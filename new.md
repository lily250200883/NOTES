#####1、预习课程：http://www.tmooc.cn/web/login.html 账号：web1702n_pm@tedu.cn 密码：PM2017tarena
        下载作业网址：code.tarena.com.cn 用户名：tarenacode 密码：code_2013 WEBCode/wfd1702/AM/PM/ALL
        web服务器=Apache
        PHP100自学视频：https://pan.baidu.com/share/link?shareid=3623474815&uk=171029850
        xampp开发手册,官方下载地址：https://www.apachefriends.org
        normallize.css 标准化CSS网站
        animate.css动画网站
        bootstrap.css一个全面的样式库
        jquery.com   jquery官方网站
        201801级：web1711n_pm@tedu.cn       密码：PM2017tarena
        zhangdong@tedu.cn  张东
        **创建对象的方法
        **三种循环的区别
        **递归
        cocos3dx游戏开发网站
        polyfill网站：developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
        图标获取：阿里巴巴iconfont（现在推荐）font awesome  （以后要学）
        图片素材：千图网，懒人图库，站酷
        https://github.com/liyxPro/Front-end-tutorial web前端资源汇总
        http://www.cnblogs.com/  博客园
        http://web.jobbole.com/  伯乐在线
        微信公众账号：前端大全 9秒
        http://www.ruanyifeng.com/home.html 阮一峰
        liwenhua@tedu.cn
        font ave   阿里巴巴矢量图标 千图网
        http://getbootstrap.com    中文官网：http://www.bootcss.com
        图片素材：千图网，懒人图库，站酷
        https://github.com/liyxPro/Front-end-tutorial web前端资源汇总
        0基础建站 蝉知网
        成亮：105207974
     
        cc1990.applinzi.com/insulation/index.html
     
     2、面试题：
         1、用户在浏览器中输入www.taobao.com直到看到页面之间发生了什么？
             1.操作系统访问网络上的DNS服务器，把域名转换成IP地址
             2.浏览器发起HTTP请求消息
             3.Web服务器（Apache）接收并解析请求消息，查找指定的资源，可能访问数据库，构建并返回HTTP响应消息
             4.浏览器接收并解析响应消息
             5.浏览器缓存接收到的响应内容，并解析和渲染响应内容
         2、静态网页与动态网页区别：
            静态网页：网页内容任何人在任何时间访问都是不变的
                     html/css/js/flash/视频音频
            动态网页：网页内容不同人在不同时间访问可能是不同的
                     DB/JSP/PHP/ASP.NET/NodeJS
                     JSP=HTML+Java:功能强大可靠，适合大型企业级项目（淘宝，中软，银行）--卡车
                     PHP=HTML+PHP:简单易用，适合互联网项目（百度，阿里）-----家用轿车
                     ASP.NET=HTML+C++:易用，适合windows平台，缺点花钱----贵的家用轿车
                     Node.js=HTML+ES(JS):性能好，适合于服务器端IO（input和output）密集型项目(微博，微信),数据读取和保存，
                                         不适合CPU密集型项目（大量计算，比如加密和解密，滴滴打车，天气预报，美团，适合用java,c++）----超级跑车，对跑道有要求
        PS:
             C+d取消选框  C+加号/减号:放大/缩小  空格变小手 ctrl+选取工具可以选中当前图形的图层
                   多张图片拼成一张，减少对服务器的请求次数，一次请求用background-position
                   经常变化的图适合做成img
                   不分产品，固定的小图标适合用拼成的图png
                   实现步骤：
                   1.根据想看图像大小，创建等比区域
                   2，设置背景图 以及 位置，来实现图像的显示
                   这种多图拼成的图俗称css sprites  雪碧图  精灵图
        Editplus:
             C+/(在CSS中快速注释) Tab(敲好元素字母后按tab快速成元素)
        MS：
             windows+d回到桌面
             F5刷新网页
             ctrl+b运行网页
             F12调试
             ctrl+shift+N创建模板
             F2重命名
             运行窗口：win+R
             搜网址运行过程：ping www.taobao.com
             windows+e我的电脑
             文件夹页面点F10 可出现工具栏  显示隐藏文件名和后缀
             ctrl+shift+delete清楚浏览器缓存=====ctrl+H
        webstorm：
             Alt+ left/right 切换代码视图
             alt+F2浏览网页   file里面settings可以改字体  ctrl+F查询
             ctrl+alt+下箭头可以多个复制  alt+1左侧栏隐藏
             shift+F6重命名
             ctrl+shift+u 小写大写转换
             shift+tab 成段向前缩进
             ctrl+/ 单行注释
             ctrl+shift+/ 块注释
             ctrl+shift+ +/- 展开/折叠
             ctrl+shift+ up/down 上下移动句子
             Ctrl+N 查找类
             Ctrl+Shift+N 查找文件
             Ctrl+R 替换文本
             Ctrl+Shift+Space 自动补全代码
             Ctrl+空格 代码提示
             Ctrl+X 删除行
             Ctrl+D 复制行
             Ctrl+J 自动代码
             Ctrl+E 最近打开的文件
             Ctrl+Q 显示注释文档
             Alt+F1 查找当前代码所在位置
             Alt+鼠标左键 多行代码同时编辑
             Ctrl+G 快速跳转到制定行  1378
             F2 或Shift+F2 高亮错误或警告快速定位
             代码标签输入完成后，按Tab，生成代码。
             选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。
             页头多行注释:/**+enter
     
             ctrl+alt+L 格式化代码
             Alt+回车 导入包,自动修正
             Ctrl+Alt+L 格式化代码
             Ctrl+Alt+O 优化导入的类和包
             Alt+Insert 生成代码(如get,set方法,构造函数等)
             Ctrl+E或者Alt+Shift+C 最近更改的代码
             Ctrl+F 查找文本
             Ctrl+Alt+Space 类名或接口名提示
             Ctrl+P 方法参数提示
             Ctrl+Shift+Alt+N 查找类中的方法或变量
             Alt+Shift+C 对比最近修改的代码
             Ctrl+Shift+先上键
             Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/*...*/ ）
             Ctrl+H 显示类结构图
             Ctrl+Alt+ left/right 返回至上次浏览的位置
             Alt+ Up/Down 在方法间快速移动定位
             Ctrl+Shift+Up/Down 代码向上/下移动。
             Ctrl+W 选中代码，连续按会有其他效果
             选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。
             Ctrl+Up/Down 光标跳转到第一行或最后一行下
             Ctrl+B 快速打开光标处的类或方法
        *如何自学一门新编程语言
        		1:了解背景:历史，现状，发展，特点
        		  (应用领域!!!)
        		2:搭建环境:写helloworld
        		3:数据类型
        		4:变量常量
        		5:运算符
        		6:逻辑结构
        		7:通用小程序
        		8:函数对象
        		9:常用函数库，类库，框架
        		10:实用项目
        学习编程三步：
             1.理解思路/机器式的思维方式    程序员必做50道题&常见js特效40例
             2.仿写代码
             3.反复默写
        *如何把静态网页变为动态网页
          方法1：在HTML中混编入PHP语句
        	    (1)前端人员编写.html
          	(2)后台人员把.html重名为.php，穿插入PHP语句
                 优点：一次请求，就可以获取到所有的动态数据
                 不足：不便于分工协作，代码的可维护性差
          方法2：使用AJAX在静态页面加载完成再异步请求动态数据
             (1)前端人员编写.html（没有动态数据）；同时后台人员编写.php（没有任何HTML/CSS/JS——返回纯JSON）
             (2)客户端请求.html，等静态页面加载完成，再异步请求.php获取动态数据
                 好处：便于分工协作，前后台彻底分离，代码的可维护性高！
                 不足：静态HTML结构和动态数据需要分多次请求
     ===================================================HTML=================================================================
        &times;关闭按钮   空格&nbsp; &lt+&gt <>  &copy @   &yen; 人民币  &laquo;《  &raquo;》
     1、结构标签：header nav section aside article footer
     2、可以设置为0/none的元素：border outline text-decoration
     3、sup上标 sub下标
     4、hr属性：size color width align
     5、元素标准属性：id title class style
     6、页面中允许修改尺寸的元素：
        行内元素 span,i,b,s,u,sub,sup,(img,a)不可修改尺寸
        行内块：多个元素能在一行内显示，允许修改尺寸---表单控件元素(单选按钮radio,checkbox复选框除外)
        img,table可修改尺寸，本身具备width和height属性的行内元素
        块级元素 div,h1~h6,p,ol,ul,li,dl,dd,(结构标记)
     8.外边距设置为0 ：body,p,h1,h2,h3,h4,h5,h6,ol,ul,dl,dd,pre{margin:0;}
       允许修改尺寸：块级元素，行内块元素（radio和checkbox除外），img,table,    行内元素不能修改
     9.lorem+Tab：一堆字符
     10.具备默认外边距的元素：body,p,h1-h6,ul,ol,dl,dd,pre(通过css重写：body,p,h1,h2,h3,h4,h5,h6,ul,ol,dl,dd,pre{margin:0;})
     11.外层元素用ID  里面可以用class
     12.背景色是从边框位置处开始绘制的
     13、锚点 <a name="自定义名称">内容</a>
             <ANY id="自定义锚点名称"></ANY>
        链接到锚点
             跳转到本页的锚点<a href="#锚点名称">内容</a>
             跳转到其他页面的锚点<a href="页面的URL#锚点名称">内容</a>
     14、创建表格
        定义表格<table></table>
        行<tr></tr>
        列<td></td>
        table属性：width height align border bgcolor cellspacing外 cellpadding内
        tr属性：align水平 valign垂直 bgcolor
        td属性：align水平 valign垂直 width列宽 height列高（colspan跨列 rowspan跨行 被合并的单元格需要删除）
        标题<caption></caption> “caption紧跟在table之后”
        th放在tr中，字体有加粗效果
        表头：<thead></thead> 表主题：<tbody></tbody> 表尾：<tfoot></tfoot>
     15、只需要输名称，不需输数值
        disabled readonly checked reversed multiple selected
     16、列表：
         有序列表ol:1,A,a,I,i
         无序列表ul:disc circle squre none(list-style)
         定义列表（图文混排）
         <dl>
          <dt></dt>
          <dd></dd>
         </dl>
     18、表单：
         <form action=""
                 method="get/post/delete/put"
                 enctype="1.applycation/x-www-form-urlencoded;2.multipart/form-data;3.text/plain"
                 name=""
                 id=""></form>
             表单控件：
     	1>.input使用：用户名/密码/单选按钮/复选框/按钮/隐藏域和文件选择框
              <input
     	            type="text/password/radio/checkbox/submit/reset/button/image（后须跟src=“”）/hidden(隐藏域)/file（电脑中选择文件）"
     	            name="txtName/txtPwd/rdo.../chk.../btn（submit提交表单数据给服务器,reset将表单恢复到初始化的状态,button由用户自定义功能）/txt(hidden,file)"
     	            value="(框里显示文本)"[disabled(禁用且不被提交) readonly(允许被提交)placeholder(占位符) maxlength “文本框专有属性”]
     	            [checked(无值)“单选按钮和复选框使用”]>
              其他按钮<button>内容</button>
         2>.多行文本textarea:<textarea name="txt" cols="" rows="" readonly></textarea>
     	3>.下拉选项框和滚动列表select和option:
             ex:
                 <select name="sel" size="显示多少项的数值" multiple(设置多选)>
                   <option value="选中值" selected（无值，预选中值）></option>
                 </selet>
     	4>.关联文字与空间<label for=“提前给要关联的单选起好ID,再填给for”></label>
     	5>.空间分组<fieldset>(会把选好的部分用线框起来)
     	            <legend>分组标题</legend>
     	          </fieldset>
     19.新表单：<input type="email/search/url/tel/number（用户年龄）/range（年龄范围）/color/date/week/month">
                其中number和range，有min/max/step属性，range更有value属性（初始值）
     ====================================================CSS初级================================================================
     1.css(cascading style sheets)样式特征：继承性，层叠性，优先级（内联样式最高），调整显示优先级（样式属性：值 !important）
             ex:background:blue !important;
         优先级顺序：
                 浏览器的默认设置    低
                 内部样式和外部样式  中（就近原则）
                 内联样式            高
     2.选择器：
        1.基础选择器:通用选择器  *{样式声明}
                     元素选择器  div{}
                     类选择器   （多类选择器 <p class="类名1 类名2 类名3"></p>
                                   分类选择器  元素选择器.类选择器名称{样式声明}）类名不可以包含特殊字符，除“-”“_”外
                     ID选择器    #idvalue{样式声明}
                     群组选择器  div,p,.myf,span.myC,#d1{样式声明}
                     后代选择器  选择器1 选择器2 选择器3{样式声明}
                     子代选择器  选择器1>选择器2{样式声明}
                     伪类选择器   1.链接伪类:link,:visited
                                  2.动态伪类:hover（鼠标悬停）,:active（被激活）,:focus（获取焦点-文本框和密码框）
                                  3.目标伪类(锚点伪类)：:target/elem:target  a标记用锚点
                                               ex:<div>-------------------------同页面锚点<a href="#需要链接的锚点的id"></a>
                                                      <a href="#img1">图片1</a>
                                                      <a href="#img2">图片2</a>
                                                      <a href="#img3">图片3</a>
                                                  </div>
                                                  <div id="container">
                                                       <img id="img1" src="01.jpg">
                                                       <img id="img2" src="02.jpg">
                                                       <img id="img3" src="03.jpg">
                                                  </div>
                                  4.结构伪类：:first-child   匹配属于其父元素中的首个元素---------------有兼容性问题IE8
                                                    ex:#tbl td:first-child{}---->td父元素tr的第一列
                                              :last-child
                                              :nth-child(n)  匹配属于其父元素中的第N个元素
                                                    ex:tr:nth-child(2) td:nth-child(3)  第二行第三列
                                              :empty 匹配每个没有子元素（包含文本）的元素，且不能有空格------ex:<div> </div>无法匹配
                                              :only-child 匹配其父元素中的唯一子元素的元素
                                  5.否定伪类：将指定选择器匹配的元素排除出去   :not(selector)---------------有兼容性问题IE8
                                             ex:#tbl tr:not(:first-child) 除第一行之外的所有行
                                                 	td:not(:first-child){font-size: 32px;}-----除第一列以外的所有列
                                  6.伪元素选择器:---------------有兼容性问题IE8
                                       伪类与伪元素区别：前者匹配元素，后者匹配一部分内容（首字符，首行文本）
                                              :first-letter/::first-letter （修改首字符）
                                              :first-line/::first-line （修改首行文本）   ***:first-line与:first-letter冲突时，用的效果是first-letter
                                              ::selection （修改被用户选取的部分）***只允许修改文本颜色和背景颜色
                                              :与::区别-->在css3之前，伪元素使用的是:，在css3之后，伪元素使用::
                                       内容生成：
                                           伪元素选择器:before或::before(匹配到某元素的内容区域之前)
                                                        属性：{content:“”/‘’;} 图片url()
                                                             ex:<p>(:before)床前明月光</p>
                                                             ex:p:before{content:"子曰";}
                                                                <p>人之初，性本善</p>
                                                        :after或::after   (为匹配某元素的内容区域之后)
                                                        属性：{content:“”/‘’;} 图片url()
                                                            ex:  p:after{content:"疑是地上霜";}
                                                                 <p>床前明月光(:after)</p>
        2.复杂选择器
              1.兄弟选择器：平级元素，只能向后找兄弟，不能向前找兄弟
                    相邻兄弟选择器：选择器1+选择器2{}(选择器1旁边的兄弟选择器2有影响)  P+P{}---(除第一个p之后的所有平级p都有影响)
                    通用兄弟选择器：选择器1~选择器2 ex:#d1~div(除d1以外，后面所有平级div都受影响)
              2.属性选择器：想匹配页面所有文本框[]
                    1.[attr]匹配页面中附带attr属性的所有元素
                         ex:[id]  [type]  [disabled]
                    2.elem[attr]表示具备attr属性的任意元素
                         ex:div[id]
                    3.[attr1][attr2]同时具备attr1和attr2属性的元素
                         ex:input[class][type]
                    4.[attr=value]页面中所有attr属性值为value的元素
                         ex:[id=parent]/等同于#parent [class="container"]/等同于.container
                    5.[class~=value]value为class众多属性值之一的选择器
                         ex:div[class~=important]{}   <div class="heavy important parent"></div>
                    6.[attr ^=value]以...作为开始
                         ex:<div class="col-sm-3"></div>---->div[class^=col]
                    7.[attr *=value]包含...字符
                         ex:<div class="col-md-12"></div>...<div class="col-sm-12"></div>----->   div[class*=md]{}
                    8.[attr $=value]以...作为结束
     3.选择器优先级：权值：元素选择器1
                            类选择器10
                            伪类选择器10
                            ID选择器100
                            内联样式1000
     4.尺寸单位：%(相对单位)
                 in(英寸)
                 cm,mm,pt(1磅=1/72in，表文字大小)
                 px(像素)
                 em(相对于父元素乘以倍数)
                 rem(相对根元素字体大小乘以倍数)
     5.颜色单位：英文单词blue,red,yellow
                  rgb(r,g,b)-----r,g,b:0-255
                  rgb(r%,g%,b%)
                  rgba(r,g,b,alpha)------alpha：透明度，0-1的小树，值越大越不透明，趋近于0更透明
                  #rrggbb-----由0-9和A-F的数组或字母组成，#000000-黑色，#ffffff-白色，#eeeeee-灰色，#1fab24,#11ffaa
                  #rgb-----#fff
     6.尺寸：width/min-width/max-width      height/max-height/min-height
       溢出：overflow/overflow-x/overflow-y
             取值：visible(内容可见，默认值）/hidden（隐藏溢出部分）/scroll（滚动条）/auto(溢出时显示滚动条，未溢出不显示)
     7.边框：border:width style(solid/dotted/dashed) color;        border:0(border:none);
       使用：border-方向(top/bottom/left/right)：width style color;
              border-属性:值；border-width/style/color;
              border-方向-属性:值；
       边框倒角：border-radius:px/%;
       边框阴影：box-shadow:h-shadow v-shadow blur(模糊距离) spread(阴影大小) color inset(外阴影改内阴影);
                 ex:box-shadow:10px 10px 30px 10px green;
     8.轮廓：outline:width style color;(修改input激活时的轮廓)
             outline-width:/outline-style:/outline-color:
             outline:none/0;
     9.框模型： 1.外边距：margin-top/bottom/left/right:(单位：px/%(相对于父元素的百分比)/auto（上下无效，左右有效）/负数移动)；
                     简洁写法：margin:v1 v2 v3 v4;/v1 v2(左右) v3;/v1 v2;
                     特殊效果：1.当两个垂直外边距相遇时，他们将合并成一个外边距，距离以数据大的值为主
                            行内元素设置垂直外边距无效(img除外)
                            行内块元素，设置垂直外边距，整行元素都跟着发生改变
             ******************2.外边距溢出：在某种条件下，为子元素设置上外边距有可能会作用到父元素上
     				             条件：
     					               1、父元素没有上边框
     					               2、为第一个子元素设置上外边距时
     				             解决方案：
     					           1、为父元素加上边框
     						            可以设置为透明
     						            弊端：会增加父元素高度
     					           2、用父元素上内边距取代子元素上外边距
     						            弊端：会增加父元素高度
     					           3、在父元素下第一个子元素加个空的<table>元素
     						            弊端：多一个元素
                                    4、父元素中使用overflow:hidden
                                    5、第一个子元素位置处，生成一个空内容，display:table;
                                       ex:#dd(父元素):before{content:"";display:table;}
                2.内边距：padding-top/right/bottom/left:(单位：px/%/auto（上下无效，左右有效）)；
                  简洁写法：padding:v1 v2 v3 v4;/v1 v2(左右) v3;/v1 v2;
                ******box-sizing:content-box(默认);/border-box;
     10.背景：background-color：red;
              background-image：url("");
              background-repeat:repeat（默认）/no-repeat/repeate-x/repeat-y;
              background-size:width height/width% height%(*相对于元素本身宽高的百分比)/
                              cover(将背景图等比放大，直到背景图完全覆盖到元素所有区域)/
                              contain(等比放大，只要有一边接触到元素某一边就不再放大);
              background-attachment(背景图片固定）：scroll(默认)/fixed(鼠标滚动而图片不动);
              background-position:x y/x% y%/(left/center/right) (top/center/bottom);
              background:color url() repeat attachment position;(简写)以上属性值可以按需求去写，不需要的可以省略，省略采用默认值
              background:red;
              background:url() no-repeat right center;（background:url repeat position;）给3个值
     11.渐变：
        线性渐变：background-image:linear-gradient(angle方向或角度：to top=0deg/to right=90deg/to bottom=180deg/to left=270deg/0deg~360deg,
                                               color-point1(颜色值 位置值),
                                               color-point2,...)
                  ex:background-image: linear-gradient(270deg,red 0px,yellow 100px,blue 200px);
        径向渐变：background-image:radial-gradient(size at position半径值 关键字 圆心所在位置：
                                      color-point1,
                                      color-point2,...)
                  注意：size at position 是可以省略的
                  ex:background-image:radial-gradient(200px at left top,blue,red);-----200px为起始到结束距离
                     background-image:radial-gradient(100px at right top,red 0%,blue 30%,yellow 70%);
        重复线性渐变：background-image:repeating-linear-gradient:(to bottom,red 0%,green 10%,blue 20%)
        重复径向渐变：background-image:repeating-radial-gradient:(100px at right top,red 0%,blue 30%,yellow 70%);
        不支持渐变的浏览器，可以添加浏览器前缀来适应渐变效果：(www.caniuse.com-----查询浏览器是否支持)
           浏览器前缀：火狐firefox：-moz- （-moz-animation:值；）
                       谷歌和苹果chrome &safari：-webkit-
                       欧朋opera：-o-
                       微软IE：-ms-
                     如果浏览器不支持属性的话，前缀则加在属性名称前：
                    （-moz-animation:值；）...
                     如果浏览器不支持属性值，前缀则加载属性值前面：
                     ex:background-image:-moz/webkit/o/ms-linear-gradient();...
     12.字体属性
        如果字体包含中文，特殊符号，最好用“”或者‘’引起来
        font-size:px（像素）,pt（磅）,em(父元素倍数),rem(字体倍数)
        网络中字体默认16px 英文8px*16px
        font-family（字体）:Arial,"微软雅黑"，“黑体”
        font-weight:normal/bold/整百倍数的数字（400正常，900bold)
        font-style(斜体）：normal/italic;
        小型大写字符：font-variant:normal/small-caps;
       字体简写方式：font:style variant weight size family;(使用简写模式，family的值必须要设置，否则无效)
     13.文本属性
        color：(颜色)
        text-align:left/center/right/justify(两端对齐);(文本排列)
        text-decoration:none/underline/overline(上划线)/line-through--><s></s>;
        line-height:px/无单位数字表倍数；(行高)   *****line-height=元素height就可以设置垂直居中
        text-indent:px（首行文本缩进）
        text-shadow:h-shadow v-shadow blur color;(文本阴影);(同box-shadow)
        文字发光：text-shadow:0 0 1px red;
        ex:font:12px/24px"微软雅黑"（12px是字体大小，24px是行高）
     14.表格属性
        padding（边距）表格中margin无效
        width height()
        font-*,text-*（文本格式化）.
        background-*（背景）
        border（边框）
        vertical-align:top/middle/bottom;(仅限于表中文本垂直方向对齐)
        table特有属性
        border-collapse(边框合并):seperate(分离边框）/collapse(边框合并);------设在table属性上的
        border-spacing(边框边距):一个值（水平垂直相同）/二个值(水平 垂直);注意：此属性仅在分离模式（border-collapse:seperate;）下使用------设在table属性上的
        caption-side(标题位置):top（位于表格上）/bottom（位于表格下）;
        table-layout（显示规则）:auto(宽度由内容决定)/fixed（设定宽度）；
     15.定位-浮动
        普通流定位（默认定位）
        浮动定位：脱离文档流，不占据页面空间，后面未浮动元素会上前补位，浮动元素会停靠在父元素的左边或右边，或其他平级的已浮动元素的边缘上，
                  浮动只能在当前行内浮动，解决了块级元素在一行内显示的问题。
                  float：left/right/none;
                  特殊效果：1.如果父元素显示不下所有已浮动元素，最后一个将换行显示
                            2.元素一旦浮动起来之后，那么宽度将由内容来决定（非手动指定情况下）
                            3.元素一旦浮动起来后，那么将变成块元素，对行内元素影响最大，因为行内元素默认不能修改尺寸，变成块级后，允许修改尺寸
                            4.文本，行内元素，行内块元素在页面中采用环绕的方式在排列的，他们不会被浮动元素压在底下，而是会巧妙的避开浮动元素
                  清除浮动：清除当前元素前面的元素浮动所带来的影响
                            clear:none(不做任何清除动作)/left（清除当前元素的前面元素左浮动带来的影响）/right(同理)/both（清除左和右浮动）;
     ************解决浮动元素对父元素高度的影响:1.直接设置父元素的高度（弊端：必须要知道父元素的高度是多少）
                                                   2.设置父元素也浮动（弊端：对后续元素位置有影响）
                                                   3.设置父元素overflow属性为hidden或auto（弊端：如果有内容要溢出显示，如弹出菜单，也一同被隐藏了）
                                                   4.父元素中追加一个空块级元素，并设置其clear为both（在网页中多个元素而已）
                                                   5.解决方案4的简便写法，CSS3高级解决:.clear(父元素):after{content:"";display:block;clear:both;}
     16.显示
        1.显示/隐藏
             display:none(让生成的元素没框，即隐藏页面元素并脱离文档流)/block(生成块)/inline（生成行内元素）/inline-block(生成行内块)/table(生成像table一样的元素)
             visibility(规定元素是否可见):visible(可见)/hidden（隐藏，未脱离文档流）/collapse（动态删除表格一行或一列，不影响表格整体布局）
                 ****display:none;和visibility:hidden;区别：隐藏元素，是否脱离文档流，前者脱离，后者未脱离
        2.透明度：
             opacity(透明度)：0.0~1.0(完全透明~完全不透明)   IE filter=filter(opacity=0-100);
                 *****rgba与opacity区别：前者只作用于元素的文本或者背景颜色，后者作用于元素的所有内容
        3.垂直方向对其方式
             vertical-align（垂直对齐）:baseline(基线对齐，对于行内文本来说，即在最后一行文本的下方默认值;对于图片，位于图片下方3px位置处)/top/middle/bottom；
             vertical-align使用场合table(td)/行内块元素/img
        4.光标：
             cursor:default(默认)/pointer(小手)/crosshair(+)/text(I)/wait(等待)/help(帮助)
     17.列表
        list-style-type(列表类型):none/disc/circle/squre.;
        list-style-image(列表项图像):url();
        list-style-position(列表项位置):outside(内边距里，li外)/inside（li里面）;
        list-style:type url position;
        最常用：list-style:none;
        使用场合：纵向排列或横向列表
     18.display:block/inline-block;(有把元素隐藏后再显示功能)（visibility:hidden;隐藏）
        inline显示隐藏后的行内元素
     19.定位属性 position:static(静态定位，默认)/relative(相对定位)/absolute(绝对定位)/fixed(固定定位)；
                 注意：除static以外，其他的定位方式都称之为“已定位元素”
        偏移属性：只有“已定位元素”才能使用，top(取值为正，下移；取值为负，上移)/bottom(上为正，下为负)/left(右为正，左为负)
                                              /right(左为正，右为负)/*框里都为正，框外为负*/
        相对定位：相对它原来位置偏移；
                  {position:relative;top:20px;}
                  使用场合：位置微调，配合绝对定位元素实现位置
                  特点：元素原本所占据的空间依然会被保留，不会被其他元素所占据
        绝对定位：特点：1.绝对定位元素会脱离文档流（不占空间）
                        2.绝对定位元素通过偏移属性固定位置
                        3.绝对定位元素会相对于它最近的已定位的（relative,absolute,fixed） 祖先元素，来实现位置初始化
                        4.如果没有已定位的祖先元素，会相对于最初的包含块（body/html）来实现定位
                  适用场合：弹出框
                  {position:absolute;top:5px;left:-5px;}
                  注意：1.绝对定位元素会变成块级元素
                        2.绝对定位元素默认情况下margin：auto会失效，其他正常
             ****3.top:0;right:0,bottom:0;left:0;margin:auto;(可实现既水平又垂直的居中效果)
        堆叠顺序：z-index:无单位数值（数越大越靠上，数越小就会压在下面，负数为页面所有内容最下）；
                  注意：默认后来者居上，父子关系不受堆叠顺序影响（永远都是子压在父上）
        固定定位：{position：fixed;top:5px;left:-5px;}
                  特点：固定定位元素永远都是相对于body实现定位
                        固定定位元素会脱离文档流
                        固定定位元素会变成块级元素
     20.隐藏的4种方法：
           <div style="display: none;">DISPLAY: NONE</div>   可选择
           <p style="visibility:hidden;">VISIBILITY: HIDDEN</p>  不可选择
           <span style="opacity: 0;">OPACITY: 0;</span>  不可选择
           <input type="hidden" name="id" value="123"/>  可选择
     ===================================================css高级==============================================================
     1.弹性布局（flexible box:处理某元素内子元素的排列方式）
          包含：flex container(flex容器),flex item(flex项目),main axsis(主轴),cross axsis(交叉轴),main start(主轴起点),cross start(交叉轴起点)
          注意：子元素的float,clear,vertical-align,text-align会失效
          属性：1.display:flex/inline-flex;    兼容性：display:-webkit-flex;
                2.容器属性：1.flex-direction:row/row-reverse/column/column-reverse;
                                      (指定主轴方向:横轴，起点在左端，是默认值；横轴，起点在右端；纵轴，起点在顶端；纵轴，起点在底端)
                            2.flex-wrap:nowrap(默认值，不换行且等比缩放)/wrap（换行）/wrap-reverse(第一行在最底部);
                                       （一行内显示不下，如果换行）
                            3.flex-flow:row nowrap(默认值)/direction wrap;(是flex-direction和flex-wrap的缩写)
                            4.justify-content:flex-start(主轴起点对齐)/flex-end(主轴终点对齐)/center/
                                             space-between(两端对齐)/space-around(中间间隔是两边靠边的间隔大一倍)；
                                           （注意：根据主轴方向来确定效果）
                            5.align-items:flex-start(交叉轴起点对齐)/flex-end/center/baseline(第一行文字最下的基线文字对齐)/
                                          stretch(默认值，如果项目为设置高度或高度为auto是，将占满整个容器的高度);(一行项目为主)
                            6.align-content:flex-start(在交叉轴起点对齐)/flex-end/center/
                                            space-between(与交叉轴两端对齐，轴线之间间隔相等)
                                            space-around(每个轴线两端间隔相等，轴线间隔比轴线与父元素边框间隔大一倍)/
                                            stretch(默认值，在不指定项目高度时，占满整个交叉轴);
                                           （容器具备多根轴线时，即自动换行时，项目对齐方式）
                3.项目属性：1.order(项目排列顺序)：0/没有单位的数字(排序，值越小，越靠前，默认为0)；
                           2.flex-grow(项目放大比例):0/1/正数数值(如果有一个元素取值为1，那么剩余空间内，所有将占满整个空间；
                                        多个元素为1时，剩余空间大家平分)；(如果当前排列轴有空余空间，项目将如何放大)
                           3.flex-shrink(项目缩小比例)：0（空间不足时，不缩小）/1（空间不够时等比缩小）/数字；(默认为1，空间不足时，等比缩小)
                           4.flex-basis(指定项目所占空间大小):auto（本身大小）/length(指定宽高，取决于主轴方向)；
                           5.flex:auto(1 1 auto)/none(0 0 auto)/flex-grow,flex-shrink,flex-basis(自定义);
                                   (flex-grow,flex-shrink,flex-basis简写)
                           6.align-self:auto/flex-start/flex-end/center/baseline/stretch;
                                   (定义当前元素与其他元素不一样的交叉轴对齐方式，可以覆盖align-items值，默认为auto,即继承父元素的align-items)
     2.转换
           转换属性：transform:none(默认值)/一组转换函数（表示一个或多个转换函数，中间用空格分开）;
           转换原点：transform-origin:0px 0px;/0% 0%;/left top;(x和y两个值)(三个值是x,y,z轴)
                     默认原点位置：50% 50%或center center;
           2D转换：
              1.2D位移：
                  transform:translate(x)在X轴上的位移距离;/translate(x,y);/translateX(x)只在x轴上位移;/translateY(y)只在y轴上位移;
              2.2D缩放：
                  transform:scale(value)(x和y轴的缩放比例);
                            scale(x,y)(分别指定x和y轴的缩放比例);
                            scaleX(x);
                            scaleY(y);
                            value>1是放大比例；1>value>0缩小的比例；负数呈现斜对角放大或缩小（物极必反）
              3.2D旋转：
                  transform:rotate(ndeg);(n为具体角度，取值为正顺时针旋转，取值为负逆时针旋转)
            *****注意：1.转换原点位置会影响转换效果
                       2.元素旋转后，连同坐标轴也一起旋转，会影响旋转后的位移效果，且旋转和位移是有顺序影响的
              4.2D倾斜:(变平行四边形,正数是y轴逆时针旋转，负数y轴顺时针倾斜)
                  transform:skew(xdeg);x轴倾斜，实际上是改变了y轴的倾斜角度,取正值是Y轴逆时针倾斜，取负值是Y轴顺时针倾斜
                            skewX(xdeg);x轴倾斜，实际上是改变了y轴的倾斜角度,取正值是Y轴逆时针倾斜，取负值是Y轴顺时针倾斜
                            skewY(ydeg);Y轴倾斜，实际上是改变了X轴的倾斜角度,取正值是X轴顺时针倾斜，取负值是X轴逆时针倾斜
                            skew(xdeg,ydeg)
       ****3D旋转:第1步.perspective:...px;(模拟透视距离,取值越大，离转换物体越远，取值越小，离转换物体越近。)
       ***********注意：该属性要加在3D转换元素的父元素上
                        兼容性：chrome&safari:-webkit-perspective:...px;
                  第2步.transform:rotateX(xdeg);以x轴为中心旋转元素（取值为正的顺时针旋转，负的是逆时针旋转）
                                  rotateY(ydeg);
                                  rotateZ(zdeg);
                                  rotate3d(x,y,z,ndeg);3个轴取值为大于或等于1的轴要参与旋转；取值为0的轴不参与旋转
                                  ex:rotate3d(1,0,0,45deg);x轴旋转45度，其余不动；
                                     rotate3d(1,1,1,45deg);3个轴同时旋转45度；
       ****3D位移:第1步:transform-style:flat;默认值，不保留其子元素的3D属性 (加在父元素上)
                                        preserve-3d;保留其子元素的3D位置
                  第2步:transform:translateZ(z);正值为前，负值为后，
                        translate3d(x,y,z);
     3.过渡
           1.过渡属性：transition
           transition-property:none/all/propertyName;
            ex:背景颜色变化时，将采用过渡效果呈现
               transition-property:background-color;
             **允许使用过渡的属性：
               1.颜色属性；
               2.取值为数值的属性；尺寸  边距  4个方向
               3.转换属性：transform---缩放，位移，倾斜，旋转
               4.渐变
               5.visibility
               6.阴影
           2.过渡时间：
               transition-duration:s和ms为单位的数值；
               1s=1000ms
               注意：默认值为0，即无任何过渡效果产生；
               ex:transition-property:background;
                  transition-duration:2ms;(2毫秒内匀速换背景色)
                  transition-timing-function:linear;
           3.过渡速度时间曲线函数（速率）：
               transition-timing-function(时间函数):ease(先慢后快再慢)/
                                                    linear(匀速)/
                                                    ease-in(慢速开始，加速结束)/
                                                    ease-out(快速开始，减速结束)/
                                                    ease-in-out(先慢后快再慢，比ease急一些);
           4.过渡延迟：激发操作后，等待多长时间
               transition-delay:以s或ms为单位的数值
           注意：在元素里头写过渡是管去管回，在hover里只有去没有回,hover里只放转换动作
                 ex:
                 		img{
                 			transition:all 2s linear 2s;
                 		}
                 		img:hover{
                 			transform: scale(1.5);
                 		}
                 多个过渡值在后面加逗号再写别的过渡值
           5.过渡简写模式：transition:property duration timing-function delay;
              ex:transition:property1 duration1 timing-function1 delay1,property2 duration2;
     4.动画（animation）
                1.声明动画(为动画起名)：
                  @keyframes 名称{/*声明 若干 关键帧（时间：动作（样式））*/
                  0%/from{/*动画开始时的动作*/}
                  25%{/*动画运行到1/4时的动作*/}
                  ...
                  100%/to{/*动画结束时的动作*/}
                  }
                  兼容性： @-webkit-keyframes 名称{} @-moz-keyframes 名称{} @-o-keyframes 名称{} @-ms-keyframes 名称{}
                    1.为动画定义名称
                    2.定义动画所有关键帧
                2.为元素调用动画（谁想用谁来引用）
                  1.animation-name:(指定当前元素要调用的动画名称)
                  2.animation-duration（完成当前动画执行的总时长）:s/ms;
                  3.animation-timing-function(指定动画执行的速度时间曲线函数):
                                              ease/
                                              linear/
                                              ease-in/
                                              ease-out/
                                              ease-in-out;
                  4.animation-delay(延迟):s/ms;
                  5.animation-iteration-count(指定动画播放次数):
                                             数值(默认1次)/
                                             infinite(无限次播放)
                  6.animation-direction(指定动画播放方向0%~100%或者100%~0%):
                                             normal(默认值，从0%~100~)/
                                             reverse(从100%到0%)/
                                             alternate(normal和reverse轮流播放，奇数播放次数时，从0%~100%；偶数播放次数从100%~0%);
        不可以简写7.animation-fill-mode(规定动画在播放前或播放后的状态):
                                             none(默认)/
                                             forwards(动画完成后，保持在最后一个帧的状态上)/
                                             backwards(延迟时间内，保持在第一个帧)/
                                             both(播放前后保持分别保持在第一个帧和最后一帧上);
                  8.animation-play-state:paused(暂停)/running(播放);(指定动画的播放状态：播放|暂停)
                3.简写模式：
                  animation:name duration timing-function delay iteration-count direction;
                  ex:animation:change 3s linear 1s 3 alternate;
                ***********加载时就执行动画，在元素声明里调用；如果移入时调用，在hover调用
     5.CSS Hack(IE浏览器兼容):针对不同的浏览器编写不同的属性
           1.浏览器浏览模式：
                         标准模式：完全按照W3C的标准显示网页
                         准标准模式：支持标准，同时向前兼容非标准
                         混杂模式：不按标准解析内容，以IE自己的标准为主
           2.在HTML中，可以通过<!doctype>进行模式选择
              1.触发混杂模式，不声明<!doctype>即可，采用IE5.5内核进行页面渲染
              2.触发准标准模式
           <!doctype html>标准模式
           csshack原理：使用样式属性的“优先级”来解决兼容性问题。
           csshack的实现方式：1.css类内部hack：在样式属性名称前或样式属性后增加些前后缀，来适配不同的浏览器
                              2.css选择器hack
                              3.html头部引用hack（掌握）
                              条件注释语法：<!--[if 条件 IE 版本号]>  满足浏览器要执行的内容  <![endif]-->
                              版本号：1、IE6-10  2、省略版本号，判断是否为IE浏览器
                              条件：1、gt 判断当前浏览器是否大于指定版本的浏览器
                                       <!--[if gt IE 8]>该内容只能在IE8（不含8）以上版本执行<![endif]-->
                                    2.gte 判断当前浏览器是否大于等于指定版本的浏览器
                                    3.lt  判断当前浏览器是否小于指定版本的浏览器
                                    4.lte  判断当前浏览器是否大于等于指定版本的浏览器
                                    5.！判断当前浏览器是否是非指定版本浏览器
                                    6.省略条件   判断当前浏览器是否是指定版本浏览器
                                       <!--[if IE 6]>只在IE6中执行<![endif]-->
     6.css代码优化
     =============================================javascript初级=================================================================
     将十进制数转二进制: n.toString(2)
     每个汉字占2字节
     查看一个字的unicode号: str.charCodeAt();
     				数字0~9: 48~57
     				大写字母A~Z: 65~90
     				小写字母a~z: 97~122
     				汉字: \u4e00~\u9fa5
     路径中的\:将\换成/ ——强烈建议, 任何操作系统都认
     bool: true->1  false->0
     模运算判断：能否整除，奇数，偶数，闰年
     按指定位数四舍五入: n.toFixed(2)
     一、Javascript基础知识：
         1、javascript使用场景：数据计算，表单验证，动画效果
         2、NETScape:网景
         3、javascript祖师爷：布兰登艾奇
         3、相关语言：
             ECMAScript:ECMA组织制定的javaScript标准（ES3+ES5+ES6）
             JavaScript:NetScape按照ECMAScript标准实现的JavaScript语言版本
             JScript:微软根据ECMAScript标准实现的Javascript语言版本
         4、JavaScript组成三部分(原生JS语言)：
             1.核心语法：ECMAScript制定 7天初级+5天高级
             2.DOM标准：规定了专门操作网页内容和样式的程序 2天
             3.BOM:专门操作浏览器的程序 2天
         5、Javascript运行环境：专门用来解释并执行程序语言的小软件（脚本解释引擎）
             1.浏览器自带：内容排版引擎、脚本解释引擎
             2.独立安装：nodeJS（从chrome浏览器中单独剥离出来的独立的脚本解释引擎）
                 以前语言：前端：JS   后端：PHP/JAVA  数据库：SQL
                 现在语言：前端：JS   后端：nodeJS    数据库：MongoDB(支持JS语言)  实现前后端js通吃
         6、如何编写：
             1、网页内编写：新建html文档，在<body>下写入<script></script>（即js与html写在同一个文件中）；
                         问题：不便于维护和重用；
             2、在专门的js文件中编写，在网页中引入：网站项目，新建html文档，body中写入<script src=".js文件路径"></script>
                         强调：一个script标签，要么用于包含js代码，要么用于引入外部js文件，不能同时使用，
                         否则带src的script标签内部的内容会自动失效。
             3、在浏览器控制台/nodeJs中编写js指令：测试小程序；
                         1、控制台：
                         操作：按回车执行
                              按shift+回车是仅换行，但不执行
                              上下键切换写过的代码，反复修改使用
                              清屏，左上角叉号，或者ctrl+L
                         2.nodeJS:（安装视频在nodeday01的nodejs01.wmv的01:28处）
                         操作：win+R调出窗口控制台
                         运行：1.交互模式：node 回车（交互模式自带输出打印功能，不用写console.log()）；
                         3.NodeJs（版本8.9.1LTS--long term support ）与JS区别：JS运行在客户端，NodeJs运行在服务器端的V8引擎
     三、基本语法规范:
     	1、程序: 3步: 1.输入，2.处理，3.输出
     		1. 输入: 向网页中输入一个值	prompt("提示")
     		2. 输出: 向页面中输出: document.write("...");
                      向控制台输出: console.log("...");
                      弹出提示框: alert("...")
                      对话框缺点: 1. 样式不可修改
                                  2. 会阻断程序继续执行以及用户操作
     	2. 变量:
     		什么是变量: 内存中存储一个数据的存储空间，再起一个名字
     		何时: 只要反复使用的数据，都要先保存在变量中，再反复使用变量。
     	如何:
     		声明: 在内存中创建一个存储空间再起一个名字
     		何时: 只要使用变量前，必须先声明变量
     		如何: var 变量名;
     		默认值: undefined
     		简写: var 变量1,变量2,...;
           变量名:
             1. 使用字母，数字，下划线组成，不能以数字开头
             2. 不允许使用js语言的保留字/关键词
             3. 见名知义
             4. 驼峰命名:
                首字母小写，中间单词首字母大写
                比如: backgroundColor:
                     listStyleType
     	赋值: 将等号右边的值保存到等号左边的变量中
     	如何: 变量名=值;
     	简写:
     	 1. 声明同时，初始化变量的值:
     		var 变量名=值;
     	 2. 同时声明并初始化多个变量:
     		var 变量1=值1, 变量2=值2,....;
         特殊:(js广受诟病的地方1)
     	普通模式: 强行给未声明变量赋值, 不会报错！会自动创建该变量。
     	严格模式: 比普通js运行模式要求跟严格的机制
     		1. 禁止给未声明的变量赋值
     		如何启用: 在代码开始位置: "use strict";
     		取值: 任何情况下，使用变量名，等效于直接使用变量中的值。
     		特殊: 强行从未声明的变量中取值, 报错！
     		 ReferenceError : 要用的东西，没找到
     	3.常量: 值不允许改变的量
     		何时: 只要一个数据一旦定义，就不允许改变
     		如何:
                 声明: const 常量名=值;
                 强调: 声明常量时，必须初始化，习惯上，常量名要全大写！
                 赋值: 常量不允许在声明后再赋值
                 取值: 常量的用法和普通变量完全一样
             特殊: (js广受诟病的地方)
             强行修改常量的值：
             普通模式: 不报错，但也不能修改——静默失败
             严格模式: 报错！
             高版本的浏览器，将所有静默失败都升级为错误！
     	4. 数据类型:数据在内存中的存储结构（2大类）
     		1. 原始类型: 值直接保存在变量本地的数据类型5种:number  string   boolean   null    undefined
     		2. 引用类型: 值无法保存在变量本地的数据类型
     		   原始类型介绍：
                 1.number: 存储一切数字
                     何时: 只要不带引号的数字直接量，默认就是number
                     只要经常用作算数计算或比较的数值都不加引号
                     存储空间:  8字节二进制(整数4字节，浮点数-小数8字节)
                     1字节(Byte)=8位二进制数(Bit)
                     1KB=1024字节Byte
                     1MB=1024KB
                     将十进制数转二进制: n.toString(2);
                     for：var age=110000;
                         console.log(age.toString(2));
                     强调: number即包含整数，又包含浮点数(小数)
                 2.string: 保存一串字符组成的字符串
                     何时: 用于显示或记录一段文字，凡是用"或'包裹的一串文字，自动就是字符串类型
                     存储空间: 每个字符，数字，或英文标点占1字节，每个汉字占2字节
                     js中采用unicode编码存储每个字符:
                     unicode是对全球主要语言的每个文字编一个号
                     为什么: 计算机只认数字，不认字符
                 ****查看一个字的unicode号: str.charCodeAt();
                         ex:var str="生";
                            var c=str.charCodeAt();
                            console.log(c);//29983---unicode号
                         数字0~9: 48~57
                         大写字母A~Z: 65~90
                         小写字母a~z: 97~122
                         汉字: \u4e00~\u9fa5  对应unicode号：19968-40869(5位)
                     转义字符: \
                         何时: 2种:
                         1. 当字符串中包含和js语言标点符号冲突的内容，用\将冲突的字符转为原文，不再按程序解析
                         2. 要表示特殊意义:
                         \r空格  \n 换行  \t 制表符(空格) \u unicode------仅仅适用于js程序，即控制台显示
                         3.特殊情况: 路径中的\，将\换成/ ——强烈建议, 任何操作系统都认
                     3.boolean: 布尔类型: 只有两个值的类型: true/false
                         何时: 专门用于表示一个判断的结论
                     4.null: 空 让程序员手动清空一个变量
                     5.undefined: 空 由程序自动使用，为变量赋初值
             3.*注意：凡是从页面中获取的数据都为string类型，可以使用console.log(typeof n)来检测数据类型-->n为变量。
         5. 数据类型转换:将不需要的数据类型，转化为需要的数据类型
             1.js四大特点之一: 弱类型: 3大特点:
               1. 声明变量时，不需要提前指定变量的数据类型
               2. 同一个变量先后可保存不同类型的数据
               3. 不同数据类型间可相互转化
             2.何时: 只要给定的数据类型不是想要的
             3.如何转换: 2种:
               1. 隐式转换: 不需要程序员干预，由js自动完成的数据类型转换
                 何时: 只要给定的数据类型和js程序需要的类型不相符，js就会根据自己的需要，自动转化数据类型。
                 ***比如: 算数计算中:默认: 一切都转为number类型，再做计算
                     为什么: 因为number类型最适合计算
                     bool: true->1  false->0
                 ***特殊: ***+运算中，只要碰到一个字符串，那么一切都转为字符串，+运算变为字符串拼接！
               2. 强制转换: 程序员主动调用函数完成的数据类型转换，只要给定的数据类型不是想要的，且自动转换的结果也不是想要的，就要强制转换。
                    1.其他类型转number: 2种:
                         1. Number(x): 将x转为number类型
                             何时: 都是隐式转换，其实相当于自动调用Number(x)，很少主动使用。
                             问题: 只能转换纯数字组成的字符串和bool类型
                             如果转不了: 就返回NaN
                                NaN: 不是一个数字的任何值 Not a Number
                                NaN参与任何运算结果只能是NaN
                         2. parseFloat/parseInt(str):将str转为number类型，自动去除"末尾"非数字字符
                            parseFloat可保留小数部分,parseInt 去掉小数部分
                             何时: 只要将字符串转number，首选parseFloat，如果确实需要去掉小数，才选parseInt，如果转不了，也返回NaN
                             强调: 参数应该是string类型
                                  如果给定的值不是string类型，则先执行隐式转换，转为string类型，再转number
                               比如: parseFloat(true)
                                    parseFloat("true")->NaN
                    2.其他类型转string: 2种:
                         1. x.toString() 将x转为字符串类型
                             x不能是null或undefined ——不是万能
                         2. String(x) 将x转为字符串类型——万能
                             其实，隐式转为string时，都是自动调用String
                    3.其他类型转bool类型: 1种
                        Boolean(x)
                        规则: 只有5个值会被转为false:0,  "",  NaN,  null,  undefined
                             其余都转为true
                        其实, 隐式转为bool时，都是自动调用Boolean(x)
         6. 运算符和表达式:
             1.程序: 人的想法在计算机中的执行
             2.运算符: 程序中模拟人的想法的特殊符号
             3.表达式: 由数据，变量和运算符组成的完成一项单一任务的语句。
             4.算数运算: +,-,*,/,%
                   %: 模运算/取余数: 被除数/除数,不要商，要除不尽的余数部分
                     何时: 1. 取余数
                          2. 判断能否整除
                           判断偶数: 能被2整除 n%2==0
                           判断奇数: 不能被2整除 n%2!=0
                           判断闰年：
         *****隐式转换:
                 默认: 都转number
                 特殊: +运算中,碰到字符串，都转字符串，+运算变为字符串拼接。
             5.舍入误差: 计算机中，也有计算不尽的数值
               **如何解决:
                     1. 按指定位数四舍五入: n.toFixed(2)
                         今后几乎所有显示钱数的地方都要toFixed(2)
                     2. 存储: 保存很长位数的小数: 0.39999999
             6.关系运算: 用两个值做比较，做判断
               包括: >  <  >=  <=  ==  !=
               返回值: bool
               隐式转换:
                 默认: "都转number"
                 特殊:
                   1. "两个值"都是字符串, 则不再转数字，而是依次比较每个字符的unicode号
                   2. 判断NaN:
                     NaN和任何值做> < >= <= ==5种比较时，永远false
                     NaN和任何值做!=比较时，永远是true
                    问题:NaN==NaN =>false 用普通的==无法判断NaN
                    解决: isNaN(num) 专门代替==，用来判断num是不是NaN
                     何时: 只要判断是不是NaN，都用isNaN(num)---->先进行隐式转换isNaN(Number(num))
                     反用: 判断一个值是不是数字: !isNaN(num)
                   3. 区分null和undefined
                    问题：==比较时，会自动将undefined隐式转为null
                       null==undefined => null=null
                    解决: === 全等: 类型必须先相同，值再相等
                      其实===就是不带隐式转换的==
             7.逻辑运算: 将多个关系运算，综合起来得到最终结论
                 1.何时: 只要根据多个条件，综合得出最终结论时
                 2.包括: &&而且   ||或(要么)  !不(没有)
                      1.条件1&&条件2...:
                         要求所有条件都为true，结果为true
                         只要一个条件为false，结果为false
                      2.条件1||条件2...:
                         只要一个条件为true，结果为true
                         除非所有条件都为false，结果才为false
                      3.!条件: 颠倒条件的判断结果
                         **隐式转换: 默认将每个条件都转为bool类型
                    *****短路逻辑: 如果前一个条件已经可以得出最终结论，则后续条件不再执行。
                          &&: 只有前一个条件为false时，后续条件才不执行
                          ||: 只要前一个条件为true时，后续条件不再执行
                         ex:var H=226,D=2.5,B=false;
                            console.log(H>180&&D>1&&B==true);//false
                            console.log(D<10||B==true);//true
                    *****利用短路:
                          1. 简单分支结构: 1个条件，1件事，只有满足才做
                            如何: 条件&&(操作)----->因为存在优先级问题，所以操作一般加（），增加优先级；
                    *****运算符优先级：优先级高的运算先计算，需要改变优先级，可用（），优先级大小可以参考teachers note 里的operator.jpg查询优先级。
                          2.实现默认值/备用值：
                            如何：值1||值2
                                 如果值1可以转为true，就选择值1使用；
                                 如果值1不能转为true为false时，就选择值2使用。
             8.位运算:
                   1. 左移/右移:
                       1<<3=8  1左移3位 相当于1*2的3次方 代替/简化1*Math.pow(2,3);
                       2<<3=2*2的3次方=16
                       8>>3=1  8右移3位 相当于8/2的3次方
                   2. 取整:
                       n^0   n|0   n>>>0  代替/简化Math.floor(n)
                   3. 交换两变量的值:*************
                       var a=3,b=5;
                       方法一: var t=b; b=a; a=t;
                       方法二: a+=b; b=a-b; a=a-b;
                       方法三: a^=b; b^=a; a^=b;
                       方法四：a=[b,b=a][0];
                       方法五：ES6：[a,b]=[b,a]
                 赋值运算:
                   扩展赋值运算: 对特殊赋值运算的简写:
                     a=a+b 将a的值+b的值，再存回a中
                 ——将b的值累加到a上
                           可简写为a+=b;
                     a=a-b -> a-=b;
                     a=a*b -> a*=b;
                     a=a/b -> a/=b;
                     a=a%b -> a%=b;
                   更简化: 递增递减运算: 如果每次累加1/累减1
                     a+=1  ->  a++
                     a-=1  ->  a--
             9.前++和后++:
                 1. 如果单独使用, 前后都一样
                 2. 如果参与到其他表达式中时:
                   相同: 变量中的值一定都会+1
                   不同: *前*++，返回+1后的*新*值
                        *后*++，返回未+1的*旧*值
                   注意:for循环，i=0,初始值++,再循环会跳过***
                   鄙视:
                    var n=3;
                    console.log(n++ + ++n + n++);
                            //  ?   ?     ?
                    //console.log(++n + n++ + ++n);
                              // ?    ?     ?
                     console.log(n);//6
                    提示: 所有表达式都是从左向右依次执行
                         如果前一个表达式修改了变量的值，则会影响后续表达式的执行。
     3. ***函数:内存中封装一项任务步骤清单的代码段，再起一个名字。
         1. 声明: function 函数名(参数列表){
                     函数体;
                     return 返回值;
         }
              参数: 函数运行时，接收传入函数的数据的变量
                  只不过不用var创建，用function
              参数列表: 多个参数间用逗号分隔，相当于在函数内部创建的局部变量；
                何时: 当一项任务必须某些数据才能正常执行时
                为什么: 参数可让函数变得更灵活
              返回值: 函数执行的结果
                何时: 如果函数的调用者需要获得函数执行结果
                如何返回: return 返回值;
                  其实，return可单独使用: 表示退出函数
                  如果没有返回值的函数，其实也返回东西:
                      默认返回undefined
         2. 调用: 让引擎按照函数的步骤清单，执行任务。
               var 返回值=函数名(参数值列表)
              参数值列表: 传入函数的执行时必须的数据列表
                    只要函数定义时规定了参数变量，调用时都要传入参数值。且顺序和个数保持一致。
                    每个参数值之间用逗号分隔
              ===强调: 函数不调用不执行，只有调用才执行。
     ***作用域scope: 一个变量的可用范围
       包括: 2种:
         1. 全局作用域: window
           全局变量: 直接定义在全局中，不属于任何函数的变量
               特点: 可反复使用，随处可用
               何时: 如果一个变量需要反复使用，或跨函数随处可用时
         2. 函数作用域: function
           局部变量: 2种:
             1. 函数的参数变量
             2. 在函数内var出的变量
             特点: 仅在函数内可用，出了函数不能使用
                   不可重用
             何时: 如果一个变量，仅希望在函数内有效时
       总结: 优先定义并使用局部变量
             尽量少使用全局变量——避免被污染
             ex:  var x=10;
                  function fun(){
                    x=100;
                    x++;
                    console.log(x);
                  }
                  fun();//101
                  console.log(x);//101
                  ------------------
                   var x=10;
                   function fun(){
                     var x=100;
                     x++;
                     console.log(x);
                   }
                   fun();//101
                   console.log(x);//10
     ***变量的使用顺序: 优先使用函数内的局部变量
                       只要局部声明了，就不用全局的
                       除非局部没有声明，才去全局找
              ex:  var bx="可乐";
                   function room1(){
                     var ysj="纯净水";
                     console.log(ysj);
                     console.log(bx);
                   }
                   function room2(){
                     console.log(bx);
                   }
                   console.log(bx);//可乐
                   room1();//纯净水 可乐
                   room2();//可乐
     ***声明提前(hoist):在开始执行程序前，引擎会将var声明的变量和function声明的函数，
                       提前到*当前作用域*顶部集中优先创建。再开始执行程序。——赋值留在原地。
                       ex:  console.log(a);//不报错！返回undefined
                            var a=10;
                            console.log(a);//10
                       ex:  var n=10;
                            function fn(){
                              console.log(n);//undefined
                              var n=100;
                              console.log(n);//100
                            }
                            fn();
                            console.log(n);//10
          鄙视: 如果先使用，后声明，一定在考声明提前，
                就要将所有var和function提前到当前作用域的顶部，先创建，再判断程序的输出
          解决：
             1.变量：
                 传统：强烈建议将所有的声明都集中在当前作用域顶部创建
                 ES6：let代替var声明变量
                     let要求：在let之前，不允许提前使用该变量
             2.函数：
                 function 函数名(参数列表){...}====>var 函数名=function(参数列表){...}
                 ***函数本质：
                     1.函数名其实仅是一个普通的变量；
                     2.函数其实是保存代码段的引用类型的对象；
                     3.函数名通过函数对象的地址引用着函数对象；
     ***按值传递:两变量间赋值，或向函数中传入参数时，其实只是将原变量中的值复制一个副本给对方。
               结果:原始类型的值: 修改新变量，不影响原变量的值
               ex:  var a=5;
                    var b=a;
                    b++;
                    console.log(a);//5
                    console.log(b);//6
     4. 全局函数:ES标准中规定的，不需要任何对象就可直接调用的函数。
           比如: String()/Number()/Boolean()
                parseInt/parseFloat()
                isNaN()
           反例: alert()/prompt()...
     5.编码解码:将url中多字节字符或保留字符编码为单字节
         为什么: url中不允许出现多字节字符以及和保留字符冲突的字符
         何时: 只要url中包含多字节字符以及和保留字冲突的字符时，都要先编码为单字节。
         如何: 编码: var code=encodeURI(url)
               解码: var text=decodeURI(url)
         问题: 不能对保留字符编码解码,比如: ":" , "/"
         解决: 编码: var code=encodeURIComponent(url);
               解码: var text=decodeURIComponent(url);
               ex:  var kword=prompt("搜索");//将kword编码为单字节
                    kword=encodeURIComponent(kword);
                    document.write("向服务器发送请求:<br>");
                    var request="https://s.taobao.com/search?q="+kword;
                    document.write(request);
     
                    document.write("<br>");
                    document.write("Server端收到请求:<br>")
                    request=decodeURIComponent(request);
                    document.write(request);
     ***eval函数: 执行一段字符串格式的js表达式
     6.程序三大结构——分支（条件函数）
           1. 一个条件，一件事，只有满足才做，不满足就不做
             如果操作简单: 短路: 条件&&(操作)-----ex:total>=500&&(total*=0.8);
             如果操作复杂: if(条件){操作}
           2. 一个条件，二件事，二选一执行:
             如果仅两个值二选一:
                 (条件?值1:值2)
             如果操作简单: 三目/三元/条件
                 条件?操作1:操作2
             如果操作复杂:
                 if(条件){操作1;}else{操作2;}
           3. 多个条件，多件事，多选一执行
             如果多个值，多选一: 三目
               条件1?值1:
               条件2?值2:
                   ...?... :
                   默认值 ——强调: 默认值不能省略！
             如果操作简单: 三目
               条件1?操作1:
               条件2?操作2:
                   ...?... :
                   默认操作 ——强调: 默认操作不能省略！
             如果操作复杂: if...else if结构
               if(条件1){
                 操作1               //如果当前条件满足，则不再向后执行
                 }else if(条件2){
                 操作2               //如果进入条件2，暗示条件1不满足
                 }else if(...){
                     ...
                 }else{             —— 如果没有默认操作，则else省略
                     默认操作
                 }
            简写: 如果if/else if/else下只有一句话，可省略{}——强烈不建议
            特殊: 如果所有条件都是等于比较，可简写为
              switch(表达式){        //先计算表达式的值
                case 值1:           //用表达式的值和每个case后的值做*全等*比较  //如果表达式的值全等于case后的值
                  操作1;            //就进入case下执行操作
                case 值2:
                  操作2;
                ...
                default:           //如果所有case的值都不等于表达式的值
                }                  默认操作; //则执行默认操作   ——强调: 最后一个default可省略
             问题: 只要前一个case满足条件，则后续所有case都被执行。
             原因: switch是入口
             解决: break; 可终止当前结构继续向后执行
               如何: 每个case之间，都要加break
                 ex:  //请用户按键
                      var key=parseInt(prompt("请按键..."));
                      switch(key){
                        case 1:
                          alert("正在查询余额...");
                          break;
                        case 2:
                          alert("正在转账...");
                          break;
                        case 3:
                          alert("正在取款...");
                          break;
                        case 0:
                          alert("转人工...");
                          break;
                        default:
                          alert("无效按键!");
                      }
     7.程序三大结构:——循环（3种）
           1.while:-------知道循环次数，选择
                 var 循环变量=初始值;
                 while(循环条件){
                   循环体;
                   修改循环变量}
                   ex:  var r=parseInt(Math.random()*10);
                        var n=parseInt(prompt("输入一个0~9之间的整数"));
                        while(n!=r){
                          alert(n>r?"大了":"小了");
                          n=parseInt(
                            prompt("输入一个0~9之间的整数")
                          );
                        }//(退出循环)提示猜对了
                        document.write("猜对了!");
           2.do while:
             var 循环变量=初始值;
                do{
                  循环体;
                  修改循环变量
             }while(循环条件);
     ********while: 先验证后执行；do while: 先执行一次，再验证
             ex:	var str="no zuo no die,no can no bibi";
                	var i=-1;
                	do{
                		i=str.indexOf("no",i+1);
                		if(i!=-1){
                			console.log(i);
                		}else{
                			break;
                		}
                	}while(true);
           3.for:
                for(var 循环变量=初始值;循环条件;修改循环变量){
                  循环体;}
         ***让循环中的变量不要泄露到循环外，用let代替var: let声明的变量仅能在{}内使用
             break: 中断并退出当前循环;
             continue: 跳过本轮循环，继续执行下一轮
     8.创建n个空元素的数组,创建数组时仅知道数组元素个数，暂时不知道内容:
         var arr=new Array(n);
     9.关于length:
          1. 获取数组最后一个元素:
             arr[arr.length-1]
          2. 获得倒数第n个元素
             arr[arr.length-n]
          3. 末尾追加一个新元素:
             arr[arr.length]=新元素
          4. 删除数组最后一个元素
             arr.length-=1;
          5. 删除数组末尾倒数n个元素
             arr.length-=n;
          6. 清空数组
             arr.length=0;
     10.遍历：for(var i=0;i<arr.length;i++){arr[i]}
     11.关联数组：1. 先创建空数组: var ym=[];
                2. 向空数组中添加新元素，要使用自定义的下标名称
                    ym["name"]="杨幂"
             	   ym["math"]=81;
                    ym["chs"]=59;
                    ym["eng"]=89;
                 关联数组中length属性失效，永远等于0，因为关联数组中没有数字下标,length无法+1
          遍历关联数组:
                   for(var key in ym){
                     key //当前房间号
                     ym[key]//当前元素值
                   }
     12.数组转字符串2种：
             String(arr): 将arr中每个元素都转为字符串，用逗号连接（给数组拍照, 用于比较操作前后数组是否发生了变化)
             arr.join("连接符"):将arr中每个元素都转为字符串，用自定义的连接符连接元素(使用逗号以外的其它连接符时)
                   使用场合: 1. 把单词拼接为句子:
                             2. 无缝拼接: （**重要用途: 判断数组是否为空！）
                                 错误: arr.join() => String(arr) =>逗号连接
                                 正确: arr.join("")
                             3. 动态生成页面元素
     13.程序三大结构:——顺序
        concat:拼接===>强调:（不修改原数组，只返回新数组）
                            var newArr=arr1.concat(值1,值2,arr2,...);
                            2. 可打散数组类型参数为单个数据,再拼接
        slice:选取===>强调：（不修改原数组，只返回新数组）
                            var subArr=arr.slice(starti,endi+1);
                      强调: 1. 如果一个函数两个参数都是下标时，就会含头不含尾。
                      简写: 1. 如果位置离结尾近，可用负数下标: arr.length-n 可简写为: -n
                           2. 可省略第二个参数，表示一直选取到结尾
                           3. 两个参数都可省略: 完整复制一个数组
        splice:修改===>强调: （直接修改原数组）
                         1.删除元素: arr.splice(starti,n)删除starti位置开始的n个元素
                           强调: 不必考虑含头不含尾
                           其实: 有返回值: 返回被删除的元素组成的临时数组
                             var deletes=arr.splice(starti,n);
                           简写: 1. 支持负数下标，表示倒数第n个
                                2. 省略n
                         2.插入新元素: arr.splice(starti,0,值1,值2,...)
                             在starti位置插入值1,值2,...
                             原starti位置的值向后顺移
                           强调: 不支持打散数组参数
                         3.替换: 先删除旧的，再在同一位置插入新的
                           arr.splice(starti,n,值1,值2,...)
                             先删除starti开始的n个元素
                             再在starti位置插入值1,值2,...
                           强调: 删除的个数和插入的个数不必相同
                         4.翻转: arr.reverse();
        arr.sort()：排序===>将所有元素都转为字符串，再按字符串升序排列。
        出入栈：
            1. 结尾出入栈:
                 结尾入栈: arr.push(值) => arr[arr.length]=值
                   强调: 1. 其实push可压入多个值
                        2. 不支持打散数组参数
                 结尾出栈: var last=arr.pop()
            2. 开头出入栈:
                 开头入栈: arr.unshift(值)
                   强调: 开头入栈后的元素顺序和结尾入栈后的元素顺序是相反的。
                 开头出栈: var first=arr.shift();
     14.升序和降序
         最简单的数字升序比较器:
            function cmp(a,b){return a-b;}
               如何使用: 将比较器函数对象作为参数传入sort()
                 arr.sort(cmp);
                 强调: 不加()
                 回调: 自己定义的函数，自己不调用，而是传入另一个函数中，被另一个函数反复调用。
               何时: 只要对数字元素排序，都要自定义比较器函数
               问题2: 如何降序:
               解决: 只要颠倒比较器结果的正负号，就可改升序为降序
         最简单的数字降序比较器:
             function cmp(a,b){return b-a}
     15.向数组中添加元素4种:
          1. concat(): 1. 不修改原数组，返回新数组
                    2. 在结尾拼接元素
                    3. 支持打散数组类型参数
          2. splice(): 1. 直接修改原数组
                   2. 在任意位置插入新元素
                   3. 不支持打散数组类型参数
          3. push(): 1. 直接修改原数组
                  2. 只能在结尾拼接元素
                  3. 不支持打散数组类型参数
          4. shift(): 1. 直接修改原数组
                  2. 只能在开头拼接元素
                  3. 不支持打散数组类型参数
     16.取出数组元素: 4种:
          1. slice(): 1. 可获取任意位置的任意个元素
                      2. 不修改原数组，返回选中的元素组成的新数组
          2. splice(): 1. 删除任意位置的任意个元素
                       2. 直接修改原数组
                       3. 返回被删除的元素组成的新数组
          3. pop(): 1. 只能从结尾删除一个元素，并返回
          4. shift(): 1. 只能从开头删除一个元素，并返回
          5.split(""):按指定字符，将一个字符串切割为多段子字符串
                       var subs=str.split(/reg/i);
                       说明: 在切割后的结果数组中，不包含切割符了
                       固定套路: 将字符串打散为字符数组:
                       var subs=str.split("");
          6.str.substring():   str.substring(starti,endi+1) 用法同slice，但不支持负数
                               str.substr(starti,n) => str.slice(starti,starti+n);
          7.既查找关键词内容，又查找位置的方法：
               替换: 将字符串中找到的关键词，替换为指定新内容
               1. 简单替换: 将所有关键词都替换为统一的内容
                 str=str.replace(/reg/ig,"新值");
               2. 高级替换: 根据每个关键词的不同，动态选择替换不同的新值
                 str=str.replace(/reg/ig,function(kw){
                   kw   //可自动获得本次找到的关键词
                   return //根据kw的不同，动态返回不同的值
                   })
               3.衍生: 删除: 将关键词替换为""
                  str=str.replace(/reg/ig,"")
          8.切割:按指定字符，将一个字符串切割为多段子字符串
                  var subs=str.split("关键字");
                  var subs=str.split(/reg/i);
                  说明: 在切割后的结果数组中，不包含切割符了
                  固定套路: 将*字符串打散*为字符数组:
                  var subs=str.split("");
                  ex:<ul id="scores">
                     	<li>85</li>
                     	<li>92</li>
                     	<li>22</li>
                     	<li>77</li>
                     </ul>
                     <script>------要求页面分数从高往低排序
                     	var html=scores.innerHTML;
                     	console.log(html);
                     	html=html.replace(/^\s*<li>|<\/li>\s*$/ig,"");
                     	console.log(html);
                     	html=html.split(/<\/li>\s*<li>/i);
                     	console.log(html);
                     	html.sort(function(a,b){return b-a});
                     	console.log(html);
                     </script>
     17.二维数组
           创建: 2种:
            1. 先创建空数组，再添加子数组:
               var arr=[];
               arr[0]=[0,0,0,0];
               arr[1]=[0,0,0,0];
            2. 创建数组同时，初始化子数组
               var arr=[[0,0,0,0],
                      ... ,
                 [0,0,0,0]];
           访问: arr[r][c] 每个元素的用法和普通数组的元素完全一样
           遍历二维数组: 外层循环控制行，内层循环控制列
             for(var r=0;r<data.length;r++){
               for(var c=0;c<data[r].length;c++){
                 data[r][c] //当前正在变量的元素
         }
         }
     ===================================================JS高级============================================================
     1.String
         1.大小写转换：str.toLowerCase() 转小写------用户名和验证码不区分大小写
                       str.toUpperCase() 转大写
         2.获得指定位置的字符:str.charAt(i) <=> str[i]（此方法容易误会为数组）
         3.获得指定位置字符的unicode号:str.charCodeAt(i) 获得i位置的字符的unicode号
                                 将unicode号，反向转回原文
                                 String.fromCharCode(unicode)  强调: 一次只能转一个字
                                 ex:msg+=String.fromCharCode(unicode);
         4.获取子字符串:
             str.slice(starti,endi+1)=>str.slice(starti,starti+n);
             str.substring(starti,endi+1) 用法同slice，但不支持负数(因为底层未写str.length-1的API)
             str.substr(starti,n) => str.slice(starti,starti+n);
         5.查找一个固定关键词的*位置*:
               var i=str.indexOf("关键词",fromi)从fromi位置开始，找str中下一个"关键词"的位置
               返回值: 找到的关键词的下标位置i
                       如果没找到，返回-1
               简写: 省略fromi，默认从0开始
         6.查找最后一个关键词的位置:var i=str.lastIndexOf("关键词");
               问题: 只能查找一个固定关键词的位置
               解决: 正则表达式判断是否包含敏感词
                     var i=str.search(/正则/)   在str中查找第一个符合/正则/
         7.判断字符串中*是否包含*符合规则的关键词
             var i=str.search(/reg/i)
             返回值: 返回关键词的*位置*,如果没找到返回-1
             问题: 正则表达式默认都是大小写敏感的
             解决: 在第二个/后加i,表示忽略(ignore)大小写
             何时: 只要仅判断有没有关键词时，首选search
             问题: 1. 只能查找*一个*关键词
                   2. 只能返回*位置*，无法返回关键词内容
                  ex:	var str="那天，我去了她家，我说：窝草，你家真大！";
                         if(str.search(/[我卧窝]([草槽艹操]|cao)]/i)!==-1){
                             alert("包含敏感词，不能发送！");
                         }else{
                             document.write("文华说："+str);
                         }
         8.查找所有关键词的内容:
             var kwords=str.match(/reg/ig);
             返回值: 返回所有关键词组成的*数组*,如果没找到，返回null------数组结构：arr[0: 我CAO,  index: 12]
             问题: 正则表达式默认都只匹配第一个关键词
             解决: 在第二个/后加g，表示全部(global)
             何时: 仅希望获得关键词内容时
             问题: 仅能获得内容，无法获得每个关键词的位置
     ********indexOf,search,match区别：
             1.indexOf只能找到下标位置；
             2.search只能找到一个下标，不显示内容，支持正则；
             3.match只能找到一个，显示下标和内容，加g可以找到所有内容，不显示下标，支持正则；
         9.既查找关键词内容，又查找位置的方法：
             替换: 将字符串中找到的关键词，替换为指定新内容
             1.替换一个固定的关键词：-----只替换一个，且不支持正则
                   str=str.replace("关键词","新值");
             2. 简单替换: 将所有关键词都替换为统一的内容
                   str=str.replace(/正则/ig,"新值");
                   *****必须先验证查找结果是否为null
                     ex:str=str.replace(/no/ig,"**");
             3. 高级替换: 根据每个关键词的不同，动态选择替换不同的新值
               str=str.replace(/正则/ig,function(kw){
                             kw   //可自动获得本次找到的关键词
                 return //根据kw的不同，动态返回不同的值
                 })
                 **鄙视：str=str.replace(/\b[a-z]/ig,function(kw){
                      			//kw会依次获得: y, c, y, u
                      			return kw.toUpperCase();
                      		});
             3.衍生: 删除: 将关键词替换为""
                str=str.replace(/正则/ig,"")
              ex:var str="      zhang   dong     ";
                 console.log(str.replace(/^\s+/,""));--------替换开头空格
                 console.log(str.replace(/\s+$/,""));--------替换结尾空格
                 console.log(str.replace(/(^\s+|\s+$)/g,""));---替换开头和结尾空格，g是因为匹配开头和结尾两个字符集，不能只执行1次
                 </script>
         10.切割: 按指定字符，将一个字符串切割为多段子字符串
                var arr=str.split(/reg/i);
                说明: 在切割后的结果数组中，不包含切割符了
                固定套路: 将字符串打散为字符数组:
                var arr=str.split("");--------如果字符串想用数组的api时，先变成数组，如果字符排序或者翻转
     2.正则表达式
         何时: 2种:
           1. 模糊匹配多种关键词
           2. 密码格式
         如何:
           1. 最简单的正则表达式，是关键词原文本身  ex:no
           2. 字符集:规定一位字符有多个可用的备选字符列表的集合
             何时: 只要一位字符，有多种可能备选字时
             如何: [备选字符列表]  ex:[我卧][曹草操艹]
             强调: 一个字符集只能匹配一位
             简写: 如果字符列表中部分字符是连续的，可用-省略中间字符
               比如:	[0-9] 一位数字
                     [a-z] 一位小写字母
                     [A-Z] 一位大写字母
                     [A-Za-z] 一位字母
                     [0-9A-Za-z] 一位字母或数字
                     [\u4e00-\u9fa5] 一位汉字
                     ex:[\u4e00-\u9fa5][A-Z]·[A-Z0-9][A-Z0-9][A-Z0-9][A-Z0-9][A-Z0-9](车牌号)
             特殊: 除了:[^字符列表]
           3. 预定义字符集:
            什么是: 对常用字符集的简写: 4个:
              \d 一位数字 =>[0-9]
              \w 一位字母,数字或_ =>[0-9A-Za-z_]
              \s 一位空字符: 空格, Tab...
              . 通配符
           4. 量词:专门规定字符集出现次数的规则
                何时: 只要规定字符集出现的位数/次数
                如何: 量词必须紧跟在字符集之后，修饰相邻的前一个字符集。
                包括:2大类:
                  1. 有明确数量边界的:
                    字符集{n,m} 至少n个，最多m个   ex:\d{6,8}  最少6位数字，最多8位
                    字符集{n,} 至少n个，多了不限   ex:\d{6,}  至少6位数字，多了不限
                    字符集{n}  必须n个             ex:\d{6}   必须6位数字
                  2. 没有明确数量边界的:
                    字符集? 可有可无，最多1个
                    字符集*  可有可无，多了不限
                    字符集+  至少一个，多了不限
           5. 选择和分组:
             *选择: 或  |  ---------多个规则中，只要匹配其一即可！
                规则1|规则2|...
               |在正则中，优先级最低
             *分组: 用()将多个规则分为一组
               何时: 如果希望量词同时修饰多个字符集时，就要先将多个字符集分为一组，再用量词修饰分组
               为什么: 默认字符集仅修饰相邻的前一个字符集
             ex:身份证号: 15位数字  2位数字  1位数字或Xx
                           \d{15}     (\d\d       [0-9Xx])     ?------------------\d{15}(\d{2}[0-9X])?
                               后两部分，可有可无，最多1次
             ex:手机号: +86或0086   可有可无，最多一次
                        空字符       可有可无，多了不限
                         1
                         3,4,5,7,8      选一个
                         9位数字
                         (\+86|0086)?\s*1[34578]\d{9}
             ex:微 信 wei xin w x-------(微|w(in)?)\s*(信|x(in)?)-----因为出现了|,所以字符集[]，要换成()
             	var str="咱们微x联系";
             	if(str.search(/(微|w(in)?)\s*(信|x(in)?)/i)!==-1){
             		alert("包含敏感词，不能发送！");
             	}else{
             		document.write("文华说："+str);
             	}
             ex:'2018/8/20'.replace(/(\d{4})\/(\d{1,2})\/(\d{1,2})/,'$1年$2月$3日')
     
                "2018年8月20日"
           6. 指定匹配位置: 3种:
             ^ 字符串开头 比如: 字符串开头的空字符: ^\s+
             $ 字符串结尾 比如: 字符串结尾的空字符: \s+$
             ex:开头或者结尾都有空字符   ^\s+|\s+$
              开头或结尾的空字符:\b 单词边界: ^ $ 空格 标点符号
              比如: 查找单词no，不包含单词内的no
                  \bno\b
           7. ****RegExp: (Regular Expression)封装一个正则表达式2种:
               1. 格式验证:
               2. 即查找关键词内容，又查找关键词位置:
                    创建: 2种:
                    1. 创建一个固定的正则表达式: var reg=/正则/ig;
                        字符冲突: 两/之间如果再包含/，需要将内部的/转为\/
                          比如: /<\/option>/
                    2. 动态生成一个正则表达式:
                       var reg=new RegExp("正则","ig");
                        字符冲突: ""之间如果包含\和", 都要变为\\和\"
                          比如: new RegExp("\\d{6}","ig")
               3.验证格式:
                     var bool=reg.test(str); 验证str是否符合reg的规则要求，符合返回true，否则返回false
                     问题: 正则表达式默认只要包含就算匹配
                     解决: 今后，凡是验证，必须前加^，后加$，表示从头到尾完全匹配
                     ex:	var reg=/^\d{6}$/;
                        	var upwd=prompt("请输入密码：");
                        	if(reg.test(upwd)){
                        		document.write("验证通过");
                        	}else{
                        		alert("密码格式不正确，请重新输入");
                        	}
               4.查找关键词: 即查找所有关键词内容，又查找位置:
                     var arr=reg.exec(str); 在str中查找符合reg要求的下一个关键词的位置和内容保存在数组arr中
                       返回值: arr: [0: 关键词,  index: 下标 ]   找不到返回null
                       强调: 1. reg.exec可自动从本次查找位置开始执行下一次查找。但是需要循环推动。
                             2. 要想找所有，reg也必须加g
                             3.reg有自己默认的对象属性lastIndex，会配合reg.exec使用显示下次开始查找的位置
                       ex:	var str="明明喜欢我，却不告诉我，别理我，我想静静，静静是谁？先告诉我明明是谁？";
                             var reg=/明明|静静/g;
                             do{
                          		var arr=reg.exec(str);
                          		if(arr!=null){
                          			console.log("在位置"+arr.index+"处发现敏感词:"+arr[0]+",下次从位置"+reg.lastIndex+"开始查找");
                          		}else{
                          			break;
                          		}
                          	}while(true);
     3.Math:专门封装算数计算的常量并提供数学计算的API
         强调: 不能new！所有API都通过大写Math直接调用
         API:
           1. 取整: 3种:
                上取整: Math.ceil(num)   只要超过，就取下一个整数-------22.33取整23
                下取整: Math.floor(num)  舍弃小数部分------22.33取整22
                *******vs parseInt(str): 类型转换: Math.floor只能对纯数字的内容下取整
                                                   parseInt 可去掉结尾非数字单位
                四舍五入取整: Math.round(num)
                *******vs n.toFixed(d):
                                        1. round只能取整, toFixed可按任意小数位数四舍五入
                                        2. 返回值: round   返回*数字*，可直接做计算
                                           ******toFixed   返回*字符串*，做+运算前必须强转为数字
                ******用Math.round四舍五入取有小数的数字：
                      ex:	function round(num,d){
                         		num*=Math.pow(10,d);
                         		num=Math.round(num);
                         		return num/Math.pow(10,d);
                         	}
                         	console.log(
                         		round(2014.888,2),
                         		round(2018.42222,3)
                         	);
           2. 乘方和开平方:
                Math.pow(底数,幂)        ex: Math.pow(10,2) =>10的2次方=>100
                Math.sqrt(num)           ex:Math.sqrt(9)=3
                ex:	//求两圆中心点距离：两圆坐标为：c1(x1,y1) c2(x2,y2)
                   	var x1=100,y1=100,
                   		x2=200,y2=200;
                   	var dist=Math.sqrt(
                   		Math.pow(x2-x1,2)+Math.pow(y2-y1,2)
                   	);
                   	console.log(dist);
           3. 最大值和最小值:
                Math.max/min(值1, 值2,....)
                强调: 不支持获得数组中的最大/最小值
                解决:1....数组     Math.max(...数组)-----拆数组
                            ex:var arr=[3,6,9,4,5];
                               Math.max(...arr);
                     2.Math.max.apply(null,arr);
           4. 随机数:
                Math.random()   返回0~1之间的一个随机小数0<=r<1
                     ex:Math.random()<0.5?"1":"*"
                公式: 在任意min~max之间取一个随机整数:parseInt(Math.random()*(max-min+1)+min)
                简化: 从0~n之间生成一个随机整数:parseInt(Math.random()*(n+1))
                ex:双色球机选
                             function doubleball(){
                                 //定义空数组reds
                                 var reds=[];
                                 //反复生成红球，只要reds中元素的个数<6
                                 while(reds.length<6){
                                     //在1-33之间生成一个随机整数r
                                     var r=parseInt(Math.random()*(33-1+1)+1);
                                     //parseInt(Math.random()*(max-min+1)+min)
                                     //遍历reds
                                     for(var i=0;i<reds.length;i++){
                                         //如果reds中当前元素===r
                                         if(reds[i]===r){
                                             //就退出循环
                                             break;
                                         }
                                     }
                                         //如果i===reds的元素个数，才
                                         if(i===reds.length){
                                             //将r压入reds中
                                             reds.push(r);
                                         }
     
                                 }
                                 //循环结束
                                 //将reds按数字升序排列
                                 reds.sort(function(a,b){return a-b});
                                 //在1-16间生成一个随机整数b
                                 var b=parseInt(Math.random()*16+1);
                                 //在页面上输出：将reds转为字符串 | b
                                 document.write(reds.join(",")+"|"+b);    //document.write(reds.toString()+"|"+b);
                             }//5,6,7,8,9,2 | 8
                             doubleball();
           5.三角函数
                坐标->求两个直角边长->反三角函数->角度
                    Math.atan(对边长/临边长)
                    问题: 无法区分象限
                    解决: Math.atan2(对边长,临边长)------Math.atan2(y,x)-----求弧度
     4.Date:封装一个时间，并提供操作时间的API的对象
         何时: 只要存储时间或计算时间
         1.如何创建: 4种:
            1. 创建日期对象，同时获得*客户端*当前系统时间，无法获得服务器时间:
               **今后凡是需要统一时间，一律从服务器端获取
                var now=new Date();
            2. 创建日期对象并保存自定义时间:
                var date=new Date("yyyy/MM/dd hh:mm:ss")
                         new Date(yyyy,MM-1,dd,hh,mm,ss)
            3. 使用毫秒数创建日期对象:
              日期对象的原理: 日期对象中保存的是一个毫秒数，因为毫秒数不受时区影响，且便于算数计算。
                      起点: 1970年1月1日至今
                惯例: 在跨国系统中存储时间，不要使用字符串，而要使用毫秒数。
              何时: 只要将存储的毫秒数，转化为日期对象时
              如何: var date=new Date(毫秒数);----------var 毫秒数=date.getTime();--获取当前毫秒数
            4. 复制一个日期对象:因为日期计算时，都是直接修改原日期对象，无法同时保存计算前后的两个时间，
                             所以只要希望同时保存计算前后的两个时间，就要在计算前，将起始时间复制一个副本，
                             再用副本计算截止时间。
              方法: var date2=new Date(date1);
         2.日期API:8个单位: FullYear（2018年不是18年--千年虫案例）   Month   Date    Day  没有s结尾
                          Hours    Minutes  Seconds  Milliseconds
             1. 每个单位都有一对get/set方法:
               其中getXXX()负责获取指定单位的值
                  setXXX()负责设置指定单位的值
                ex:  date.getDate() //获得date中的日期
                     date.getHours() //获得date中的小时
                     date.getTime()//获得毫秒数
                     date.setDate(20) //将date中的日期设置为20号
                     date.setHours(11) //将date中的小时设置为11点
                特例: Day没有set方法，因为星期几是通过换算得到的，不能人为修改。
             2. 返回值/取值范围:
               FullYear  年份该是多少就是多少
         ******Month  0~11  计算机中保存的月份比现实中小1
               Date    1~31
               Day     0~6
               Hours   0~23
               Minutes/Seconds  0~59
             3.日期计算2种:
                 1. 两日期对象可相减,结果是毫秒差:
                    何时: 计算倒计时或时间差
                 2. 对任意单位做加减3步:
                     1.var date=new Date();
                     1.var n=date.getXXX();
                     2.n+=?;
                     3.date.setXXX(n);----可以自动调整时间进制，n可以是任意值
                     4.date----即可显示时间
                   简写: date.setXXX(date.getXXX()+/-n)
                     比如: 当前时间+30天
                       now.setDate(now.getDate()+30) //52
                           当前时间-2个月
                       now.setMonth(now.getMonth()-2)
                   问题: setXXX会直接修改原日期对象，旧时间无法保存
                   解决: 先将起始时间复制一个副本，再用副本计算截止时间---date2=new Date(date1)
             4.日期转字符串:
                 date.toString(date) 将date转为当地时间的完整日期格式-------Sat Jun 30 2012 00:00:00 GMT+0800 (中国标准时间)
                 date.toLocaleString() 转为当地时间的简化版格式----2012/6/30 上午12:00:00
                 **date.toLocaleDateString() 仅保留日期部分----2015/6/30
                 date.toLocaleTimeString() 仅保留时间部分------上午12:00:00
                 date.toGMTString()  转为国际标准时间(0时区)------Fri, 29 Jun 2012 16:00:00 GMT
     5.错误处理:程序运行过程中，导致程序无法继续执行的异常情况，发生错误后，程序会立刻中断退出，
                 错误处理是即使程序发生错误，也保证不强行退出的一种机制
         1.为什么: 避免程序强行中断，闪退，导致极差的用户体验
         2.何时使用: 只要希望即使程序发生错误，也保证不强行退出
         3.如何使用:
           try{
             可能发生错误的语句
             }catch(err){---------------------err为错误对象：专门保存错误信息的对象，错误发生时，会自动创建错误对象
             //只有发生错误时，才执行的代码
                 //提示用户，记录日志，释放资源
             }
           错误处理代码: 1.保存进度; 2. 提示用户; 3. 记录日志
                   ex:	var num=parseFloat(prompt("请输入一个数字"));
                         var d=parseInt(prompt("请输入小数位数"));
                         try{
                             var result=num.toFixed(d);
                             document.write("结果："+result);
                         }catch(err){
                             alert("出错啦："+err);
                         }
                         document.write("<br>程序继续执行...")
         4.性能问题: 放入try catch中的代码，可能执行效率会降低，且一旦出错，还要额外创建error对象，占用更多内存空间.
         5.解决: 如果可提前预知错误的原因，可用if...else...来代替try catch——对于开发人员的经验要求非常高
                 ex:	var num=parseFloat(prompt("请输入一个数字"));
                    	var d=parseInt(prompt("请输入小数位数"));
                    	if(d>=0&&d<=100){
                    		var result=num.toFixed(d);
                    		document.write("结果："+result);
                    	}else{
                    		alert("出错啦:小数位数必须介于0-100之间！");
                    	}
                    	document.write("<br>程序继续执行...")
         6.鄙视: js中错误的类型: 6种********
             SyntaxError: 语法错误
             ReferenceError: 引用错误, 要用的变量未找到
             TypeError: 类型错误, 使用错误的类型调用函数或访问元素。----要使用的变量值为null/undefined，不能加().[]
             RangeError: 范围错误, 参数值超范围
             URIError,EvalError;
             bug: 只要导致程序出现问题的原因
         7.主动抛出错误:当前程序运行出错时，主动新建一个错误，抛出
             1.何时抛出: 在团队协作开发中，函数的作者，向函数的使用者抛出错误，提示调用者如何正确使用函数。
             2.如何抛出: throw new Error("错误提示");
             ex:	//函数作者
                	function round(num,d){
                		if(!isNaN(num)&&!isNaN(d)){
                			num*=Math.pow(10,d);
                			num=Math.round(num);
                			return num/Math.pow(10,d);
                		}else{
                			throw new Error("请务必使用数字！");
                		}
                	}
                	//函数使用者
                	var num=parseFloat(prompt("请输入数字："));
                	var d=parseInt(prompt("请输入小数位数："));
                	if(!isNaN(num)&&!isNaN(d)){
                		var result=round(num,d);
                		document.write("结果是："+result);
                	}else{
                		alert("出错啦！必须输入数字")
                	}
                	document.write("<br>程序继续执行...")
     6.垃圾回收：
         垃圾: 内存中不再被任何变量应用的对象
         垃圾回收: 引用会自定释放不再被使用的对象的内存
         为什么: 内存的容量都是极其有限的
         垃圾回收器: 专门监控内存，并回收垃圾的小程序
         原理:
           1. 程序运行时，垃圾回收器和主程序一同启动，并行执行。
           2. 每创建一个对象，垃圾回收器就会监控该对象的引用个数
           3. 一旦发现一个对象，不再被任何变量使用，则释放该对象
           强烈建议: 一旦一个对象不再使用，则将变量赋值为null。释放对该对象的引用。
     7.Function
         1.创建3种:
                1.声明:
                     function 函数名(参数列表){
                                             //函数体;
                                             //return返回值--------调用者需要结果才返回值
                                             }；
                     特点: 会被*声明提前*hoist
                     ex:	//hoist
                         console.log(a);   //undefined
                         var a=10;
                         console.log(a);  //10
     
                         function fun(){console.log(1);}
                         fun();   //2
                         function fun(){console.log(2);}
                         fun();  //2
                         -----------------声明提前过程------------------
                         //hoist
                         var a,
                         function fun(){console.log(1);}
                         function fun(){console.log(2);}
                         console.log(a);  //undefined
                         a=10;
                         console.log(a);  //10
                         fun();   //2
                         fun();   //2
                2.直接量:var 函数名=function(参数列表){函数体; return返回值}------底层也是变量存储了一段代码
                   特点: *不会被声明提前*--------其实也有声明提前，只是因为变量名被提前了，赋值留在原地登录
                   何时: 只要希望函数的定义不被声明提前时
                   ex:	var fun=function(){
                             console.log(1);
                         };
                         fun();   //1
                         var fun=function(){
                             console.log(2)
                         };
                         fun();  //2
                         var fun=10;
                         fun();  //fun is not a function
                         -----------------声明提前过程------------------
                         var fun;
                         var fun;
                         var fun;
                         fun=function(){
                         console.log(1)
                         };
                         fun();   //1
                         fun=function(){
                         console.log(2)
                         };
                         fun();   //2
                         fun=10;
                         fun();---------因为是个值，不是函数
                3.用new:var 函数名=new Function("参数1","参数2",......"函数体;return 返回值")----参数必须放“”里
                   强调: 所有参数变量和函数体，必须用""包裹
                   鄙视: 以下函数创建正确的是:
                        function fun(a,b){return a-b}
                        var fun=function(a,b){return a-b}
                        var fun=new Function(a,b,"return a-b")  XXX
                        var fun=new Function("a","b","return a-b")
         2.重载(overload):相同函数名，不同参数列表的多个函数，在调用时可根据参数的不同，自动选择对应的函数执行。
                1.何时: 如果一件事，根据不同的参数，执行不同的逻辑时
                2.为什么: 减少函数的数量，减轻调用者的负担
                3.问题: js语法，默认不支持多个同名函数同时存在！
                4.如何变通:
                   1. 仅定义一个函数，不要写参数列表
                   2. arguments: 函数内自定创建的，用于接收传入函数的所有参数值的类数组对象
                      类数组对象: 长的像数组的对象
                        vs 数组: 相同:1. 下标, 2. .length, 3.for遍历
                                 不同: 类型不同——API不通用
                       不用创建，自动包含一个arguments对象
                   3. 函数内，根据arguments中参数的个数或类型，动态决定执行不同操作。
                   ex:	function pay(){
                             if(arguments.length===0){
                                 console.log("手机支付...");
                             }else if(arguments.length===1){
                                 console.log("现金支付...");
                             }else{
                                 console.log("刷卡支付...")
                             }
                         }
                         pay();
                         pay(100);
                         pay("1234 5678","123456");
                5.还需要参数：
                   1. 参数用于提示调用者如何正确使用函数
                   2. 参数名一般都比arguments简洁且见名知义
         3.匿名函数:创建函数时，不指定函数名的函数
                1.何时: 当一个函数仅使用一次时
                2.为什么: 1. 节约内存，2. 划分临时作用域，避免全局污染
                3.如何使用: 2种:（***********）
                    1. 回调:
                            arr.sort(function (a,b){return a-b})
                            str.replace(reg,function(kw){return 替换值})
                            btn.addEventListener("click",function(){...})
                    2. 自调: 定义匿名函数后，立刻调用自己，调用后立刻释放
                              如何: 2种:
                                   +function(){
                                   }()
                                   (function(){
                                             ...
                                   })()
                                   ex:	(function(){
                                      		var start=new Date();
                                      		alert("开始加载页面内容，at:"+ start.toLocaleTimeString());
                                      })()
                                      	(function(){
                                      		var end=new Date();
                                      		alert("页面内容加载完成，at:"+end.toLocaleTimeString());
                                      	})()
                              何时: 只要不希望造成全局污染时，就用匿名函数包裹所有自定义的代码。
     8.作用域(scope)：一个变量可用范围，也是一个变量的实际存储位置。--------避免不同范围的变量间相互干扰。
         1.包括: 2种:
             1. 全局作用域: window-->保存全局变量: 特点: 随处可用，可重复使用-----全局作用域对象
             2. 函数作用域: AO-->保存局部变量: 特点: 仅函数内可用，不可重用-------函数作用域对象
         2.函数的生命周期:
             1.程序开始执行前:
                 创建执行环境栈(数组)-ESC,用于保存将要调用的所有函数
                 在栈中添加第一个函数调用: 浏览器的主程序main().
                 主程序创建全局对象window----document  array  Date ...
             2.定义函数:
                 用函数名创建全局变量
                 创建函数对象封装函数体
                 函数名变量引用函数对象
                 函数对象的scope属性(籍贯)指回window
             3.调用函数:
                 在ECS中记录本次正在调用的函数
                 为本次函数调用创建函数临时作用域对象AO(活动对象)
                 在AO中定义局部变量(var 声明的和参数变量)
                 设置AO的parent指向函数的scope
                 执行过程中，变量使用顺序: 优先使用AO中的局部变量----------active object活动对象
                                             AO中有，就不去全局找
                                             AO中没有，才去全局找
             4.函数调用后:
                    ECS中的函数记录出栈
                    ->临时作用域对象AO被释放
                         ->所有局部变量一同释放
     9.作用域链（scope chain）: 由各级作用域对象连续引用形成的链式结构，保存着所有变量，且控制着变量的使用顺序----先局部后全局
     10.闭包(closure):即重用变量，又保护变量不被污染的一种机制（***********）
         1.为什么: 全局变量和局部变量都有优缺点:
                 全局: 优: 可反复使用；缺: 随处可用——易被污染
                 局部: 优: 仅在函数内可用，不会被污染；缺: 不可重用
         2.何时使用闭包: 即重用变量，又保护变量不被污染
     ****3.使用方法: 3步:
               1. 用外层函数，包裹住***受保护的变量***和***内层函数***
               2. 外层函数将内层函数返回到外部
               3. 使用者调用外层函数，获得内层函数对象
         4.鄙视: 闭包如何形成: 因为内层函数对象引用着外层函数的作用域对象(AO)，使其无法释放
                 ex:	function outer(){
                         var i=0;
                         return function num(){
                             i++;
                             console.log(i)
                         }
                    	}
                    	var getNum=outer();
                    	getNum();//1
                    	getNum();//2
                    	getNum();//3
                 闭包的问题: 比普通函数占用更多内存空间——多的是外层函数的AO
                 解决: 将引用闭包函数的变量赋值为null，导致内层函数对象先释放，再导致外层函数的AO一并释放
     ***************判断输出：套路
                    1.找到受保护的变量；
                    2.找到外层函数共向外抛出了几个内层函数，一个外层函数抛出的多个内层函数对象共用***同一个****受保护的变量
                    ex:	function fun(){
                       		var n=999;
                       		nAdd=function(){n++};---------------强行给一个未声明的变量赋值，会在*全局window*创建该变量
                       		return function(){
                       			console.log(n);
                       		}
                       	}-------------------------------------*****实际此函数向外抛出了两个函数
                       	var get=fun();--------------//function(){console.log(n);}
                       	get();  //999
                       	nAdd();
                       	get();  //1000
         5.鄙视: 画简图识别闭包:2步:
              1. 找受保护的变量:
                 1.外层函数的局部变量(var的或参数变量)
                 2.确定在外层函数调用后，受保护变量的最终值
              2. 找抛出的内层函数:2个途径:
                 1. return
                 2. 直接给全局变量赋值
              3. 隐藏: 将内层函数放入一个数组/对象中隐藏返回
                一次外层函数调用，返回的多个内层函数，共用同一个受保护的变量。
                 ex:function fun(){*****************
                        for(var i=0,arr=[];i<3;i++){
                             arr[i]=function(){
                                 console.log(i);
                             }----------------i=3,跳出循环时为3
                        }
                    return arr;---------------实际arr输出为3个函数的数组---arr[----------------只命名未调用
                           }                                                   arr[i]=function(){console.log(i);}
                    var funs=fun();                                            arr[i]=function(){console.log(i);}
                    funs[0]();                                                 arr[i]=function(){console.log(i);}
                    funs[1]();                                                  ]
                    funs[2]();
     11.***********面向对象: 程序中都是用对象结构来描述现实中一个具体事物。
         对象: 程序中封装现实中一个事物属性和功能的存储空间。
         1.为什么: 现实中，任何数据都有明确的归属，都不是孤立的。
         2.何时: 只要用程序描述现实中一个事物，都要将事物的属性和功能封装在一个对象中
         3.面向对象三大特点: 封装，继承，多态
              1.封装:将现实中一个事物的属性和功能集中定义在一个对象结构中，事物的属性会成为对象的属性，事物的功能会成为对象的方法
                       1.为什么封装: 让每个数据都有其专门的归属，便于维护和操作
                       2.何时封装: 只要使用面向对象，都要先将数据封装在对象中，再使用。
                       3.如何封装: 3种:
                         1. 对象直接量:
                                   var obj={//创建一个新对象
                               属性名:值,
                                        ... : ... ,
                               //方法名:function(参数列表){
                                 方法名(参数列表){//ES6
                               this.属性名...
                               },
                               方法名(...){...}
                               }
                               A.何时使用直接量: 如果创建对象时就已经知道对象的成员。
                               B.问题: 对象自己的方法，要访问自己的属性:
                               C.错误: 对象名.属性名, 一旦对象名修改，方法内的对象名要同时修改。不便于维护
                               D.正确: 在方法内使用关键词this自动指代当前对象本身。即：this.属性名
                               E.优点: 即使对象名修改，this也可自动获得当前对象本身，和对象名无关
                                      this可翻译为: 当前对象的/自己的1
                               F.总结: 今后只要对象自己的方法中，要使用自己的属性，就必须用this.属性名
                         2. 用new: 2步:
                               1. 创建空对象: var obj=new Object();
                               2. 向空对象中添加新属性:
                                  obj.属性名=值;
                                  obj.方法名=function(){ this.属性名}
                                   A.何时使用: 如果创建对象时暂时不知道对象的成员,对象创建后，随时可添加新属性。
                                   B.js中对象本质: 其实就是一个关联数组,对象其实是关联数组的简化版用法:
                                   C.关联数组对象
                                     访问元素:   ym["属性名"]   ym.属性名
                                     创建: 2步: 先创建空[]  可用直接量{}一次性创建 再添加新元素
                                   D.VS关联数组区别：
                                   相同:
                                           1. 访问不存在的属性，不报错，返回undefined
                                           2. 随时可以添加新属性
                                           3. 访问时，即可用["属性名"]，也可用.的方式
                                             如果属性名是固定不变的，则优先用.
                                             如果属性名来自于变量或需要动态生成，则使用["属性名"]
                                           4. 用for(var key in 对象) 遍历
                                   E.问题: 一次只能创建一个对象,反复创建多个相同结构的对象，代码冗余太多，不便于维护
                                   解决方法:构造函数
                         3. 用构造函数反复创建多个相同结构的对象:
                               1.构造函数: 专门描述一类对象统一结构的函数，还用于将一个新的空对象装修成想要的结构并存入数据。
                               2.何时: 反复创建多个相同结构的对象，都要先用构造函数描述统一的结构
                               3.如何: 2步:
                                   1. 定义构造函数:
                                          function 类型名(参数列表){
                                               this.属性名=参数;
                                                              ... ...
                                                        this.方法名=function(){
                                               this.属性名
                                           }
                                           }
                                   2. 用new调用构造函数创建新对象:
                                        var obj=new 类型名(属性值列表);
                                   *******new做的四件事：
                                          1. 创建一个新对象
                                          2. 设置新对象继承构造函数的原型对象
                                          3. 用新对象作为主语，调用构造函数
                                                  自动将this->新对象
                                                  通过强行赋值的方式，向对象中添加新属性
                                          4. 返回新对象的地址给变量
                                          问题: 只能重用代码，无法节约内存
                                          为什么: 构造函数内的方法，被反复创建了
                                          解决: 继承
                                   ex:	function Student(name,age){
                                             this.sname=name;
                                             this.sage=age;
                                             this.intro=function(){
                                                 console.log("I'm "+this.sname+",I'm "+this.sage);
                                             };
                                         }
                                         var lilei=new Student("lilei",11);
                                         var hmm=new Student("hanmeimei",12);
                                         console.log(lilei);
                                         console.log(hmm);
                                         lilei.intro();
                                         hmm.intro();
                               4.如何访问对象的成员:成员=属性+方法
                                   A.访问属性: 对象.属性名用法和普通的变量完全一样,属性其实就是保存在对象内的变量
                                   B.调用方法: 对象.方法名()  用法和普通的函数完全一样
                                   C.方法其实就是保存在对象内的函数
                                     .读作"的"
                                     其实，也可用对象["属性名"]方式访问
                                   D.问题: 方法定义在构造函数内。每创建一个新对象，都会重复创建相同的函数副本——浪费内存！
                                   E.总结: 构造函数: 优: 代码重用！缺: 无法节约内存
                                   F.解决方法:继承
              2.继承:父对象的成员，子对象无需重复创建就可直接使用，不但可代码重用，且还可节约内存
                       1.何时使用: 只要多个子对象，拥有相同的成员时，都要将相同的成员，仅保存在父对象中一份即可。所有子对象共用。
                       2.如何使用:原型对象(prototype): 专门集中保存同一类型的多个子对象，共有成员的父对象。
                           1.如何获得原型对象:__proto__属性继承构造函数的原型对象
                               1. 买一赠一: 创建构造函数同时，已经自动创建了该类型的原型对象，构造函数的prototype属性引用着原型对象。
                                            原型对象的constructor也引用着构造函数对象
                                            ----构造函数通过prototype指向原型对象，原型对象通过constructor指向后遭函数
                               2. 自动继承: 每用构造函数创建一个子对象，new都会自动设置子对象的__proto__属性指向构造函数的原型对象
                           2.如何向原型对象中添加共有属性:
                               构造函数.prototype.属性/方法名=值/function(...){...}
                               ex:	function Student(name,age){
                                         this.sname=name;
                                         this.sage=age;
                                     }
                                     Student.prototype.intro=function(){
                                         console.log("I'm "+this.sname+",I'm "+this.sage);
                                     };
                                     var lilei=new Student("lilei",11);
                                     var hmm=new Student("hanmeimei",12);
                                     console.log(lilei);
                                     console.log(hmm);
                                     lilei.intro();
                                     hmm.intro();
                                     console.log(lilei.__proto__==hmm.__proto__);
                       3.强调: 原型对象中的方法，要想访问对象自己的属性，也必须加this.
                       4.总结:
                           1.每个子对象，值不同的属性，都要定义在构造函数中
                           2.所有子对象共有的相同方法和属性值，都要集中定义在原型对象中。
                       5.共有属性和自有属性比较:
                           自有属性: 直接保存在当前对象本地的属性
                           共有属性: 保存在原型对象中，所有子对象共用的属性
                            相同: 取值时, 对象.属性
                            不同: 修改时:
                               1.自有属性可直接通过子对象修改:==>子对象.自有属性=值
                               2.共有属性只能通过构造函数的原型对象:==>构造函数.prototype.共有属性=值
                       6.内置对象的原型对象:其实每种*内置对象*也都有一对儿构造函数和原型对象，其中:构造函数负责创建新对象，
                                       A.比如: var arr=new Array();
                                               var now=new Date();
                                               var reg=new RegExp();
                                       B.特例: Math和window不是构造函数，不能new！
                                       C.原型对象负责集中存储该类型可用的所有API
                                         比如: arr.sort()  arr.push()  arr.slice()
                                       D.因为Array.prototype:{
                                                      sort(){...},
                                                      push(){...},
                                                      slice(){...},
                                                      ...}
                       鄙视：ES标准中规定了11中内置类型：
                                      String  Number  Boolean ——包装类型
                                      Array  Date   RegExp   Math
                                      Error
                                      Function  Object
                                      global(在浏览器中被window代替)
                                     每种内置类型都包含2部分组成:
                                      1. 构造函数: 创建子对象
                                      2. 原型对象: 保存共有成员
                                     问题: 旧浏览器不支持新的API
                                     为什么: 旧浏览器中原型对象中不包含该API
                             ********解决: 自定义该API，并添加到原型对象中
                             ********搜索: MDN 类型.prototype.方法名
                                         ->polyfill 复制即可
                       7.解决浏览器兼容性问题: 旧浏览器无法使用新API,2步:
                            1. 判断: 如果当前浏览器的指定类型的原型中不包含想要的API
                                 if(!"indexOf" in Array.prototype)
                                 //其中in用于检查左边的成员名是否在右边的对象中或对象的原型链上
                                 if(typeof Array.prototype.indexOf!=="function")
                            2. 如果没有就向原型中添加一个新函数
                               Array.prototype.indexOf=function(){
                               this //代表当前数组对象
                               }
                       ex:	if(typeof Array.prototype.indexOf!=="function"){
                                 Array.prototype.indexOf=function(val,fromi){
                                     fromi=fromi||0;
                                     for(var i=fromi;i<this.length;i++){
                                         if(this[i]===val){
                                             return i;
                                         }
                                     }
                                     return -1;
                                 }
                             }
                             var reds=[1,3,5,6,3,2,1];
                             document.write(
                                 reds.indexOf(10)+"</br>"+     //-1
                                 reds.indexOf(3,2)+"</br>" //4
                             );
                            鄙视：包装类型
                            什么是: 专门保存原始类型的值，并提供操作原始类型值的API
                            为什么: 原始类型的值自身不包含任何功能！
                            何时: 试图用原始类型的值调用方法时，都会自动使用包装类型对象来帮助原始类型的值执行操作
                            如何: 不用自己用!
                                 比如: "Hello".toUpperCase()
                                  typeof "Hello"  string
                                  new String("Hello").toUpperCase()
                                  new String释放
                            问题: 1. 为原始类型的值添加属性，结果?，无效
                                  2. 包装类型的API也出现浏览器兼容性问题
                            ex:
                             if(typeof String.prototype.startsWith!=="function"){
                                 String.prototype.startsWith=function(str){
                                     document.write("调用自定义的startsWith<br/>");
                                     return new RegExp("^"+str).test(this);
                                 }
                             }
                             if(typeof String.prototype.endsWith!=="function"){
                                 String.prototype.endsWith=function(str){
                                     document.write("调用自定义的endsWith<br/>");
                                     return new RegExp(str+"$").test(this);
                                 }
                             }
                             var url="http://tmooc.cn/images/logo.png";
                             if(url.startsWith("http")){
                                 document.write("采用http协议<br/>");
                             }else{
                                 document.write("采用https协议<br/>");
                             }
                             if(url.endsWith(".png")){
                                 document.write("是png格式的图片");
                             }else{
                                 document.write("不是png格式的图片");
                             }
                       8.原型链: 由多级父对象逐级继承形成的链式结构，任何对象都有__proto__属性指向其父对象，
                                 保存了所有对象中的成员，控制着对象成员的访问顺序，即优先使用自有属性，
                                 自己没有才沿原型链向父级找，只要找到就不再向上找**********
                          鄙视：如何判断一个对象是不是数组类型，共有几种方式**************************
                          错误: typeof 只能区分原始类型,function和引用类型对象
                                无法进一步区分引用类型对象的具体类型名
                             1. 判断原型对象:
                                 obj.__proto__===Array.prototype
                                 Array.prototype.isPrototypeOf(obj)
                                 ex:var obj1={},obj2=[],obj3=new Date(),obj4={};
                                    obj4.__proto__=obj2;
                                    console.log(
                                      /*obj1.__proto__===Array.prototype,
                                        obj2.__proto__===Array.prototype,
                                        obj3.__proto__===Array.prototype*/
                                        Array.prototype.isPrototypeOf(obj1),
                                        Array.prototype.isPrototypeOf(obj2),
                                        Array.prototype.isPrototypeOf(obj3)
                                    );
                             2. 判断构造函数:
                                 obj.constructor===Array
                                 obj instanceof Array--------------instance实例
                                 问题: 不严格: 不仅检查直接父对象，且检查整个原型链。
                                 ex:console.log(
                                    /*	obj1.constructor===Array,
                                         obj2.constructor===Array,
                                         obj3.constructor===Array*/
                                         obj1 instanceof Array,
                                         obj2 instanceof Array,
                                         obj3 instanceof Array,
                                         obj4 instanceof Array
                                     );
                             3. 判断隐藏的class属性:
                                 每个对象内部都有一个隐藏的class属性，在创建对象时，就记录了对象创建的类型，class属性不随继承关系改变而改变
                                 如何: 唯一的办法:顶级Object.prototype的toString方法
                                 问题: 各级内置类型的原型对象中都重写了toString方法，导致子对象无法调用到顶级toString方法
                                 解决: .call()
                                    要抢的函数全名.call(对象)
                                    Object.prototype.toString.call(obj)
                                                   //obj.toString()
                                 ex:console.log(Object.prototype.toString.call(obj1)==="[object Array]");
                                    console.log(Object.prototype.toString.call(obj2)==="[object Array]");
                                    console.log(Object.prototype.toString.call(obj3)==="[object Array]");
                                    console.log(Object.prototype.toString.call(obj4)==="[object Array]");
                             4.isArray(),ES5新语法：
                                 ex:	console.log(
                                         Array.isArray(obj1),
                                         Array.isArray(obj2),
                                         Array.isArray(obj3),
                                         Array.isArray(obj4)
                                     )
              3.多态: 同一个函数，在不同情况下，表现出不同的状态
                      包括: 2种:
                          1. 重载overload
                          2. 重写override:如果子对象觉得父对象的成员不好用，就可在子对象本地定义同名成员，覆盖父对象的成员。
                   1.为什么: 从父对象继承来的成员不一定都是想要的
                   2.何时使用: 如果子对象觉得父对象的成员不好用
                   3.使用方法--自定义继承:
                       1.何时使用: 只要希望获取其它对象现成的成员时
                       2.如何: 3种:
                         1. 直接修改**一个对象**的__proto__属性指向新父对象
                                  child.__proto__=father
                           A.问题: __proto__是内部属性，不推荐使用
                           B.解决: Object.setPrototypeOf(child,father)
                               ex:	function Student(name,age){
                                         this.sname=name;
                                         this.sage=age;
                                     }
                                     Student.prototype.intro=function(){
                                         console.log("I'm "+this.sname+",I'm "+this.sage);
                                     };
                                     var lilei=new Student("lilei",11);
                                     var hmm=new Student("hanmeimei",12);
                                     var father={
                                         bal:10000000,
                                         car:"infiniti"
                                     };
                                  /*	hmm.__proto__=father;*/
                                     Object.setPrototypeOf(hmm,father);
                                     console.log(lilei);
                                     console.log(hmm);
                                     console.log(lilei.bal,lilei.car);
                                     console.log(hmm.bal,hmm.car)
                         2. 通过修改构造函数的原型对象来**批量修改所有子对象***的父对象:
                               构造函数.prototype=father
                               强调: 时机: 在开始创建子对象之前，就要换。
                                 ex:	var father={
                                    		bal:10000000,
                                    		car:"infiniti"
                                    	};
                                    	function Student(name,age){
                                    		this.sname=name;
                                    		this.sage=age;
                                    	}
                                    	Student.prototype=father;
                                    	Student.prototype.intro=function(){
                                    		console.log("I'm "+this.sname+",I'm "+this.sage);
                                    	};
                                    	var lilei=new Student("lilei",11);
                                    	var hmm=new Student("hanmeimei",12);
                                    	console.log(lilei);
                                    	console.log(hmm);
                                    	console.log(lilei.bal,lilei.car);
                                    	console.log(hmm.bal,hmm.car);
                                    	lilei.intro();
                                    	hmm.intro();
                                    	console.log(father);
                         3. 两种类型间的继承: 更像Java的继承
                           A.问题: 如果两种类型间拥有部分相同的属性结构和方法定义。-----飞机大战的小蜜蜂和敌机有fname和speed,以及prototype方法fly()
                           B.解决: 抽象出一个父类型:
                                1. 父类型的构造函数中包含子类型相同的部分属性
                                2. 父类型的原型对象中包含子类型相同的部分方法
                                3. 在子类型构造函数中借用父类型构造
                                4. 让子类型原型继承父类型原型-----Object.setPrototypeOf(子类型.prototype, 父类型的prototype)
                           C.错误: 直接调用父类型构造:如果一个函数不用.不用new调用的话，***其中的this默认指向window***
                           D.解决: 用call强行调用，并替换this为指定对象:**********
                                   父类型构造(要抢的函数全名).call(this,参数值...)
                                  ex:
                                  call: 可强行调用一个函数，并替换函数中的this
                                  何时: 如果函数中默认的this不是想要的
                                  如何: 函数.call(替换this的对象,参数值,参数值,... ...)
                                        让子类型原型对象继承父类型原型对象
                           ex:	function Flyer(fname,speed){
                              		this.fname=fname;
                              		this.speed=speed;
                              	}
                              	Flyer.prototype.fly=function(){
                              		console.log(this.fname+"以时速"+this.speed+"飞行");
                              	};
                              	function plane(fname,speed,score){
                              		/*window.*/Flyer.call(this,fname,speed);------------------重要步骤
                              		this.score=score;
                              	}
                              	plane.prototype.getScore=function(){
                              		console.log("击落"+this.fname+"得"+this.score+"分");
                              	};
                              	Object.setPrototypeOf(plane.prototype,Flyer.prototype);
                              	var f16=new plane("f16",1000,5);
                              	f16.fly();
                              	f16.getScore();
                              	console.log(f16);
              4.总结: 面向对象三特点:
                       封装:将事物的属性和功能集中定义在一个对象中，便于维护
                       继承:父对象的成员，子对象无需重复创建，可直接使用，代码重用，节约内存——偷懒
                       多态:如果父对象的成员不好用，可在子对象中重写同名成员，为了体现父子对象间的差异
     12.ES5:ECMAScript: ECMA组织制定的JavaScript语言的国际标准，所有浏览器厂商遵照实现。规定了JS语言的核心语法。
         1.严格模式:比普通js运行模式更严格的模式
             1.为什么:js语言有很多广受诟病的缺陷
             2.何时: 2种:
                 1. 新项目,建议必须使用严格模式
                 2. 旧项目, 建议逐个模块向严格模式迁移
             3.如何: 2种:
                 1. 整个代码段启用严格模式，即在script元素或js文件的开头加入:"use strict";
                 2. 仅对单个函数启用严格模式，即在function内，函数体的顶部加入:"use strict";
             4.要求:
                 1.不允许对未声明的变量赋值
                 为什么: 自动创建全局变量，会导致歧义和内存泄漏
                     ex:	"use strict";
                         (function(){
                             var gf;
                             qgf="今晚308，w84u";
                             console.log(gf);
                             console.log(qgf);
                         })()
                 2.静默失败升级为错误
                 为什么：静默失败: 程序执行不成功，也不报错
                     ex:"use strict";
                       function Flyer(fname,speed){
                             this.fname=fname;
                             this.speed=speed;
                         }
                         var f16={};
                         Flyer.call(f16,"F16",1000);
                         console.log(f16);
                 3.普通函数调用中的this，不再自动指向window，而是指向undefined
                    为什么: 堵住通过this造成内存泄漏的途径
                 4.不建议使用arguments和arguments.callee实现递归----------解决：用循环解决
                    arguments.callee: 在函数内，自动获得当前函数本身，专门用于递归！
                    问题: 递归效率极低！重复计算量极大！
                          禁用arguments.callee等效于禁用递归！
                    解决: 几乎所有的递归，都可用循环解决
                     ex:	"use strict";----------------------启用严格模式时，无法使用arguments.callee
                         function f(n){   //1 1 2 3 5 8 13 21 34 55
                             if(n<3) return 1;
                             else
                             return arguments.callee(n-1)+arguments.callee(n-2);
                         }
                         console.log(f(10));  //55
                     解决方法：
                         function f(n){   //1 1 2 3 5 8 13 21 34 55
                             if(n<3) return 1;
                             else{
                                 //f1    f2         i
                                 //1      1    2    f3
                                 //1      2    3    f4
                                 //2      3    5    f5
                                 //3      5    8    f6
                                 var f1= 1,f2= 1,fi;
                                 for(var i=3;i<=n;i++){
                                     fi=f1+f2;
                                     f1=f2;
                                     f2=fi;
                                 }
                                 return fi;
                             }
                             }
                             console.log(f(10));
         2.保护对象:JS中的对象可随意修改属性值，可随意添加删除属性，有必要保护对属性值的修改
             1.对象属性分为:
                 命名属性:可直接用.访问到的属性
                 内部属性：实际存在，但不可以用.来访问------比如class
             2.命名属性又分为2大类：数据属性:直接存储属性值的属性
                                    访问器属性: 不存储属性值，仅提供对其它属性的保护（***********）
             3.保护属性：
                 3.1数据属性:（***********）
                     {value: 实际存储属性值
                     writable: true/false, //控制是否可修改
                     enumerable: true/false, //控制是否可被for in遍历到，不能控制.直接访问——不完全的隐藏
                     configurable: true/false, //控制是否可删除该属性, 还控制着，是否可修改另外两个特性---删除和修改，遍历（***********）}
                     强调: configurable经常作为前两个属性的双保险，且一旦设为false，不可逆！
                     1.查看四大特性:var attrs=Object.getOwnPropertyDescriptor(对象,"属性名")
                         ex:	var lily={
                                 id:1001,
                                 ename:"莉莉",
                                 salary:12000
                             };
                             var id_attrs=Object.getOwnPropertyDescriptor(lily,"id");
                             console.log(id_attrs);
                     2.如何修改四大特性:Object.defineProperty(对象,"属性名",{
                                                           特性:值,
                                                           特性:值,
                                                           ... ...
                                                           })
                         A.问题: defineProperty一次只能修改一个属性
                         B.解决: 同时修改多个属性:
                               Object.defineProperties(对象,{
                                 属性名:{要修改的特性:值},
                               属性名:{要修改的特性:值 },
                                     ... : ...
                               })
                         C.问题: 只能进行最基本的保护，无法用自定义规则保护属性
                         D.解决方法:访问器属性
                         f.如果使用defineProperty动态添加的属性四大属性默认为false；而用this添加的四大属性默认值都为true
                 3.2.访问器属性：不实际存储数据，专门为另一个数据属性提供保护的特殊属性
                     1.何时: 只要用自定义逻辑保护属性时
                     2.如何: 2步:不能用直接量添加，只能用defineProperty或defioneProperties
                     3.前提：先有一个受保护的数据属性实际存储属性值，且受保护的数据属性最好隐藏（enumerabel:false）
                     4.四大特性：
                         {
                                 get: function(){ return this.数据属性 }
                                 set: function(val){
                                   if(val符合自定义规则时)
                         		   才this.数据属性=val
                                   else
                                    报错!
                                 }
                                 enumerable:
                                 configurable:
                               }
                     5.使用：用法和普通数据属性完全一样，
                             内部：试图用访问器属性获取值时，自动调用get方法
                                   试图用
                             1. 定义一个隐藏的数据属性实际存储属性值
                             2. 添加访问器属性保护隐藏的数据属性:
                                     Object.defineProperty(对象,"属性名",{
                                     get(){//在试图获取属性值时自动调用
                                     //返回受保护的数据属性值
                                     },
                                     set(val){//在试图修改属性值时自动调用
                                        //参数val会自动获得要修改的新值
                                       //如果验证val符合规则
                                             //才将val赋值给受保护的属性
                                        //否则
                                           //报错！
                                     },
                                       enumerable:true,
                                       configurable:false
                                     })
                             3.如何使用访问器属性: 同普通属性用法完全一致,其中赋值时，自动调用set，取值时自动调get
                                     A.内部属性:不能用.直接访问的隐藏属性__proto__
                     ex:function Emp(id,ename,salary,age){
                         Object.defineProperties(this,{
                         id:{
                             value:id,
                             writable:false,
                             enumerable:true,
                             configurable:false
                         },
                         ename:{
                             value:ename,
                             writable:true,
                             enumerable:true,
                             configurable:false
                         },
                         salary:{
                             value:salary,
                             writable:true,
                             enumerable:false,
                             configurable:false
                         },
                         _age:{
                                 writable:true,
                                 enumerable:false,
                                 configurable:false
                         }
                         });
                         this.age=age;
                         //Object.preventExtensions(this);---------------------禁止添加新属性
                         Object.seal(this);---------------------禁止扩展和删除新属性
                       }
                       Object.defineProperty(Emp.prototype,"age",{----------因为age不是一个可以直接使用的值，
                         get:function(){                                    而是一套具有逻辑性的代码，希望所有子对象都可以使用
                             console.log("自动调用get属性");
                             return this._age;
                         },
                         set:function(val){
                             console.log("自动调用age的set方法");
                             if(val>=18&&val<=65)
                             this._age=val;
                             else
                             throw new Error("年龄范围不对");
                         },
                         enumerable:true,
                         configurable:true
                       });
                         var lily=new Emp(1001,"lily",12000,22);
                         lily.id=1002;
                         delete lily.ename;
                         for(var key in lily){
                             console.log(key+" : "+lily[key]);
                         }
                         console.log(lily);
             4.保护结构：
                 防篡改: 保护对对象结构的修改:3个级别:
                    1. 防扩展: 禁止添加新属性
                              Object.preventExtensions(obj)
                         原理: 每个obj内部都有一个隐藏属性:Extensible，默认为true,
                               preventExtensions将Extensible改为false
                    2. 密封: 既不可以扩展，又禁止删除现有属性
                                  Object.seal(obj)
                         原理: 既修改obj的Extensible为false,又将所有属性的configurable都改为false
                         ex:JScore/day06/02-constructor.html
                    3. 冻结: 在密封基础上禁止修改任何值
                             Object.freeze(obj)
                         原理: 修改obj的Extensible为false,将所有属性的configurable都改为false
                              还将所有属性的writable都改为false
                         使用场景：数据库不能修改，只读内容
                         ex:	"use strict";
                            	var dbconfig={
                            		host:"127.0.0.1",
                            		port:27017,
                            		db:"xz",
                            		user:"root",
                            		pwd:""
                            	};
                            	Object.freeze(dbconfig);
                            	dbconfig.user="hh";
         3.Object.create(): 可直接用一个父对象创建一个子对象。（***********）
             1.如何: var child=Object.create(father,{
                     属性:{
                      value:值,
                      writable:true,
                      enumerable:true,
                      configurable:true,
                   },
                   ... : {
                     ...
                   }
                   });
             2.强调: 只要添加到对象中的属性，四大特性默认为false，必须显式写为true。
             3.原理: 1. 创建一个空对象
                     2. 让新对象自动继承father
                     3. 为新对象扩展新的自有属性
             4.何时: 如果没有构造函数，只有父对象，也想创建子对象时。
             ex:	var father={
                		bal:10000000,
                		car:"infiniti"
                	};
                	var hmm=Object.create(father,{
                		bao:{
                			value:"LV",
                			writable:true,
                			enumerable:true,
                			configurable:true
                		},
                		house:{
                			value:"200",
                			writable:true,
                			enumerable:true,
                			configurable:true
                		}
                	});
                	console.log(hmm);
         4.call/apply/bind区别（***********）：用来替换函数中不正确的this
              1.call和apply: 强行*调用*一个函数并*临时*替换函数中的this为指定对象。
                 差别: 仅在参数上:
                   call要求传入函数的参数，必须单独传入逗号分隔
                     函数.call(替换this的对象, 参数值, ......)
                   apply要求传入函数的参数，必须放入数组中整体传入。*apply可自动打散数组类型的参数*
                     函数.apply(替换this的对象, [ 参数值, ..... ])
                 ex:	function calc(base,bonus1,bonus2){
                         console.log(this.ename+"工资总和为"+(base+bonus1+bonus2));
                     }
                     var lilei={ename:"lilei"};
                     var hmm={ename:"hanmeimei"};
                     calc.call(lilei,2000,1000,1000);
                     var bonus=[2000,2000,2000];
                     calc.apply(hmm,bonus)
              2.bind: 基于一个现有函数*创建*一个功能完全相同的新函数，并*永久*绑定this为指定对象，还可永久绑定部分固定的参数值。
                     何时：如果希望永久绑定this时
                     强调: 用bind绑定的this，不能再被call/apply替换
                     如何: 2步:
                          1. var fun=函数.bind(替换this的对象,部分参数值);
                          2. fun() //this->永久绑定的对象
                     ex:	function calc(base,bonus1,bonus2){
                                         console.log(this.ename+"工资总和为"+(base+bonus1+bonus2));
                                     }
                                     var lilei={ename:"lilei"};
                                     var hmm={ename:"hanmeimei"};
                                     var lilei_calc=calc.bind(lilei,10000);--------------用bind永久绑定了lilei为指定对象，以及固定了base的值
                                     lilei_calc(2000,2000);
                                     var hmm_calc=calc.bind(hmm,20000);
                                     hmm_calc(1000,1000);
              3.何时用: 只要函数中的this不是想要的:（***********）
                  1.如果立刻执行函数，临时替换this,可使用：call/apply
                         call: 如果参数单独传入
                         apply: 如果参数放在数组中传入
                  2.希望创建一个新函数作为回调函数给别人用时，可使用bind
         5.数组API:
           1.判断：every()/some():判断数组中的元素是否符合要求
               1.返回值: bool
               2.every():判断数组中是否每个元素都满足要求
                       var bool=arr.every(function(elem,i,arr){
                                //elem会自动获得当前正在变量的元素值
                                //i 当前正在遍历到的位置
                                //arr 当前数组对象
                                 return 判断条件
                                 })
                       ex:	var arr1=[2,4,6,8],arr2=[1,2,3,4,5];------------判断是否全部为偶数
                             console.log(
                                 arr1.every(function(elem){
                                     return elem%2==0;
                                 }),//true
                                 arr2.every(function(elem){
                                     return elem%2==0;
                                 })//false
                             );
                       ex:	var arr1=[2,4,6,8,1],arr2=[1,2,3,4,5];-----------判断从小到大排列
                             console.log(
                                 arr1.every(function(elem,i,arr){
                                     return i<arr.length-1?elem<=arr[i+1]:true;
                                 }),//false
                                 arr2.every(function(elem,i,arr){
                                     return i<arr.length-1?elem<=arr[i+1]:true;
                                 })//true
                             );
               3.some():判断数组中是否包含满足要求的元素
                       var bool=arr.some(function(elem,i,arr){
                              //elem会自动获得当前正在变量的元素值
                              //i 当前正在遍历到的位置
                              //arr 当前数组对象
                                 return 判断条件
                                })
                       ex:	var arr1=[2,4,6,8],arr2=[1,2,3,4,5];------------判断是否有偶数
                             console.log(
                                 arr1.some(function(elem){
                                     return elem%2==0;
                                 }),//true
                                 arr2.some(function(elem){
                                     return elem%2==0;
                                 })//true
                             );
               4.强调: 数组API的回调函数(return)中this默认->window，所以，不能用this指代当前元素值
           2.遍历forEach()/map(): 对数组中每元素执行相同的操作:
               1. forEach(): 对原数组中每个元素执行相同的操作-------直接修改原数组
                       arr.forEach(function(elem,i,arr){
                       arr[i]=新值
                       })
                       ex:	var arr=[1,2,3,4];------------得出偶数数组
                          	arr.forEach(function(elem,i,arr){
                          		//arr[i]*=2;
                          		arr[i]=elem*2;
                          		//elem*=2;----------此种方法错误，因为是直接取出原数组值修改后，再放回原数组，并不能直接通过操作改变数组值
                          	});
                          	console.log(arr);////arr=[2, 4, 6, 8]
                       ex:兼容IE8写法：
                             var arr=[1,2,,4,5,,7,8];
                             if(typeof Array.prototype.forEach!="function"){
                                 Array.prototype.forEach=function(fun){
                                     document.write("调用自定义Array的forEach<br/>");
                                     for(var i=0;i<this.length;i++){
                                         if(this[i]!==undefined){
                                          fun(this[i],i,this)
                                          }
                                     }
                                 }
                             }
                             arr.forEach(function(elem,i,arr){
                                 //arr[i]*=2;
                                 arr[i]=elem*2;
                                 //elem*=2;
                             });
                             document.write(arr);
               2. map(): 取出原数组中每个元素，执行相同操作后，放入新数组返回--------------不改变原数组，返回新数组
                       var new=arr.map(function(elem,i,arr){
                       return 新值
                       })
                       ex:	var arr=[1,2,3,4];
                          	var evens=arr.map(function(elem,i,arr){
                          		return elem*=2;
                          	});
                          	console.log(evens);//evens=[2, 4, 6, 8]
                          	console.log(arr);//arr=[1, 2, 3, 4]
                       ex:兼容IE8写法：
                             var arr=[1,2,,4,5,,7,8];
                             if(typeof Array.prototype.map!="function"){
                         		Array.prototype.map=function(fun){
                         			document.write("调用自定义Array的map<br/>");
                         			for(var i= 0,result=[];i<this.length;i++){
                         				if(this[i]!==undefined){
                         					result[i]=fun(this[i],i,this);
                         				 }
                         			}
                         			return result;
                         		}
                         	}
                         	var evens=arr.map(function(elem,i,arr){
                         		return elem*=2;
                         	});
                         	document.write(evens);
                         	document.write("<br/>");
                         	document.write(arr);
           3.过滤和汇总:filter()/reduce()
               1. 过滤: 复制出原数组中符合条件的元素组成****新数组*****
                       var subArr=arr.filter(function(elem,i,arr){
                               return 判断条件
                       })
                       筛选出arr中符合判断条件的元素值，放入新数组返回。
                       ex:	var arr=[1,2,3,4,5,6];
                          	var evens=arr.filter(function(elem){
                          		return elem%2==0;
                          	});
                          	console.log(arr);
                          	console.log(evens);
               2. 汇总: 将数组中所有元素，统计出一个汇总**结果**，返回值为**数值***，即将arr数组中每个值累加后，求和。
                         其实: reduce不一定非要从0开始累加，可从任意startVal开始累加
                       var r=arr.reduce(function(prev,val,i,arr){//prev: 临时保存截止目前的汇总值
                             return prev+val
                       },base);---------base为基数值
                     ex:	var arr=[1,2,3,4,5,6];
                        	var sum=arr.reduce(function(prev,elem){
                        		return prev+elem;
                        	});
                        	console.log(sum);//21
                        	var arr2=[4,5,6,7,8];
                        	sum=arr2.reduce(function(prev,elem){
                        		return prev+elem;
                        	},sum);
                        	console.log(sum);//51
     13.ES6:
         1.let: 创建一个仅在当前块内有效的变量
              1.var的问题:
                 1. js中**没有块级作用域**，导致块内的变量会污染外部。
                 2. js的**声明提前**会打乱程序的正常执行顺序
                     ex:	var a=10;
                         function fun(){
                             console.log(a);--------------如果局部有变量，是不会去使用全局的a的
                             var a=100;
                             a++;
                             console.log(a);
                         }
                         fun();//undefined   101
                         console.log(a);//10
                     ex:	"use strict";
                         var a=10;
                         function fun(){
                             console.log(a);
                             let a=100;
                             a++;
                             console.log(a);
                         }
                         fun();//a is not defined
                         console.log(a);
                     ex:"use strict";
                        var a=10;
                        function fun(){
                            console.log(window.a);
                            let a=100;
                            a++;
                            console.log(a);
                        }
                        fun();//10   101
                        console.log(a);//10
              2.何时: 今后强烈建议用let代替var
              3.强调: let必须配套严格模式使用
                 1. 解决声明提前: 检查let a之前不允许提前使用a，即变相强制将所有变量的声明放在当前作用域的顶部
                 2. 解决块级作用域:let声明的变量，仅在当前{}内有效，出了块失效。
              4.原理：其实，let就是匿名函数自调，解决IE8兼容问题：使用匿名函数(function(){})()****
                 ex:		var t=0;//记录操作小号的总时间
                    		function conn(){
                    			console.log("建立连接，耗时：0.3s");
                    			t+=0.3;
                    		}
                    		function query(){
                    			console.log("查询数据，耗时：0.8s");
                    			t+=0.8;
                    			var err=true;
                    			if(err){
                    				let t=new Date();
                    				console.log("出错啦，at:"+t);
                    			}
                    		}
                    		conn();
                    		query();
                    		console.log("总共耗时："+t);
                 ex:同上面效果一样，解决IE8兼容问题
                    		var t=0;//记录操作小号的总时间
                    		function conn(){
                    			console.log("建立连接，耗时：0.3s");
                    			t+=0.3;
                    		}
                    		function query(){
                    			console.log("查询数据，耗时：0.8s");
                    			t+=0.8;
                    			var err=true;
                    			if(err){
                    				(function(){-------------------使用匿名函数自调
                    				var t=new Date();
                    				console.log("出错啦，at:"+t);
                    				})()
                    			}
                    		}
                    		conn();
                    		query();
                    		console.log("总共耗时："+t);
              5.let与for循环：***********************很重要
                  let与for:
                    for(let i=0;i<xxx.length;i++){
                      //(function(i){-----------------------将受保护的i变量传入
                        //形成闭包
                      //})(i)
                    }
                 ex:<button>click me</button>--------------实现点击时显示button顺序
                    <button>click me</button>
                    <button>click me</button>
                    <script>
                    	var btns=document.getElementsByTagName("button");
                    	for(var i=0;i<btns.length;i++){
                    		btns[i].onclick=function(){
                    			alert(i);-------------------------//3
                    		}
                    	}
                    </script>
                 方法一：解决上面全部显示3的问题：------使用let解决
                     var btns=document.getElementsByTagName("button");
                     for(let i=0;i<btns.length;i++){---------------------var变let
                         btns[i].onclick=function(){
                             alert(i);-------------------------//3
                         }
                     }
                 方法二：解决上面全部显示3的问题：------使用匿名函数自调-闭包解决
                 	var btns=document.getElementsByTagName("button");
                 	for(var i=0;i<btns.length;i++){
                 		(function(i){---------------------------------------使用匿名函数自调
                 		btns[i].onclick=function(){
                 			alert(i);
                 		};
                 		})(i)
                 	}
         2.参数增强：
             1.参数默认值default
                 function fun(参数1，参数2，...，参数n=默认值)
                 强调：可以有多个参数拥有默认值，但必须放到参数列表的最后
                 原理：参数n=参数n||默认值----短路逻辑
             2.剩余参数rest：代替arguments
                 arguments问题：
                     1.不是纯正的数组类型
                     解决：类数组对象转数组：强行借用数组的slice,复制所有元素
                     var args=Array.prototype.slice.call(arguments);
                                     //arguments.slice()
                     ex:	function fun(ename,base){
                        		var args=Array.prototype.slice.call(arguments);
                        		args=args.slice(1);
                        		var sum=args.reduce(function(prev,elem){
                        			return prev+elem;
                        		});
                        		console.log(ename+"总工资是："+(sum));
                        	}
                        	fun("tom",12000,3000,4000);
                     2.只能获取全部参数，不能有选择获取
                     解决：function fun(参数1,参数2,...数组名){
                         数组中仅包含除之前参数外的所有剩余参数
                     }
                     ex:	function fun(ename,base,...args){
                        		var sum=args.reduce(function(prev,elem){
                        			return prev+elem;
                        		},base);
                        		console.log(ename+"总工资是："+(sum));
                        	}
                        	fun("tom",12000,3000,4000);
             3.散播spread:调用函数是，可用...数组名打散参数
             原理：函数.apply(null,数组);
                 ex:
                 var arr=[1,2,3,4];
                 Math.max(...arr)--------------或者Math.max.apply(null,arr)
                 //3
         3.箭头函数:简化**回调函数**:
              1.何时:今后，几乎所有的回调函数都可用箭头函数简化
              2.如何简化:
                       1. 所有回调函数都可:去function改=>
                       2. 如果只有一个参数:可省略()，但是,如果没有参数，必须保留空()
                       3. 如果函数体只有一句话: 可省略{}
                       4. 如果这一句话还是return，可省略return
              3.更大用途: 箭头函数内外共用同一个this——取代bind（*******）
              4.特殊: 如果不希望内外共用this，就不能用箭头函数
                        A.比如:事件处理函数:
                           elem.addEventListener("click",function(){this->elem})
                           elem.addEventListener("click",()=>{this->不是elem})
                           变通解决:
                           elem.addEventListener("click",e=>{e.target->elem})（******）
                        B.对象的方法不能内外共用this
         4.所有的回调函数：
             	var arr=[12,3,123,23,2,1];----------排序
             	arr.sort((a,b)=> a-b);
             	console.log(String(arr));
     
             	var str="you can you up!";-----------------替换首字母大写
             	str=str.replace(/^[a-z]/g,kw=>kw.toUpperCase());
             	console.log(str);
     
             	var arr=[1,2,3,4,5];-----------------------遍历
             	arr.forEach((elem,i,arr)=>arr[i]=elem*2);
             	console.log(String(arr));
             	var arr=[1,2,3,4,5];
             	arr=arr.map(elem=>elem*2);
             	console.log(String(arr));
     
             	btn.onclick=()=>{-------------------------绑定事件
             		alert("痒!");
             	};
     
             	(()=>{----------------------------------------函数自调
             		console.log("Hello 来自 匿名函数自调");
             	})()
         5.模板字符串: 对字符串拼接的简化:
                 ESlint中已禁止使用+进行拼接
              1.何时: 只要字符串拼接时，需要动态执行表达式
              2.如何: `反引号——ESC键的正下方
                     模板字符串必须用``包裹
                     ``中支持: 换行, 变量, 表达式
              3.强调: 每个变量和表达式都要用${...}包裹
              ex:
              <ul id=searchList></ul>
              <script>
              var plist=[
                 	{name:"lily",salary:1000},
                 	{name:"lucy",salary:2000},
                 	{name:"jerry",salary:3000}
                 ];
                 var html="";
                 	for(var i= 0;i<plist.length;i++){
                 		var p=plist[i];
                 		html+=`
                 		<li>
                 		<string>${p.name}</stong>
                 		<i>共有工资${p.salary}</i>
                 		</li>
                 		`;
                 	}
                 	searchList.innerHTML=html;
              </script>
         6.解构：简化多个变量的赋值
             1.数组解构：将数组中元素，分发给多个变量
                 下标对下标：var[变量1，变量2,...]
                             =[值1,值2,...]
                 变量1=值1
                 变量2=值2
             鄙视: 不声明第三个变量，交换变量的值
                a+=b, b=a-b, a-=b;
                a^=b, b^=a, a^=b;
                问题: 只能交换数字
                解决: b=[a,a=b][0]
                ES6: [a,b]=[b,a];
               ex:	var arr=["范冰冰",89,95,62];
                     var [undefined,math,chs]=arr;
                     console.log(math,chs);
             2.对象解构:将对象中的属性分别赋值给多个变量
                 属性对属性：
                 var {属性名1: 变量1, 属性名2: 变量2, ...}
                      ={属性名1: 属性值1, 属性名2: 属性值2, ...}
                     变量1=属性值1
                     变量2=属性值2
                 ex:	var products={--------------------------------模拟商品查询
                         getProductsById:function(id){
                             console.log("按id查询一个商品");
                         },
                         getProductsByName:function(pname){
                             console.log("按商品名称模糊检索一个商品");
                         },
                         getProductsByCategory:function(categoryId){
                             console.log("按商品类别检索");
                         }
                     };
                     var {getProductsById,getProductsByName,getProductsByCategory}=products;
                     getProductsById();
                     getProductsByName();
                     getProductsByCategory();
             3.函数解构:其实也是对象解构
                   问题: 传统函数定义的参数列表的顺序和个数是固定的，无法灵活的有选择的传入参数
                   解决: 对象结构方式定义参数列表和传递参数
                   2步: 1. 定义函数时，就将函数的参数定义为对象结构
                        2. 调用函数时，传入一个对象作为参数
                     ex:	function ajax({type,url,data,dataType,success}){
                             console.log(`向${url}发送请求,请求方式为${type}`);
                             if(data!==undefined){console.log(`携带参数：${data}`)};
                             if(dataType=="json"){console.log(`返回的数据类型为${dataType}`)};
                             success();
                         }
                         ajax({
                             type:"get",
                             url:"http://localhost/islogin.php",
                             success:function(){
                             console.log("处理服务器返回的数据");
                         }
                         })
         7.for of: 简化普通for循环:在特定情况下，简化普通for循环，代替forEach
              1.何时: 遍历数组中每个元素对象:
                  方法一: for(var i=0;i<plist.length;i++){
                               var p=plist[i]
                  方法二: plist.forEach((p,i,plist)=>{
                              //p  i
                           })
                  方法三: for(var p of plist){
                              //p
                           }
                  ex:<ul id="searchList">----------------------------通过遍历在页面显示li内容
                    </ul>
                    <script>
                    var plist=[
                     {name:"lily",salary:1000},
                     {name:"lucy",salary:2000},
                     {name:"jerry",salary:3000}
                    ];
                    var html="";
                    //1.普通for循环
                    /*	for(var i= 0;i<plist.length;i++){
                         var p=plist[i];
                         html+=`
                         <li>
                         <string>${p.name}</stong>
                         <i>共有工资${p.salary}</i>
                         </li>
                         `;
                     }*/
                    //2.forEach回调函数
                    /*	plist.forEach(function(p){
                         html+=`
                         <li>
                         <string>${p.name}</stong>
                         <i>共有工资${p.salary}</i>
                         </li>
                         `;
                     });*/
                    //3.for of循环，直接取每个元素对象
                     for(var p of plist){
                     html+=`
                     <li>
                         <string>${p.name}</stong>
                         <i>共有工资${p.salary}</i>
                         </li>
                             `;
                    }
                     searchList.innerHTML=html;
                    </script>
              2.如何: for(var val of arr){ val//自动获得当前元素值}（********）
              3.其中: of会自动取出arr中每个元素的值，保存到val
              4.局限:1. of只能依次遍历每个元素
                     2. 按值传递,无法修改原数组中的值,如果要直接修改原数组中的值，还要用普通for循环
                     3. 只能遍历索引数组和类数组对象。不能遍历关联数组和对象,如果遍历关联数组和对象，还要用for in循环
         8.class: 为了简化面向对象（********）
             1.对直接量的简化：
                 var obj={
                     属性名: 变量名, 如果属性名和变量名一致，则仅写一个
                     方法名(){
                       ... this.属性名 ...
                     }
                   }
             2.对类型的简化: 包括: 构造函数 和 原型对象
                  1. 定义类型:一个类型的所有属性和方法都集中包含在class{}中,
                  2.方法：
                         1.类型名提升到class之后，称为类名
                         2.构造函数一律用constructor定义,其余保持不变
                         3.共有方法可直接放入class内，等效于自动放入原型对象中。
                     class 类型名{
                       constructor(参数列表){
                         this.xxx=xxx;
                       }
                       方法名(){ ... ... }
                     }
                  3.强调: 直接放在class内的方法，默认就是定义在原型对象中
                     ex:	class Student{
                        	constructor(sname,sage){
                        		this.sname=sname;
                        		this.sage=sage;
                        	}
                        	intro(){
                        		console.log("I'm "+this.sname+" ,I'm "+this.sage);
                        	};
                        	}
                        	var lilei=new Student("lilei",11);
                        	console.log(lilei);
                        	lilei.intro();
             3.简化继承：
                  class 父类型{
                  }
                  class 子类型 extends 父类型{
                 	constructor(参数列表){
                       super(参数列表)
                     }
                  }
                 ex:	//敌机
                     class Flyer{------------------------------构造函数名提至类之后
                         constructor(fname,speed){-----------------------构造函数用constructor定义
                             this.fname=fname;
                             this.speed=speed;
                         }
                         fly(){-----------------------------------由“Flyer.prototype.fly=function(){”简化
                             console.log(this.fname+"以时速"+this.speed+"飞行");
                         };
                     }
                     class plane extends Flyer{-------------------------让plane继承父类型Flyer
                         constructor(fname,speed,score){
                             super(fname,speed);--------------------------------删除了“Object.setPrototypeOf(plane.prototype,Flyer.prototype);”
                                                                                用super代替call,并自动更换为this
                             this.score=score;
                         }
                         getScore(){
                             console.log("击落"+this.fname+"得"+this.score+"分");
                         };
                     }
                     var f16=new plane("f16",1000,5);
                     f16.fly();
                     f16.getScore();
                     console.log(f16);
             4.简化访问器
                 class 类型名{
                     constructor(参数列表){
                       Object.defineProperties(this,{
                         隐藏数据属性:{
                           四大特性...
                         }
                       })
                       this.访问器属性=值;
                     }
                     get 访问器属性名(){
                       return this.数据属性
                     }
                     set 访问器属性名(val){
                       if(val符合要求)
                        就this.数据属性=value
                       else
                        报错
                     }
                   }
                   ex:"use strict";
                     class Emp{
                         constructor(id,ename,salary,age){
                             Object.defineProperties(this,{
                             id:{
                                 value:id,
                                 writable:false,
                                 enumerable:true
                             },
                             ename:{
                                 value:ename,
                                 writable:true,
                                 enumerable:true
                             },
                             salary:{
                                 value:salary,
                                 writable:true,
                                 enumerable:false
                             },
                             _age:{
                                 writable:true,
                                 enumerable:false
                             }
                             });
                             this.age=age;
                             //Object.preventExtensions(this);
                             Object.seal(this);
                         }
                             get age(){
                                 console.log("自动调用get属性");
                                 return this._age;
                             }
                             set age(val){
                                 console.log("自动调用age的set方法");
                                 if(val>=18&&val<=65)
                                 this._age=val;
                                 else
                                 throw new Error("年龄范围不对");
                             }
                         }
                     var lily=new Emp(1001,"lily",12000,22);
                     //lily.id=1002;
                     //delete lily.ename;
                      /*	for(var key in lily){
                             console.log(key+" : "+lily[key]);
                         }*/
                     console.log(lily.age);
             5.静态方法：不需要创建子对象（实例化对象），用类型名可直接调用的方法
                 何时: 只要不确定调用该方法的对象类型时
                 原理: 不保存在原型对象中，而是保存在构造函数对象上。可通过构造函数对象，直接调用，无需子对象。
                 比如: var char=String.fromCharCode(unicode)
                       var bool=Array.isArray(obj)
                       var child=Object.create(father)
                       Object.setPrototypeOf(child,father)
                       Object.prevendExtensions(obj)
                       Object.seal(obj)
                       Object.freeze(obj)
                 如何: class 类型名{
                          static 方法名(){ ... }
                        }
                 调用: 类型名.静态方法名()
                     ex:	class Student{
                             constructor(sname,sage){
                                 this.sname=sname;
                                 this.sage=sage;
                             }
                             intr(){
                                 console.log(`I'm ${this.sname},I'm ${this.age}`);
                             }
                             static isStudent(obj){
                                 if(obj.sname!==undefined&&obj.sage!==undefined&&typeof obj.intr==="function")
                                 return true;
                                 else return false;
                             }
                         }
                         var lilei=new Student("lilei",11);
                         var obj1=new Date();
                         var obj2=function(){};
                         console.log(
                             Student.isStudent(lilei),
                             Student.isStudent(obj1),
                             Student.isStudent(obj2)
                         );
         9.promise:*****代替异步调用中的回调函数------避免回调地狱   callback hell，如果IE8不支持，还是要用回调函数callback
             需求: 多个异步调用的函数，需要顺序执行
                 1.callback解决：
                     如何: 2步:
                       1. 定义时:
                         function 前一个函数(callback){
                           异步调用:
                             结束后: callback()
                         }
                       2. 调用时:
                         前一个函数(function(){
                           下一个函数()
                         })
                     问题: callback hell
                       回调的层级越来越深！
                 2.解决: promise
                   何时: 今后只要要求多个异步操作的函数，必须顺序执行时
                   如何:
                         ex:function conn(){--------------------------------------异步变同步案例
                             return new Promise(function(open,errHandler){
                             console.log("建立连接...");
                             setTimeout(function(){//异步不同道，接力叫同步
                                 if(Math.random()<0.5){
                                     console.log("连接成功");
                                     open();
                                 }else{
                                 errHandler("连接失败");
                                 }
                             },6000);
                          });
                         }
                         function query(){
                          return new Promise(function(open,errHandler){
                             console.log("开始查询...");
                             setTimeout(function(){
                                 if(Math.random()<0.5){
                                     console.log("查询完成");
                                     open();
                                 }else{
                                     errHandler("查询失败");
                                 }
                             },4000);
                             });
                         }
                         function response(){
                             return new Promise(function(open){
                             console.log("开始返回响应...");
                             setTimeout(function(){
                                 console.log("响应完成");
                             },2000);
                             });
                         }
                         conn()
                             .then(query)
                             .then(response)
                             .catch(function(err){
                                 console.error(err);
                             });
                   异常处理: 2步:
                       1. 定义时:
                            return new Promise(function(open, errHandler){
                              如果任务正常执行，则打开开关open()
                              如果任务执行出错，则调用errHandler( 传入错误原因 )
                            })
                       2. 调用时:
                          任务1.then(任务2)
                             .catch(function(err){//errHandler
                               ... err: 获得从任务1中传出的错误信息...
                             })
                          同时等待多个任务:
                           Promise.all([
                             任务1(),
                             任务2(),
                               ...
                           ]).then().catch()
                       ex:function wenhua(){
                             return new Promise(function(open){
                                 console.log("文华起跑...");
                                 setTimeout(function(){
                                     console.log("文华到达终点!");
                                     open();
                                 },6000);
                             })
                         }
                         function yaner(){
                             return new Promise(function(open){
                                 console.log("燕儿起跑...");
                                 setTimeout(function(){
                                     console.log("燕儿到达终点!");
                                     open();
                                 },4000);
                             })
                         }
                         function dong(){
                             return new Promise(function(open){
                                 console.log("东东起跑...");
                                 setTimeout(function(){
                                     console.log("东东到达终点!");
                                     open();
                                 },2000);
                             })
                         }
                         Promise.all([
                             wenhua(),
                             yaner(),
                             dong()
                         ]).then(function(){
                             console.log("*******比赛结束!********");
                         })
     =============================================Dom========================================================================
     1. DOM：(Document Object Model)专门操作网页内容的API， W3C指定的标准，所有浏览器厂商遵照实现
         1.何时: 今后只要操作网页内容，就必须用DOM
         2.为什么: 为了统一操作网页内容的API用DOM标准操作网页内容几乎100%兼容
         3.分为:
             1.核心DOM: 万能，繁琐
             2.HTML DOM: 对核心DOM部分常用API的简化，不是万能，但简化
           包括：5件事：查找，修改，添加，删除，时间绑定
         4.DOM树:网页中的一切内容在内存中都是以树形结构存储，所有内容(元素，属性，文本)在树上，都是一个节点对象，
                 DOM有唯一的一个根节点document，所有内容节点都是document的后代节点
         5.节点对象:网页中的所有内容，都是DOM树上的节点对象
         6.类型: Node
             1.三大属性:
                 1.nodeType:节点类型
                        A.值是整数,4个:
                                   document  9
                                   element(元素)  1
                                   attribute(属性)   2
                                   text       3
                        B.何时: 只要区分节点类型时
                        C.为什么: 不同类型的节点可执行的操作不同
                        D.问题: 无法精确区分元素名
                        E.解决方法:nodeName
                 2.nodeName:节点名(元素的标签名)***
                        A.何时: 只要进一步细致区分元素种类时
                        B.包括: document  #document
                                element    元素的标签名(全大写)
                                attribute    属性名
                                text        #text
                        C.其实, nodeName可代替nodeType来鉴别节点类型*******
                 ex:document.body.nodeName====>BODY(大写判断出为元素)
                 3.nodeValue:节点值
                        A.包括: document null
                                element    null
                                attribute    属性值
                                text        文本内容----------innerHtml也可拿到文本内容***
         7.DOM操作:查找触发事件的元素->绑定事件->查找要操作的元素-->修改/添加/删除
     2.查找: 4种:
           1. 不需要查找就可直接得到:
                 document
                 document.documentElement —— html
                 document.head
                 document.body
                 document.forms[i]--------网页内所有表单
           2. 按节点间关系查找:
             1.何时: 只要已经获得一个元素，要找周围元素时
             2.包括: 2大类关系:---父子关系和兄弟关系
                  1.节点树: 包含一切内容节点的树结构
                         1.父子: elem.parentNode 父节点
                                 elem.childNodes 返回*直接*子节点的集合
                                 elem.firstChild 第一个直接子节点
                                 elem.lastChild  最后一个直接子节点
                         2.兄弟: elem.previousSibling 前一个兄弟
                                 elem.nextSibling 下一个兄弟
                         问题: 包括看不见的空字符文本节点的干扰(换行，缩进，空格...)
                  2.元素树: 只包含元素节点的树结构
                         1.父子: elem.parentElement     父元素
                                 elem.children          返回*直接*子元素的集合
                                 elem.firstElementChild 第一个直接子元素
                                 elem.lastElementChild  最后一个直接子元素
                         2.兄弟: elem.previousElementSibling
                                 elem.nextElementSibling
                         优: 不受空文本的干扰
                         缺: IE8不兼容
                         说明: 元素树不是一棵新树，仅是节点树的一个子集
                  3.鄙视: 遍历一个指定父节点下的所有后代节点
                      1. 先遍历指定父元素的直接子节点
                      2. 将遍历直接子节点的函数，在每个子节点上再执行一次
                  4.childNodes和children区别：
                      childNodes和children返回的不是数组，而是类数组对象。
                      childNodes和children都返回动态集合
                      *类数组对象(长的像数组的对象)vs 数组:
                               相同: 1.下标, 2. .length
                               不同: 类型不同，API不通用
                               简称: 集合
                     *动态集合: 不实际存储数据，每次访问集合，都重新查找DOM树。
                     *非动态集合: 数据直接保存在集合本地，无需反复查找。
                     1.问题: 反复访问集合，会导致反复查找DOM树
                     2.提前用变量缓存动态集合的数据
                     3.遍历动态集合:
                             错误: for(var i=0;i<childNodes.length;i++){...}
                             正确: for(var i=0,len=childNodes.length;i<len;i++)
                  5.鄙视: 用节点间关系，遍历指定父节点下所有后代节点
                         1.方法一：循环，但输出不是想要结果，无法遍历到子元素后代
                             ex:<html>
                                 <head>
                                     <title>遍历节点树</title>
                                     <meta charset="utf-8"/>
     
                                 </head>
                                 <body>
                                     <span>Hello World !</span>
                                     <ul id="nav">
                                         <li>电影</li>
                                         <li>综艺
                                             <ul>
                                                 <li>跑男</li>
                                                 <li>爸爸</li>
                                                 <li>极限</li>
                                             </ul>
                                         </li>
                                         <li>剧集</li>
                                     </ul>
                                       <script src="js/2.js"></script>
                                 </body>
                               </html>
                                 function getChildren(parent){
                                    console.log(parent.nodeName);
                                    var children=parent.children;
                                    for(var i=0;i<children.length;i++){---------------会造成反复重新查找DOM树，且输出的是元素整段代码
                                        console.log(children[i]);
                                    }
                                }
                                getChildren(document.body);
                         2.方法二：递归遍历解决反复查找问题
                             递归遍历2步:
                               Step1: 先仅查找直接子节点
                               Step2: 对每个直接子节点，调用和父节点完全相同的函数
                               A.算法: 深度优先遍历: 每个节点都优先遍历子节点，子节点遍历完，才遍历兄弟节点。
                               B.问题: 递归时，函数内的函数名不能写死
                         *******C.解决: 用arguments.callee指代当前函数自己。
                             ex:function getChildren(parent){
                                    console.log(parent.nodeName);
                                    var children=parent.children;
                                    for(var i= 0,len=children.length;i<len;i++){----------按值传递
                                        arguments.callee(children[i]);
                                    }
                                }
                                getChildren(document.body);
     ********************3.方法三：循环代替递归：节点迭代器对象:依次遍历，并返回每个节点对象的小工具——内置深度优先算法
                             2.如何: 2步:
                                    1. 创建节点迭代器对象:
                                            var iterator=document.createNodeIterator(
                                               parent,NodeFilter.SHOW_ALL/SHOW_ELEMENT, null, false
     
                                            );
                                    2. 循环调用迭代器的nextNode()，调到下一个节点，反复获取下一个节点，直到返回null结束。
                                            do{
                                             var node=iterator.nextNode();
                                                      if(node!=null){
                                                      //输出node
                                                      }
                                             }else break;
                                             }while(true);
                             ex:
                                 function getChildren(parent){
                                    var iterator=document.createNodeIterator(
                                        parent,NodeFilter.SHOW_ELEMENT,null,false
                                    );
                                    do{
                                        var node=iterator.nextNode();
                                        if(node!=null){
                                            console.log(node.nodeName);
                                        }else{
                                            break;
                                        }
                                    }while(true);
                                }
                                getChildren(document.body);
                  4.测试程序的执行时间:
                        console.time("name")
                        要执行的程序
                        console.timeEnd("name")
                    比如:console.time("get1");
                         getChildren1(document.body);
                         console.timeEnd("get1");
                         console.time("get2");
                         getChildren2(document.body);
                         console.timeEnd("get2");
           3. 按HTML查找: 4种:-----------例子：用js做购物车
             1. 按id查找: var elem=document.getElementById("id")
                A.强调: 1. 只能在document调用！---.getElementById，.前只能用document
                         只能返回第一个指定id的元素
             2. 按标签名查找:
                 var elems=parent.getElementsByTagName("标签名");------------------动态集合
                A.强调: 1. 可在任意父元素上调用，仅找当前父元素下的指定元素。
                        2. 返回**动态集合**-----会造成反复递归查找
                        3. 不但找直接子元素，而且找**所有后代元素**
             3. 按name属性查找: ——了解
                A.何时: 在表单中查找有name属性的表单元素时
                     var elems=document.getElementsByName("name");------------------动态集合
                B.强调: 1. 只能在document上调用
                        2. 返回动态集合
             4. 按class属性查找:
                     var elems=parent.getElementsByClassName("class");----------------------动态集合
                A.强调: 1. 在任意父元素上调用
                        2. 返回**动态集合**
                        3. 不但找直接子元素，而且在**所有后代**中查找
                        4. 不要求完整匹配class，只要包含就找到**********
                C.问题: 每次只能按一个条件查找，如果条件复杂，代码会很繁琐
                D.解决: 当查找条件复杂时，要用选择器查找
           ******实现DOM操作4步：
                 1.查找触发时间的元素
                 2.绑定事件
                 3.查找要修改的元素
                 4.修改元素
           4. 按选择器查找: Selector API: 2个:
             1. 只找一个元素:
                     var elem=parent(父元素).querySelector("selector");
             2. 找多个元素:
                     var elems=parent(父元素).querySelectorAll("selector");--------------非动态集合
             3.强调: 1. 可在任意父元素上调用
                     2. 不仅查找直接子元素，且查找所有后代元素
                     3. 返回非动态集合
                     4. 选择器兼容性，受制于当前浏览器
           *******鄙视: 按HTML查找 vs 按选择器查找
                     1. 返回值: 按HTML查找: 返回动态集合:
                         优: 首次查找效率高！只需返回需要的数据即可，不需要返回完整数据
                         缺: 造成反复查找
                     2.按选择器查找: 返回非动态集合
                         优: 不会反复查找
                         缺: 首次查找效率低
                     3. 易用性: 当查找条件复杂时
                         按HTML查找: 繁琐
                         按选择器查找: 简洁
                     4.总结:
                         1.如果根据一个条件就可获得想要的元素:首选按HTML查找
                         2.如果查找条件复杂时：首选按选择器查找
           5.总结返回值:
              1. 凡是返回一个元素的API，如果没找到，都返回null
              2. 凡是返回多个元素的API，如果没找到，都返回空元素的集合
           6.练习: 事件绑定:
             //当事件发生时，自动执行保存的事件处理函数
               elem.on事件名=function(){
             this //自动获得触发事件的.前的当前元素
             }
     3. 修改:
         1.内容:
             .innerHTML: 获取或设置元素开始标签到结束标签之间的HTML代码片段。
             .textContent: 获取或设置元素开始标签到结束标签之间的纯文字内容。------IE8不支持，使用.innerText
             .value: 获取或设置表单元素的内容
             textContent与innerHTML区别：
                 2件事: 1. 去掉文本中内嵌的标签
                        2. 将所有转义字符翻译为正文
         2.属性:3类:
               1.标准属性: 2种方式访问:
                    1. 核心DOM(**********): 4个API: 兼容一切结构化文档的API，所有属性节点都保存在元素的attributes集合中
                        优点：万能
                        问题：代码繁琐
                            var attr_node=elem.attibutes["属性名"]；
                            attr_node.nodeValue
                         1.获取属性值: elem.getAttribute("属性名")
                         2.修改属性值: elem.setAttribute("属性名","属性值")
                         3.是否包含: elem.hasAttribute("属性名")
                         4.移除属性: elem.removeAttribute("属性名")
                    2. HTML DOM:DOM将HTML标准属性都封装为了元素对象的属性，可直接用.访问——简洁——首选HTML
                        问题：只能访问标准属性
                         1.获取属性值: elem.属性名
                         2.设置属性值: elem.属性名=值
                         3.判断有没有: elem.属性名!=""
                         4.移除属性: elem.属性名=""
                         5.特殊: class属性: class是js语言的保留字，所以DOM中的class属性被迫改名为className
               2.状态属性:
                    enabled  disabled  selected  checked
                    强调：不能用核心DOM API来操作，只能用HTML DOM 打.方式操作，因为不是字符串类型，而是bool类型
                    CSS中有选择器:  :enabled :disabled :selected :checked
                    ex:var unchecked=document.querySelector("table>tbody>tr>td:first-child>input:not(:checked)");--JS做复选框例子
               3.定义自定义属性:
                 什么是: HTML标准中没有规定的，由程序员自定义添加的属性
                 何时: 2种:
                    1. 临时缓存数据
                    2. 代替id和class选择器，用于选择元素，为元素添加行为。
                     id选择器的问题: 只能有一个！
                     class选择器的问题: 只用于定义样式
                     解决: 今后，只要绑定事件，都用自定义扩展属性
                 如何:
                    1. 核心DOM:
                    2. HTML5:
                     定义时:  data-属性名="值"
                     访问时:  elem.dataset.属性名
                 ex:<ul id="u1">---------------------点击li获取属性sid值
                    	<li sid="1001">1</li>
                    	<li sid="1002">2</li>
                    	<li sid="1003">3</li>
                    	<li sid="1004">4</li>
                    </ul>
                    <script>
                    	var lis=u1.children;
                    	for(var li of lis){
                    		li.onclick=function(){
                    			alert(this.getAttribute("sid"));
                    		}
                    	}
                    </script>--------------------------------------使用getAttribute属性来获取sid
                    ex:
                    <ul id="u1">
                    	<li data-sid="1001">1</li>-----------------自定义属性
                    	<li data-sid="1002">2</li>
                    	<li data-sid="1003">3</li>
                    	<li data-sid="1004">4</li>
                    </ul>
                    <script>
                    	var lis=u1.children;
                    	for(var li of lis){
                    		li.onclick=function(){
                    			alert(this.dataset.sid);-----------------自定义获取属性
                    		}
                    	}
                    </script>--------------------------------------使用自定义data属性来获取sid
         3.样式:2种:
           单独修改一个css属性
           	1. 内联:写在元素的style属性中的样式，优先级最高，仅当前元素独有
                  1.获取或设置内联样式:elem.style.css属性
                       A.强调: 1. css属性名都要去横线变驼峰:
                                   比如: background-color->backgroundColor
                                        list-style-type->listStyleType
                              2. 所有css属性值都是字符串(可能带单位)
                              3.计算前都要先去单位，转数字再计算。
                       B.设置内联: 优: 优先级最高，当前元素独有，不影响其它元素
                       C.问题: 实际开发中可能几乎不包含内联样式。用elem.style可能无法获得任何样式。
                       D.解决: 用getComputedStyle(elem)代替elem.style
                              ComputedStyle:计算后的样式: 最终应用到元素上的所有样式的综合。
                       E.如何: var style=getComputedStyle(当前元素)
                              style.css属性
                       F.强调: 计算后的css属性都是只读,因为计算后的css属性可能原来是共用的，一旦修改，牵一发而动全身。
                               计算后的样式属性不能修改，因为来源不确定
           	2. 内部/外部样式表:3步:——危险-----------------用js做表、做表单验证
                    1. 找样式表对象:var sheet=document.stylesheets[i]
                    2. 找cssRule对象: var cssRule=sheet.cssRules[i]
                                     如果是keyframes,就需要继续找下级cssRule
                    3. 修改cssRule的style下的css属性值:
                             cssRule.style.css属性=值
                       A.问题: 每次只能修改一个css属性
                       B.解决:通过修改元素的class属性，来批量应用多个css属性*******
                       ex:用JS做表
     4.添加: 3步:
       1. 创建空元素:  var elem=document.createElement("标签名")
                     比如: var a=document.createElement("a")
                     相当于<a></a>
       2. 设置关键属性:
                   a.href="http://tmooc.cn";a.innerHTML="go to tmooc";
                   <a href="http://tmooc.cn">go to tmooc</a>
       3. 将新元素添加到DOM树指定父元素下3种:——新建的元素，必须添加到DOM树才能显示出来
             1.末尾追加: parent.appendChild(child)
             ex:var a=document.createElement("a");
                a.href="http://tmooc.cn";
                a.innerHTML="tmooc";
                document.body.appendChild(a);
             2.中间插入: parent.insertBefore(child,现有元素)
             3.替换: parent.replaceChild(child,现有元素)
       4.优化: 尽量减少操作DOM树，频繁修改DOM树，会导致频繁layout，降低页面响应速度。
         为什么: 只要修改DOM树，就会导致重排重绘,重排重绘非常复杂，且非常耗时
         网页加载过程:
             html -> DOM Tree
                     ↓
                   Render Tree->***Layout***->paint
                     ↑
             css -> CSS Rules
       5.解决修改DOM导致后果: 2种:
             1. 如果需要同时添加父元素和子元素时, 就要在内存中先将子元素添加到父元素，再将父元素整体一次性添加到DOM树
             2. 如果父元素已经在页面上，要添加多个平级子元素，就要借助文档片段（内存中临时保存多个子元素的虚拟父元素）
                   A.何时用文档片段: 要添加多个平级子元素
                   B.如何使用: 3步:
                       1. 创建文档片段:
                             var frag=document.createDocumentFragment();
                       2. 将平级子元素添加到frag中
                             frag.appendChild(elem);
                       3. 将frag整体添加到页面父元素下
                             parent.appendChild(frag);
                       说明: 将子元素添加到DOM树后，frag自动释放，不占用页面空间。
                       ex:<select name="provs">
                                 <option>—请选择—</option><!--0-->
                                 <option>北京市</option><!--1-->
                                 <option>天津市</option>
                                 <option>河北省</option>
                             </select>
                             <select name="cities" class="hide">
                             </select>
                            <script>
                             /*实现“省”和“市”的级联下拉列表*/
                             var cities=[
                                [{"name":'东城区',"value":101},
                                 {"name":'西城区',"value":102},
                                 {"name":'海淀区',"value":103},
                                 {"name":'朝阳区',"value":104}],
                                [{"name":'河东区',"value":201},
                                 {"name":'河西区',"value":202},
                                 {"name":'南开区',"value":203}],
                                [{"name":'石家庄市',"value":301},
                                 {"name":'廊坊市',"value":302},
                                 {"name":'保定市',"value":303},
                                 {"name":'唐山市',"value":304},
                                 {"name":'秦皇岛市',"value":305}]
                             ];
                             //操作4步：查找 绑定  查找  修改
                                var selProv=document.getElementsByName("provs")[0];
                                var selCts=document.getElementsByName("cities")[0];
                                selProv.onchange=function(){-----------复选框绑定事件
                                    var i=this.selectedIndex;
                                    if(i===0){
                                        selCts.className="hide";
                                    }else{
                                        selCts.className="";
                                        selCts.innerHTML="";
                                        var frag=document.createDocumentFragment();------创建虚拟父元素
                                        var opt=document.createElement("option");
                                        opt.innerHTML="-请选择-";
                                        frag.appendChild(opt);----------------子元素添加至虚拟父元素中
                                        var cts=cities[i-1];
                                        for(var c of cts){
                                            var opt=document.createElement("option");
                                            frag.appendChild(opt);
                                            opt.innerHTML= c.name;
                                            opt.value= c.value;
                                        }
                                    }
                                    selCts.appendChild(frag);-------------------将虚拟父元素挂至dom树上
                                }
                          </script>
     5.删除: parent.removeChild(child)
             child.parentNode.removeChild(child)
     6.HTML DOM常用对象:
         1.image: 指代页面上一个img元素
           创建: var img=new Image();
         2.select/option: 指代页面上一个<select>元素
             select:代表页面上<select>元素
               1.属性: sel.selectedIndex 获得当前选中项的下标位置*************
                       sel.value获得当前选中项的值(value)，如果当前option没有value，则用innerHTML代替，如果有value则显示value
                       sel.options 获得当前sel下所有option元素的**集合**
                         sel.options.length 选项的个数    sel.length =>sel.options.length选项的个数
                         sel.options.length=0  清除所有选项    sel.length=0 清除所有选项
               2.方法: sel.add(option) 向sel末尾追加一个option
                         强调: 不支持文档片段(fragment)
                       sel.remove(i)移除i位置的选项
               3.事件: sel.onchange  当选中项发生改变时触发*****************
                       Option: 指代页面上一个option元素
             option:代表<option>元素
               4.创建: var opt=new Option(text,value)-----简化了createElement，txt,value
               5.属性: opt.text代替opt.innerHTML
               ex:****************************简化借助文档片段(fragment)例子
               var selProv=document.getElementsByName("provs")[0];
                     var selCts=document.getElementsByName("cities")[0];
                     selProv.onchange=function(){-------------------当选中项发生改变时触发事件
                         var i=this.selectedIndex;
                         if(i===0){
                             selCts.className="hide";
                         }else{
                             selCts.className="";
                             selCts.innerHTML="";
                             var frag=document.createDocumentFragment();
                             frag.appendChild(new Option("-请选择-"));
                             var cts=cities[i-1];
                             for(var c of cts){
                                 frag.appendChild(new Option(c.name, c.value));
                             }
                         }
                         selCts.appendChild(frag);
                     }
         3.tabel: 指代一个table元素:
               1.管着行分组: 创建，删除，获得
                     A.创建:  var thead=table.createTHead();
                              var tbody=table.createTBody();
                              var tfoot=table.createTFoot();
                     B.删除: table.deleteTHead();
                             table.deleteTFoot();
                     C.获取: table.tHead
                             table.tBodies[i]
                             table.tFoot
                     D.行分组: tHead tBody tFoot
               2.管着tr:
                     A.创建:var tr=tXXX.insertRow(i);
                     B.说明: 如果i位置有行，则原位置的行向后顺移
                     C.常用操作: 1. 末尾追加一个新行: tXXX.insertRow();
                                 2. 开头插入: tXXX.insertRow(0)
                     D.删除:tXXX.deleteRow(i)删除当前行分组中下标为i的行
                     E.获取:tXXX.rows[i]
               3.行:管着td/th:
                     A.创建: tr.insertCell(i)
                     B.强调: insertCell只能创建td
                     C.删除: tr.deleteCell(i)
                     D.获取: tr.cells[i]
               4.删除行: 2种:
                 1. 行分组.deleteRow(i)
                    i 是行在行分组内的*****相对位置, 无法直接获得
                 2. table.deleteRow(i)
                    i 是行在整个表中的绝对位置，可直接获得:
                    tr.rowIndex 表示tr在整个表中的位置
                 3.总结: 今后凡是删除行: table.deleteRow(tr.rowIndex)******
                 ex:<style>---------------------------****重要案例：页面动态添加表格元素，且简化table中元素创建，添加操作
                    	table{width:600px; border-collapse:collapse;
                    		text-align:center;
                    	}
                    	td,th{border:1px solid #ccc}
                    </style>
                    </head>
                    <body>
                    	<div id="data"></div>
                      <script>
                    	var json=[
                        {"ename":"Tom", "salary":11000, "age":25},
                        {"ename":"John", "salary":13000, "age":28},
                        {"ename":"Mary", "salary":12000, "age":25}
                      ];
                    	//创建表头
                    	  var table=document.createElement("table");
                    	  var thead=table.createTHead();
                    	  var tr=thead.insertRow();
                    	  for(var key in json[0]){
                    		  tr.insertCell().innerHTML=key;
                    	  }
                    	  tr.insertCell().innerHTML="opr";
                    	  //创建tbody
                    	  var tbody=table.createTBody();
                    	  for(var emp of json){
                    		  var tr=tbody.insertRow();
                    		  for(var key in emp){
                    			  tr.insertCell().innerHTML=emp[key];
                    		  }
                    		var td=tr.insertCell();
                    		var btn=document.createElement("button");
                    		btn.innerHTML="×";
                    		btn.onclick=function(){
                    			var tr=this.parentNode.parentNode;
                    			var ename=tr.cells[0].innerHTML;
                    			if(confirm("是否继续删除"+ename+"？")){
                    				table.deleteRow(tr.rowIndex);
                    			}
                    		};
                    		td.appendChild(btn);
                    	  }
                    	document.getElementById("data").appendChild(table);
                      </script>
         4.form: 代表页面上一个form元素
               1.获取: var form=document.forms[i/id]
               2.属性: form.elements 包含所有表单元素: input select button textarea
                       form.elements.length 获得表单中表单元素的个数
                       form.length => form.elements.length
               3.方法: form.submit(); //手动提交表单---------JS表单验证例子
                   只有验证通过才提交: 2种:
                     1. input button 代替input submit
                        在input button的单击事件中自己调用form.submit();
                     2. input submit 配合 onsubmit事件
               4.表单元素:
                   1.获取: form.elements[i/id/name]
                     更简写: 如果表单元素有name属性，可直接:form.name
                   2.方法: elem.focus(); 让elem获得焦点
                           elem.blur(); 让elem失去焦点
         5.****表单上传文件：
               1.input标签中设置：
                     method="post "              post上传数据(2MB)
                     enctype="multipart/form-data" 将上传数据转二进制
                     <input type="file" name="myfile" />
               2.php文件：
                     $_FILES  保存上传文件所有信息
                     $_FILES["myfile"]["name"];      上传文件 kaola.jpg
                     $_FILES["myfile"]["tmp_name"]; 上传临时文件名称
                     $_FILES["myfile"]["type"];       上传文件类型 image/gif
                     $_FILES["myfile"]["size"];       上传文件大小
                     move_uploaded_file(临时文件,新文件)
               3.如果项目要求上传视频或者超过2M(apache允许上传大小2MB)，应该如何修改apache默认设置----150MB
                     技术经理-->修改apache默认配置  php.ini (授权)
                     (1)复制 php.ini -> php1.ini
                     (2)修改 php.ini
                         file_uploads=On                是否允许上传文件 On/Off
                         upload_tmp_dir="C:\xampp\tmp"  临时文件目录
                         upload_max_filesize=2M         最大上传文件150M
                         post_max_size=8M               post最大上传158M
                         max_execution_time=30          php最大执行时长900
                         max_input_time=900
                         memory_limit=256M              php最大使用内存量
                     (3)停止apache/重启apache php.ini 生效
     =============================================BOM========================================================================
     1. 什么是BOM: (Browser Object Model)专门操作浏览器窗口/软件的API
             问题：没有标准，兼容性极差
             1.window: 2个角色:
                 1. 代替ES中的global充当全局作用域对象
                 2. 封装所有dom和BOM的API
             2.window的功能: 打开和关闭窗口，弹出对话框...
             3.包括:
                 history: 保存当前窗口打开后，成功访问多的url的历史记录栈。
                 location:保存当前窗口正在打开的url的对象------location.search
                 document:封装页面内容和DOM API的根对象
                 navigator:保存浏览器的配置信息
                 screen:保存客户端显示设备的信息
                 event:定义事件对象
     2. 打开和关闭窗口:
           打开一个新窗口: /*window.*/open("url","name"),其中: name: 新窗口在内存中的名称,
           关闭窗口close()
           浏览器规定: 相同name的窗口只能开1个,后开的会替换先开的。
         1.预定义值: _self: 用当前窗口的name打开新窗口
                     结果: 新窗口替换当前窗口
                   _blank: 不指定name属性，让浏览器随机分配
                     结果: 每个窗口的name都不一样,就可打开多个
         2.打开一个超链接: 4种:
           1. 在当前窗口打开，可后退:
                 HTML: <a href="url" target="_self"></a>
                 js: open("url","_self")
                     ex:<script>
                             function open1(){
                                 open("http://tmooc.cn","_self");
                             }
                         </script>
                         <body>
                         <a href="http://tmooc.cn" target="_self">在当前窗口打开，可后退</a>
                         <a href="javascript:open1()">在当前窗口打开，可后退(js)</a>
                         </body>
           2. 在当前窗口打开，不可后退:----付款*****************
                 当前窗口每打开一个新url，都会将新url保存在history中。
                     如果新url是追加进history中，则可后退
                     如果新url将当前url替换掉，则无法后退
                         js:location.replace(新url)
                             ex:
                             <script>
                             function open2(){
                                             location.replace("http://tmooc.cn");
                                         }
                             </script>
                             <body>
                             <a href="javascript:open2()">在当前窗口打开，不可后退(js)</a>
                             </body>
           3. 在新窗口打开，可打开多个，不可后退:
                 HTML: <a href="url" target="_blank"></a>
                 js: open("url","_blank")
           4 . 在新窗口打开，只能打开一个，不可后退:----付款
                 原理：每个窗口，在内存中，都有唯一的name属性，浏览器规定，同一name属性的窗口，只能打开一个。
                 HTML: <a href="url" target="自定义name"></a>
                 js: open("url","自定义name")
                 内置name: _self 用当前窗口自己的name，打开新窗口
                           _blank 不指定name，浏览器会随机生成name
     3.BOM常用对象:
         1.history: 保存当前窗口打开后成功访问过的url的历史记录栈
             history.go(n) : history.go(0) 刷新
                             history.go(-1) 后退1步
                             history.go(1)前进1步
         2.location: 保存当前窗口正在打开的url对象
                属性:.href 获取或设置完整url
                    .protocol 协议
                    .host  主机名包含: 主机名+端口号
                    .hostname 仅主机名
                    .port端口号
                    .pathname 相对路径
                    .hash  获得锚点地址
                    .search 获得?后的查询字符串
        ***********鄙视: 将search=>对象，将search内容转为对象
                          "?username=zhangdong&pwd=123456"
                            ↓
                          var obj={
                            username:zhangdong,
                            pwd:123456
                          }
                          obj.username
                        ex:	<form>
                                 姓名:<input name="username"/><br>
                                 密码:<input type="password" name="pwd"/><br>
                               爱好:<input type="checkbox" name="favs" value="running"/>跑步
                                     <input type="checkbox" name="favs" value="swimming"/>游泳
                                     <input type="checkbox" name="favs" value="basketball"/>篮球
                                     <br>
                                 <input type="submit"/>
                             </form>
                             <script>
                               function search2obj(){____________________________鄙视：必须手写会
                                   var search=location.search.slice(1);
                                   var params=search.split("&");
                                   var obj={};
                                   for(var str of params){
                                       var arr=str.split("=");
                                       obj[arr[0]]=arr[1];
                                   }
                                   return obj;
                               }
                                 var p=search2obj();
                                 console.log(p);
                                 console.log(p.username, p.pwd);
                             </script>
                方法: location.assign("url") 在当前页面打开新url
                其实: =>location.href="url"=>location="url"在当前窗口打开，可后退
                     location.replace("url") 在当前窗口打开，替换history中当前url，实现禁止后退
                方法:
                   1. 在当前窗口打开，可后退:
                     location.assign("新url")
                        =>location.href="新url"
                        =>location="新url"
                   2. 在当前窗口打开，禁止后退:
                     location.replace("新url")
                   3. 重新加载/刷新: 2种:
                鄙视: 2种刷新:
                      1. 默认刷新:优先使用本地缓存中的文件，除非文件比服务器上的旧，才被迫下载新文件。
                        F5
                        history.go(0)
                        location.reload()-----------优先从缓存中获取
                      2. 强制刷新: 每次强制跳过浏览器本地缓存，总是从服务器下载新文件。***********
                        location.reload(true)---------------强制从服务器获取
        3.screen: 保存客户端显示设备的信息:
             window.outerHeight
             innerHeight------------楼层点亮
             innerWidth
             outerWidth-----判断窗口最小化指标-------判断响正在使用的设备
             鄙视: 判断屏幕宽
                 css: 媒体查询
             js: screen.width
        4.navigator: 保存了浏览器配置信息的对象
            1.cookieEnabled 判断是否启用cookie-----------------booling
                 cookie：在客户端本地硬盘，持久保存用户私密信息的小文件
                 为什么有cookie:程序中的数据都是临时保存在内存中，程序或计算机关闭，则内存中数据丢失
                 何时：只要希望在客户端持久记住用户的信息时
                 如何判断浏览器是否已经启用cookie:
                     if(navigator.cookieEnabled===true)
                 查看浏览器cookie:
                     设置>高级>内容设置>cookie
                 ex:	<script>
                    		if(navigator.cookieEnabled)
                    			document.write("已启用cookie，请妥善保管个人信息<br/>");
                    		else
                    			document.write("已禁用cookie，无法记住密码！");
                     </script>
            2.plugins 包含所有插件信息的集合-------------------------集合
                 插件：为浏览器添加新功能的小软件
                 如何判断浏览器是否安装了指定的插件：
                     navigator.plugins["插件名"]!==undefined 说明装了！
                     ex:		if(navigator.plugins["Shockwave Flash"]!=null){
                                 document.write("已安装Flash插件");
                             }else{
                                 document.write('未安装Flash插件，<a href="#">请点此安装</a>');
                             }
            3.userAgent 保存浏览器名称和版本号的字符串------------------字符串
                 何时：只要判断浏览器名称和版本号
                 如何：猜:navigator.userAgent;
                     ex:document.write(navigator.userAgent+"<br/>");_____________****鄙视：必须手写会
                        		var ua=navigator.userAgent,browser="",version="";
                        		if(ua.indexOf("MSIE")!==-1){
                        			browser="IE";
                        		}else if(ua.indexOf("Firefox")!==-1){
                        			browser="Firefox";
                        		}else if(ua.indexOf("OPR")!==-1){
                        			browser="OPR";
                        		}else if(ua.indexOf("Chrome")!==-1){
                        			browser="Chrome";
                        		}else if(ua.indexOf("Safari")!==-1){
                        			browser="Safari";
                        		}else if(ua.indexOf("Trident")!==-1){
                        			browser="IE";
                        			version="11";
                        		}
                        		if(browser!==""&&version===""){
                        			var i=ua.indexOf(browser)+browser.length+1;
                        			version=parseFloat(ua.slice(i,i+3));
                        		}
                        		document.write(browser+"<br/>"+version+"<br/>");
     4.定时器：2种:
        1.周期性定时器:-----------------------ex:JS做幻灯片定时器
            1.什么是: 让程序每隔一段时间间隔反复执行一次任务，循环是反复执行一个任务，而没有时间间隔
            2.何时: 让程序每隔一段时间间隔反复执行一次任务
            3.如何: 3件事:
                1. 任务函数: function 任务函数(){...}    让定时器反复调用的函数
                2. 启动定时器: var timer=setInterval(任务函数,间隔ms)
                    A.强调: 任务函数是回调，不用加()
                    B.其中: timer是定时器序号, 在内存中唯一标识一个定时器。
                3. 停止定时器: clearInterval(timer)
                    A.其中: timer是要停止的定时器序号,唯一标识一个定时器，专门用于停止一个定时器之用，只能在启动定时器时获取
                    B.问题: 停止定时器不会自动清除timer变量中的序号，有可能影响下次启动。--------------timer=null;
                    C.解决: 凡是停止定时器，都要手动清除timer
                    D.清除timer2种方式:
                       1. 手动停止: 用户通过操作来停止定时器
                       2. 自动停止:在任务函数中判断临界值,只要达到临界值，就自动停止定时器
                       ex://仿写进度条，h5表单新特性
                       <body>
                             <progress value="0.5" id="t1"></progress>
                       <script>
                              var t1=document.getElementById("t1");
                              var value=0.1;
                              var timer=setInterval(
                                  function(){
                                  value+=0.1;
                                  t1.value=value;
                                  if(value>0.9){
                                      clearInterval(timer);
                                      alert("下载完成！");
                                      }
                              } ,500);
                       </script>
                       </body>
        2.一次性定时器:------ex:JS做一次性定时器下部广告弹出.html-------------------------********异步操作
            1.什么是: 让程序先等待一段时间，再延迟执行一项任务。执行后，自动停止定时器
            2.何时: 先等待一段时间再自动执行一次,自动执行一次后，自动停止
            3.如何: 3件事:
               1. 任务函数:function task(){...}
               2. 启动定时器: var timer=setTimeout(task,等待ms)
               3. 停止定时器: 在任务执行前，就停止等待  clearTimeout(timer);timer=null;
            4.定时器原理:
               1.当启动任何定时器时, 创建定时器对象
               2.定时器对象，会按设定好的时间间隔，定时将任务加入到回调队列中
               3.回调队列中的任务，必须等待主程序执行完，才能进入ECS执行
            5.鄙视:
                 ex1:var a=10;
                     function fun(){ console.log(a=100); }
                     setTimeout(fun,0); //fun()
                     console.log(a);//10 //100
                 ex2:<span id="sc">5秒钟后自动关闭</span><br>
                 <a href="javascript:stop()">留在本页</a>
                 <script>
                 /*	  function task(){------------------一次性定时器
                 		  close();
                 	  }
                 	  var timer=setTimeout(task,5000);
                 	  function stop(){
                 		  clearTimeout(timer);
                 		  timer=null;
                 	  }*/
                 	  function task(){----------------------用周期性定时器最优，因为此操作为异步，周期性定时器可以同时控制
                 		  var n=parseInt(sc.innerHTML);
                 		  if(n>0){
                 			  n--;
                 			  sc.innerHTML=n+"秒钟后自动关闭";
                 		  }else{
                 			  close();
                 		  }
                 	  }
                 	  var timer=setInterval(task,1000);
                 	  function stop(){
                 		  clearInterval(timer);
                 		  timer=null;
                 	  }
                 </script>
                 ex3:for(var i=0;i<3;i++){
                     setTimeout(function(){
                         console.log(i);
                     },50)--------------时间长短不影响3个3同时输出
                    }//输出3个3
                 ex4:var a;
                    function fun(){
                    a=b=10;
                    }
                    setTimeout(fun,0);
                    console.log(a);//undefined
                    console.log(b);//b is not defined
     5.event:用户手动触发的或浏览器自己触发的页面状态的改变,当事件发生时，都可以执行事件处理函数来响应事件的操作。
         事件处理函数：当事件发生时，自动执行的回调函数
           1.绑定事件处理函数:3种:
               1. 在HTML中绑定:<ANY on事件名="fun()"
                   A.比如: <button onclick="fun()">
                   B.问题: 不符合内容与行为分离的原则，不便于维护
               2. 在js中绑定:（***********）
                    1. on事件名: elem.on事件名=function(){
                                   this->elem
                                 }
                         *局限: 一个事件，只能绑定一个处理函数
                    解决：2. addEventListener:可一个事件同时绑定多个处理函数
                             EventListener:包含元素，事件名，处理函数的对象
                             add是将事件监听对象，加入浏览器的事件列表之用
                                 elem.addEventListener("事件名(click)",fn);
               3.还可移除处理函数:
                    elem.removeEventListener("事件名",函数名)
                         A.问题: 绑定时如果使用匿名函数绑定，移除时无法找到原函数
                         B.解决: 如果一个处理函数可能被移除，就必须用有名的函数
                    ex:    <button id="btnShoot">shoot</button><br>
                           <button id="btnAward">获得跟踪导弹</button><br>
                           <button id="btnBreak">失去跟踪导弹</button><br>
                           <script>
                                function shoot2(){
                                    alert("发射跟踪导弹===>");
                                }
                                btnShoot.addEventListener("click",function(){
                                    console.log("发射普通子弹");
                                });
                                btnAward.addEventListener("click",function(){
                                    btnShoot.addEventListener("click",shoot2)
                                });
                                btnBreak.addEventListener("click",function(){
                                    btnShoot.removeEventListener("click",shoot2)
                                });
                           </script>
           2.事件模型/周期: ——事件冒泡3个阶段:*********事件的冒泡
                1. 捕获: 由外向内，记录各级父元素上绑定的事件处理函数——只记录，不触发
                2. 目标触发: 优先触发目标元素上的事件处理函数
                3. 冒泡: 由内向外，按捕获顺序的反向，依次执行父元素上的事件处理函数
                为什么：点在内层元素，等效于同时点在外层元素上
                解决：事件对象
           3.事件对象: 专门封装事件的信息，并提供操作事件的API（***********）---------IE8不支持
                何时: 要访问事件的信息，或要修改事件的行为
                如何:
                   创建: 不用手动创建, 总是作为处理函数的第一个参数传入
                     处理函数: function(e){
                       e=e||window.event; ----------------为兼容IE8中window.event
                     }
                   API:
                     1. 停止蔓延/取消冒泡:
                         if(typeof e.stopPropagation==="function")
                           e.stopPropagation();
                         else
                           e.cancelBubble=true;--------------兼容IE8中阻止冒泡：e.cancelBubble
                     ex:		<div id="d1">--------------阻止事件冒泡影响
                                 <div id="d2">
                                     <div id="d3">
                                     </div>
                                 </div>
                             </div>
                             <script>
                             d1.onclick=function(){
                                 alert(this.id);
                             };
                             d2.onclick=function(e){
                                 e=e||window.event;//----------------为了兼容IE8，要做判断
                                 if(typeof  e.stopPropagation==="function"){
                                     e.stopPropagation();
                                 }else{
                                     e.cancelBubble=true;
                                 }
                                 alert(this.id);
                             };
                             d3.onclick=function(e){
                                 e=e||window.event;
                                 if(typeof  e.stopPropagation==="function"){
                                     e.stopPropagation();
                                 }else{
                                     e.cancelBubble=true;
                                 }
                                 alert(this.id);
                             };
                             </script>
                     2.利用冒泡:
                         优化: 尽量减少事件监听个数
                         为什么: 浏览器触发事件处理函数，是通过遍历的方式，查找触发事件的元素和处理函数对象,如果事件监听多，则遍历慢
                         何时: 多个平级子元素响应相同的事件时
                         如何: 只要在父元素上绑定一次处理函数即可，所有子元素共用。
                         2大难题:
                            1. 获得实际出发事件的目标元素:
                                错误: this->父元素
                                正确:  e.target||e.srcElement(IE8)
                                ex:计算器
                                <div id="keys">
                                			<button>1</button>
                                			<button>2</button>
                                			<button>3</button>
                                			<button>4</button><br>
                                			<button>C</button>
                                			<button>+</button>
                                			<button>-</button>
                                			<button>=</button>
                                		</div>
                                		<textarea id="sc" style="resize:none;width:200px; height:50px;" readonly></textarea>
                                    <script>
                                			keys.onclick=function(e){
                                				e=e||window.event;
                                				var btn=e.target|| e.srcElement;
                                				if(btn.nodeName==="BUTTON"){
                                					//判断btn的内容
                                					switch(btn.innerHTML){
                                						//是C
                                						case "C":
                                							//清空sc的内容
                                							sc.value="";
                                							break;
                                						//是=
                                						case "=":
                                							//尝试
                                							try{
                                								/*e.preventDefault();*/
                                								sc.value=eval(sc.value);
                                								/*break;*/
                                								//将sc的内容放入eval()中,将计算结果放回sc的内容中
                                							}catch (err){
                                							//一旦出错
                                								sc.value=err;
                                								//将错误对象err赋值给sc的内容
                                							}
                                							break;
                                						default :
                                							sc.value+=btn.innerHTML;
                                						//其余
                                							//将btn的内容追加到sc的内容中
                                					}
                                				}
                                			}
                                	</script>
                            2. 鉴别目标元素是否想要的:
                                nodeName   .className
                            3.另一个作用: 如果一个父元素下的子元素，需要动态生成，并绑定事件。
                                          则必须将事件绑定在父元素。动态生成的子元素，才能自动使用父元素的事件，而不需要反复单独绑定。
                            4.阻止事件默认行为:*******
                                 何时: 如果浏览器事件的默认行为不是想要的
                                 包括: 3种:
                                     1. 用a元素作为按钮时，会自动在url添加锚点地址
                                     2. 自定义表单提交: 2种搭配---------ex:JS表单验证-input-type-button/submit例子
                                          input button   btn.onclick       form.submit()
                                          input submit   form.onsubmit    e.preventDefault();
                                     3. HTML5中拖拽API: 一开始都要阻止默认行为
                                         如何:
                                         e.preventDefault();
                                         return false;//IE8
                                 ex:	<div id="toTop">
                                    		<a href="#">返回顶部</a>
                                    	</div>
                                      <script>
                                        window.onscroll=function(){
                                            var scrollTop=document.documentElement.scrollTop||document.body.scrollTop;
                                            if(scrollTop>=500){
                                                toTop.style.display="block";
                                            }else{
                                                toTop.style.display="none";
                                            }
                                            document.querySelector("#toTop>a").onclick=function(e){
                                                e=e||window.event;
                                                window.scrollTo(0,0);
                                                if(e.preventDefault!==undefined){
                                                    e.preventDefault();
                                                }else{
                                                    return false;
                                                }
                                            }
                                        }
                                    	</script>
           4.HTML5中拖拽API
                 1.鼠标坐标
                       包括: 3组:
                        1. 相对于显示设备左上角:  e.screenX  e.screenY
                        2. 相对于文档显示区左上角:  e.clientX  e.clientY
                        3. 相对于元素左上角:  e.offsetX   e.offsetY
                 2.页面滚动
                       1.滚动事件:----------------ex:鼠标拖动事件例子
                            window.onscroll=function(){
                              var scrollTop=//页面顶部超出文档显示区顶部的距离
                                document.documentElement.scrollTop
                                ||document.body.scrollTop
                            }
                       2.主动跳转: 2种:
                            1. 滚动到指定位置:
                              window.scrollTo(left, top)
                            2. 滚动过一段距离:
                              window.scrollBy(left的增量, top的增量)
     6.绑定键盘事件：（***********）
         document.onkeydown=function(e){
               switch(e.keyCode){
                 case 37: //左
                   this.moveLeft();
                   break;
                 case 39: //右
                   this.moveRight();
                   break;
                 case 40: //下
                   this.moveDown();
                   break;
               }
             }.bind(this);//用start中正确的this代替事件处理函数中不想要的this
           }
     7.window.onload();------------------一段代码依赖于css样式时，用onload可以保证页面html和css加载完再执行js
     =============================================jquery==============================================================
     1. 什么是jQuery:
          第三方开发的，执行DOM操作的，极简化的，函数库
          第三方: 下载，才能用
          执行DOM操作: 增删改查，事件绑定
          极简化: jQuery是DOM操作的终极简化
               4大方面内容:
                1. 增删改查:
                2. 事件绑定:
                3. 动画:
                4.  ajax:
          函数库: jQuery中一切都是用函数来解决问题
          为什么: 2个原因:
               1. DOM操作的终极简化:
               2. 解决了大部分浏览器兼容性问题:
                 凡是jQuery让用的，都没有兼容性问题:
     2. 如何使用:
          1. 下载: 版本:
               1.x 兼容旧浏览器
                    1.x.js 未压缩版本: 具有完整的注释，代码格式，有意义的变量名
                      优: 可读性好，便于学习和理解原理
                      缺: 文件大，传输慢
                      何时: 在学习和开发时
                    1.x.min.js 压缩版本: 去掉所有注释，去掉所有代码格式，极简化变量名
                      优: 体积小，传输快
                      缺: 可读性差
                      何时: 生产环境
               2.x 不再兼容旧浏览器
               3.x 也不再兼容旧浏览器，增加了新特点:
                     1. 所有jQuery 3.x代码都运行在严格模式下: Strict Mode
                     2. 用for...of 代替了 each
                     3. requestAnimationFrame()
                     4. 兼容Promise
          2. 将jQuery文件引入网页中:
               1.引入jquery.js  ——<script src="jquery-1.11.3.js"></script>
               	        或者用jquery官网的CDN文件
               	   2.注意:
               			 #顺序:必须在自定义script之前,先入jqueryjs
               			 #加载jquery库script中间不要加入任何代码
               		     #不要使用自封闭标签
               			   <script src="jquery-1.11.3.js" /> error
               2. 引入CDN网络中的jQuery.js文件:
                CDN: 内容分发网络: 可根据每个客户端距不同服务器的网络状况，选择最优的服务器下载资源
          3. jQuery的原理:
               引入jQuery.js: 向全局添加了一种新的类型jQuery
               包括:
                 构造函数: 创建jQuery类型的子对象
                 原型对象: 保存所有jQuery类型的子对象共用的API
               如果要使用jQuery简化版Api, 必须先创建jQuery类型的子对象。
               如何: 2种重载:
                    1. 用选择器查找DOM，并封装进jQuery对象:
                         var jQuery对象=jQuery("选择器")
                         jQuery对象.简化版API()
                         说明:
                              1. 不用new: jQuery将new封装在函数内
                              2. jQuery先用选择器找到DOM元素，然后，再创建jQuery对象，将找到的DOM元素放入jQuery对象中
                                   为什么: DOM元素不是jQuery类型的子对象，无法使用jQuery简化版API。
                                   何时: 只要想用简化版API，必须将DOM元素封装到jQuery对象中
                              3. 什么是jQuery对象: 可保存多个找到的DOM元素的类数组对象
                         简写:
                              1. window.$=jQuery， 使用$，等效于使用jQuery
                                 将来创建jQuery类型的子对象: $("选择器")
                              2. jQuery.fn=jQuery.prototype, 使用fn，代替prototype
                                 将来为jQuery类型添加自定义API:
                                 jQuery.fn.函数名=function(){ ... }
                                 ex:console.log(jQuery);
                                    console.log($==jQuery);//true
                                    console.log(jQuery.prototype);
                                    console.log(jQuery.fn==jQuery.prototype);//true
                   2. 如果已经提前获得一个DOM元素, 可直接用:
                         $(DOM元素)
          4. jQuery API: 三大特点:
               1. 自带遍历效果: 对jQuery类数组对象调用一次简化版API，等效于对集合中每个DOM元素分别调用一次API
               2. 一个API两用: 没给新值，默认获取旧属性值
                               给了新值，默认修改属性
               3.每个API都返回正在操作的jQuery对象:链式操作!
          4.jquery对象转化成Dom对象
               a:var dom对象 = $jquery对象.get(0);
               b:var dom对象 = $jquery对象[0];
          5.鄙视题: DOM对象 vs jq对象
               1.DOM对象:由W3C的DOM标准规定,浏览器厂商负责实现的现成对象.
                 使用DOM API--万能..繁琐
               2.JQ对象:由第三方JQUERY.JS库定义.并提供简化操作DOM的API，类数组对象
                 使用JQUERY API->简化，解决浏览器兼容问题
               3.两套API无法通用!
     3.jquery 选择器：今后都是先找元素，再调用jqueryAPI操作元素;
     	            只要用jquery找元素,都用选择器!
     				用jquery查找元素，返回直接就是jquery对象.无需再封装.
         1.查找：
       	   1.如何: var $jq对象 = $("选择器");
     	   2.区别 jquery对象<-->dom对象
     				var $obj;  //提示当前对象jquery对象
     				var obj;
            3.基本选择器: 5个 #id .class elem * 选择器1,选择器2,
     	   4.层级选择器: 4个 选择器1  选择器2 > + ~
            5.过滤选择器:通过特定过滤规则筛选出所需元素
                 1.包含:1.基本过滤选择器(位置过滤),
                        2.内容过滤选择器
                        3.可见性过滤选择器
                        4.属性过滤选择器
                        5.子元素过滤选择器
                        6.表单过滤选择器
                 2.基本过滤选择器:位置过滤.根据元素查找结果的位置来选择.(basic filter)
                     1.何时:只要选择特定位置的元素时,都用基本过滤选择器.
                         :first  选择查询结果中排在第一个位置的元素.
                                 不考滤元素在父元素位置,仅考在jquery对象中下标位置
                         :last   选择查找结果中排在最后位置一个元素
                         :even/odd 选择器查找结果排偶数/奇数位置元素.下标从0开始
                             ex:查找处于偶数位置的li
                                $("li:even").css("border3","2px solid red");
                         :eq(i)   选择查询结果中的一个元素,i下标,从0开始
                                 jquery查找元素:规则深度优先.
                             ex:查找第2个li
                                $("li:eq(2)").css("border","2px solid red");
                         :gt(i)   选择查找结果中i位置之后的所有元素,不包含i位置元素
                             ex:查找第3个之后li
                                $("li:gt(3)").css("border","2px solid red");
                         :lt(i)   选择查找结果中i位置之前的所有元素，不包含i位置元素
                             ex:查找第3个之后li
                                $("li:lt(3)").css("border","2px solid red");
                 3.内容过滤选择器:根据内容查找元素——包括4个:
                     :contains(text) 查找内容中包含指定文本的元素
                         比如:span:contains('购物车')
                         ex:选择包含"提交"二字的按钮，变为绿色按钮
                            $("button:contains(提交)").addClass("btn-success");
                     :emtpy    查找内容为空的元素
                         比如:span:emtpy
                     :parent   选择包含内容或子元素的父元素
                         比如:span:parent  其实就是 :empty反义
                     :has(selector) 选择内容中包含符合选择器要求
                         ex:选中包含.close按钮的.alert元素，让它们变为红色的警告框
                             $(".alert:has(.close)").addClass("alert-danger");
                         选中不包含.close按钮的.alert元素，让它们变为绿色的警告框
                             $(".alert:not(:has(.close))").addClass("alert-success");
                 4.可见性过滤选择器 2个
                     :visible  匹配所有可见的元素
                     :hidden   匹配所有不可见的元素-----------------只可以匹配display:none和type=hidden
                 **html+css中***隐藏***的几种方法：
                          1.css: display:none
                                 visiblity:hidden;
                                 opacity:0
                          2.html:type="hidden"
                     ex:<style>
                        		.dropdown{width:64px; height:20px;}
                            .dropdown a{
                        			text-decoration:none;
                        			color:#000;
                        			display:inline-block;
                        		}
                        		.dropdown>a{
                        			border:1px solid #000; padding:6px 12px;
                        		}
                        		.dropdown-menu{
                        			width:200px;
                        			height:0;
                        			overflow: hidden;
                        			list-style:none; margin:0; padding:0;
                        			/*border:1px solid #aaa;*/
                        			border:0;
                        			box-shadow:5px 5px 6px #000;
                        			/*display: none;*/
                        		}
                        		.dropdown-menu a{padding:6px 20px; width:160px}
                        		.dropdown-menu li:hover{background:#ddd}
                          </style>
                        <div class="dropdown">
                          <a data-trigger="dropdown" href="#">Dropdown</a>
                          <ul class="dropdown-menu">
                      	    <li><a href="#">Action</a></li>
                             <li><a href="#">Another action</a></li>
                             <li><a href="#">Something else here</a></li>
                      	    <li><hr></li>
                             <li><a href="#">Separated link</a></li>
                          </ul>
                        </div>
                      	<script src="js/jquery-1.11.3.js"></script>
                      	<script>
                      		//先实现单击按钮下拉
                      	$("[data-trigger=dropdown]").click(function(){
                      		var $next=$(this).next();
                      		$next.is(":hidden")?$next.show():$next.hide();------------判断元素是否处于某种状态或满足某种条件
                      	});
                 5.属性过滤选择器：优：将任意属性作为查找条件!支持模糊查找!
                       1.包含:
                             [属性名]    选择包含指定属性元素
                                 例   div[id]
                                 ex:选取包含title属性的div
                                     $("#btn3").click(function(){$("div[title]").css("border","2px solid red");});
                             [属性名=值] 选择包含指定属性,并且属性值精确等于"值"的元素
                                 例   [id=btn]
                                 ex:选取title属性等于test的div
                                     $("#btn4").click(function(){$("div[title=test]").css("border","2px solid red");});
                             [属性名!=值] 选择包含指定属性,并且值不等于"值"的元素
                                 ex:选取title属性不等于test的div
                                     $("#btn5").click(function(){$("div[title!=test]").css("border","2px solid red");});
                       2.模糊查找:
                             [属性名^=值] 选择包含指定属性,并且属性值以"值"开头的元素
                                 例   [class^=b]
                                 ex:选取title属性以te开头的div
                                     $("#btn1").click(function(){$("div[title^=te]").css("border","2px solid red");});
                             [属性名$=值] 选择包含指定属性，并且属性值以"值"结尾的元素
                                 ex:选取title属性以est结尾的div
                                     $("#btn2").click(function(){$("div[title$=est]").css("border","2px solid red");});
                             [属性名*=值] 选择包含指定属性，并且属性值中包含"值"的元素
                                 ex:选取title属性包含es的div
                                     $("#btn6").click(function(){$("div[title*=es]").css("border","2px solid red");});
                             [属性选择器1][属性选择器2]    而且，复杂属性过滤,多条件查询，选择同时满足多个条件
                                 ex:选取包含id属性且title属性值包含es的div
                                     $("#btn7").click(function(){
                                        $("div[id][title*=es]").css("border","2px solid red");
                                     });
                       3.注意一:
                             属性值添加单引号不加(均可)
                             建议加上''
                 6.子元素过滤选择器(child filter)
                      选择作为(父)元素下指定位置子元素
                          :first-child    :first
                          :last-child     :last
                          :nth-child(n/2n/2n+1)   # n从1开始
                          :only-child
                          注意:vs 基本过滤选择器(位置)下标从0开始
                              ex:查找每个ul中处于偶数位置的
                                 $("ul>li:nth-child(2n)").css("border","1px solid red");
                                 查找作为ul下唯一子元素的li
                                 $("ul>li:only-child").css("border","1px solid red");
                 7.表单元素过滤选择器:根据表单元素的标签名和type属性来选择表单中的元素
                      1.包含:——2种
                          :input 选所有input/textarea/select/button/textarea
                          :type类型:选择指定type类型表单元素
                      2.type类型:——10种
                             :text文本
                             :password密码
                             :radio单选框
                             :checkbox复选框
                             :submit
                             :reset
                             :button
                             :image
                             :file（文本、文件）
                             :hidden
                             其实是:[type='xxx']简化写法
                      3.表单属性过滤选择器是:
                         :disabled   禁用
                         :enabled    可用
                         :checked    选中
                         :selected   选中(下拉菜单)
                      4.#小心
                         <input type="button"/>
                         <button></button>
                         少用:在表单自带功能<==>submit
                      5.访问标准属性：
                               获取: $("..").attr("标准属性名")
                               修改: $("..").attr("标准属性名",值);
                      6.不能访问三大状态属性：selected/checked/disabled
                               获取:$("..").prop("属性名");
                               修改:$("..").prop("属性名",值);
     4.
                 8.查找元素(父元素/下一个兄弟),判断选择器
                   .is("选择器")
                   .parent();
                   .next();
                 9.按节点间关系查找
                   	  1.遍历节点
                   			1.父子关系
                   				$("...").children(["selector"]);  仅在直接(子)元素中查询
                   				$("..").find("selector");  在所有(后代)元素中查询符合选择器元素
                   				$("..").parent();  查询父元素
                   				$("..").parents(["selector"]);  查找祖先元素
                   			2.兄弟关系
                   				$("..").next()/prev(["selector"]);  要求必须紧邻的前/后一个兄弟
                   				$("..").nextAll()/prevAll(["selector"]);  前面所有或者后面所有的兄弟
                   				$("..").siblings(["selector"]);  除自己之外的前后所有兄弟元素
                   			3.强调:jquery多数简化API自带forEach功能:
                                   $("selector").css("css属性名","值");——相当于对找到的每个元素都css操作
                                   $("selector").事件名(function(){....});——相当于对找到的每个元素都绑定事件.
                               ex:<style>---------------使用属性选择器实现标签页头的切换
                                      .tabs{ list-style:none; padding:0 }
                                      .tabs a{
                                        text-decoration:none;
                                  			color:#000;
                                  			padding:6px 12px;
                                  			display:inline-block;
                                      }
                                      .tabs>li{
                                        float:left;
                                        border-bottom:1px solid #000;
                                      }
                                      .tabs>.active{
                                        border:1px solid #000;
                                        border-bottom:0;
                                      }
                                   </style>
                                   </head>
                                   <body>
                                  		<ul class="tabs">
                                  			<li class="active"><a data-toggle="tab" href="#">十元套餐</a></li>
                                  			<li><a data-toggle="tab" href="#">二十元套餐</a></li>
                                  			<li><a data-toggle="tab" href="#">三十元套餐</a></li>
                                  		</ul>
                                   <script src="js/jquery-1.11.3.js"></script>
                                   <script>
                                      $(".tabs>li>[data-toggle=tab]").click(function(){
                                          $(this).parent().addClass("active")
                                              .siblings().removeClass("active")
                                      });
                                   </script>
         2.修改
             1.html内容
                 获取:$("...").html()                 DOM:elem.innerHTML
                 修改:$("...").html("html代码片段")        elem.innerHTML = "html代码片段"
                 清空:$("..").empty();
                      $("..").html("");
             2.文本内容
                 获取 $("..").text();                 DOM:elem.textContent;
                 修改 $("..").text([新文本内容])                 elem.textContent= "文本";
             3.表单元素内容
                 <input type="text" value="" />
                 获取元素内容 $("..").val();           DOM:input.value;
                 修改元素内容 $("..").val([新值]);             input.value = 值
             4.属性
                 1.获取  $("..").attr("属性名");         DOM:elem.getAttribute("属性名");
                 2.修改  $("..").attr("属性名",值);        elem.setAttribute("属性名","值 ");
                 3.删除  $("..").removeAttr("属性名");     elem.removeAttribute("属性名");
                 4.访问状态属性
                     $("..").prop("状态属性名");
                     $("..").prop("状态属性名",值);
     	3.添加/移除class：
     			$("..").addClass("类名");  将指定类名(追加)到选中的元素之上
     			$("..").removeClass("类名");  将指定类名从选中的元素上移除
     			$("..").hasClass("类名");  判断选中元素中是否包含指定类名 true false
     			$("..").toggleClass(类名);  有类名就移除，否则就添加
                     ex:双态按钮: 让按钮的class在up和down之间切换
                        <button class="btn up">双态按钮</button>
                        <script src="js/jquery-1.11.3.js"></script>
                        <script>
                          $("button").click(function(){
                            var $btn=$(this);
                            /*if($btn.hasClass("down")){-----------------做法一：判断，移除，添加
                              $btn.removeClass("down")
                            }else{
                              $btn.addClass("down")
                            }*/
                            $btn.toggleClass("down");-----------------做法二：直接切换class
                          });
         4.Dom元素创建.添加
     			1.DOM添加新节点3步:
     				 1:创建空元素
     				 2:设置关键属性
     				 3:将新元素添加到父元素最后子节点
     			2.JQ创建元素2步
     				 1:用html代码片段创建元素对象[jq对象]
     				   var $elem = $("html页面要显示的代码片段");——仅在内存中
     					 说明:如果html代码片段同时包含父元素和子元素,$会同时创建父元素以及子元素对象.
     				 2:将新元素添加指定父元素下
     				     $(parent).append($elem);在末尾追加---------return parent
     				        $新元素.appendTo(parent)在末尾追加------return 新元素，后续可以持续修改新元素，方便链式操作
     			         $(parent).prepend($elem);在开头追加---------return parent
     			            $新元素.preppendTo(parent)在末尾追加------return 新元素
     					 $(child).before($elem); 在child之前插入
     					 $(child).after($elem);  在child之后插入
         5.删除节点
              1.$(node).remove();删除节点
     	6.替换. 复制
              1.替换
                   1.用后边，替换前边
                     $("旧的").replaceWith("新元素");
                   2.用前边，替换后边
                     $("新元素").replaceAll("旧的");
              2.复制/克隆
                   1.浅克隆，只复制属性(id/class/)，不复制行为(click/mouseover/...)
                     var $clone = $("..").clone();
                   2.深克隆,不但复制属性，而且复制行为
                     var $clone = $("..").clone(true);
                  ex:<div>
                         <img src="img/p0.png">
                     </div>
                     <hr/>
                     <div id="list">
                       <img src="img/p3.png">
                       <img src="img/p4.png">
                       <img src="img/p5.png">
                     </div>
                     <script src="js/jquery-1.11.3.js"></script>
                     <script>
                       $("#list>img").click(function(){
                         $(this).clone().replaceAll("#chosen>img");
                       });
                     </script>
                  ex:<style>-----------------实现左侧option双击添加到右边div,右边双击可删除效果
                          select { width: 120px; height: 160px}
                     </style>
                     </head>
                     <body>
                     <select id="unsel" size="10" multiple>
                            <option value="Arg">Argentina</option>
                            <option value="Bra">Brazil</option>
                            <option value="Can">Canada</option>
                            <option value="Chi">China</option>
                            <option value="Cub">Cuba</option>
                            <option value="Den">Denmark</option>
                            <option value="Egy">Egypt</option>
                            <option value="Fra">France</option>
                            <option value="Gre">Greece</option>
                            <option value="Spa">Spain</option>
                     </select>
                     <select id="sel" size="10">
                     </select>
                     <script src="js/jquery-1.11.3.js"></script>
                     <script>
                           $("#unsel>option").dblclick(function(){
                                  var $sel=$("#sel");
                                  if($(this).parent().is("#unsel")){
                                      if(!$sel.is(":contains("+$(this).html()+")"))
                                          $(this).clone(true).appendTo($sel);
                                  }else{
                                      $(this).remove();
                                  }
     
                              });
                     </script>
         7.(Dom中)获取样式:直接访问css样式属性
         	     1.访问元素的css样式,读取选中元素css属性
                           	  $("selector").css("css属性名");
                  2.修改/添加选中元素css属性
                       $("selector").css("css属性名","值");
                       $("selector").css("borderRight","none");
                  3.多次使用css方法
                       1:jquery支持链式写法
                             $("#btn1").css("","").css("","").css("","");
                       2:jquery{}
                             $("#btn1").css({
                                       属性名:值,
                                       属性名:值,
                             });
          	     4.获取计算后的样式：
          	        getComputedStyle(elem).css属性名
         		 问题:不便于大项目维护
         		 解决:大型项目中都要操作css来代替换单个样式.
     4.jquery 事件处理---* 重点&难点——————————————————绑定
     	  	1.常用绑定：
     			  $("..").bind("事件名",fn);         绑定
     			  $("..").unbind("事件名",函数名);   解除绑定
     			  $("..").unbind();      移动该元素上所有事件绑定
     		2.一次性绑定
     		  	  $("..").one("事件名",fn);  绑定事件，仅触发一次后自动退出绑定
     		  	  ex:<button id="btn1">发射子弹</button>---------------飞机炸弹
                          <button id="btn2">获得奖励</button>
                      	<button id="btn3">失去奖励</button>
                      	<script src="js/jquery-1.11.3.js"></script>
                      	<script>
                      		$("#btn1").bind("click",function(){
                                console.log("发射子弹");
                              }).bind("mouseover",function(){
                                $(this).css("background","yellow");
                              }).bind("mouseout",function(){
                                $(this).css("background","");
                              });
                              function shoot2(){
                                alert("发射跟踪导弹...");
                              }
                              $("#btn2").bind("click",function(){
                                $("#btn1").one("click",shoot2)
                              });
                              $("#btn3").bind("click",function(){
                                $("#btn1").unbind("click",shoot2);
                              });
                      	</script>
     		3.常用事件绑定:简化版   $("..").事件名(fn);   只对部分事件提供简化-->23个
     	    4.delegate：
     	    ***以上绑定方法,只能对当前页面上己存在的元素添加事件绑定，动态生成元素无法自动绑定事件.
     	        其实就是利用冒泡的简化版：
                 1. 将this->目标元素, 不需要e.target
                 2. 将判断条件提升为第一个参数，处理函数内省略if
                 3.鄙视题:delegate vs bind
                     1:事件监听个数:
                       delegate是仅在父元素添加一次事件监听
                       bind通常都是是每个子元素都添加事件监听
                     2:对动态添加的元素
                       delegate让动态添加元素自动响应事件
                       bind通常仅对现有元素添加绑定,无法自动给动态生成元素添加绑定
     			  **解决1:利用冒泡:将事件绑定己存在父元素一次
     							function(e){
     							  var  target = e.target;
     								//target 触发事件:元素
     							}
     			  **解决2:事件代理:
     				   			$("parent").delegate("判断条件","事件名",fn);
     			  					fn-->this--->代替 e.target
     			  				ex:$(".container").bind("click",function(e){
                                    		e=e|| e.event;
                                    		var $tar=$(e.target|| e.srcElement);
                                    		if($tar.is(".block>.close")){
                                    			$tar.parent().remove();
                                    		}
                                    	});-------------------未简化版
                                    	$(".container").delegate(".block>.close","click",function(){
                                    			$(this).parent().remove();
                                    		});------------------delegate简化版：this可以直接指代当前点击元素
     							**解除
     							$("parent").undelegate("subselector","事件名");
     			  **如果要阻止a或者其他元素默认事件要用e.preventDefault();
     		5.简化**************
     		   .on/off: 统一了bind和delegate
                普通绑定: .on("事件名",function(){ ... })--------------------on的底层原理是bind
                利用冒泡: .on("事件名","选择器",function(){ ... })
     		7.己废弃:
     			 $("select").live("事件名",fn);
     			 $("selector").die("事件名");
     		8.模拟操作:用代码模拟触发另一个元素的事件
     			何时:如果少量平级元素拥有相同的事件处理函数,不必利用冒泡，就模拟触发.
     		    如何:$("..").trigger("事件名");————触发所有选中元素上的指定事件处理函数
     		    ex:<h1>与服务器进行通信的三步</h1>
                    <button id="bt0">连接到服务器</button>
                    <button id="bt1">给服务器发消息</button>
                    <button id="bt2">断开与服务器的链接</button>
                    <hr/>
                    <button id="bt99">一次性触发“连接-发消息-断开”三个处理函数</button>
                    <script src="js/jquery-1.11.3.js"></script>
                    <script>
                      $('#bt0').click(e=>
                        console.log('开始连接服务器....')
                      )
                      $('#bt1').click(e=>
                        console.log('开始向服务器发消息....')
                      )
                      $('#bt2').click(e=>
                        console.log('断开到服务器的连接....')
                      )
     
                      $('#bt99').click(function(){
                        //使用JS顺序模拟触发前三个按钮的单击事件即可
                        $("#bt0").trigger("click");
                        $("#bt1").click();
                        $("#bt2").click();
                      })
                    </script>
             9.鼠标触发事件：
                 mouseover   mouseout-----dom操作
                 mouseenter  mouseleave----jquery操作
                 回车事件：keyup
                 ex:$("#product-high").keyup(function(e){
                        var key=$("#product-kw").val();
                        var low=$("#product-low").val();
                        var high=$(this).val();
                        if(e.keyCode==13){-----------enter键值
                            loadProductSearch(1,8,low,high,key);
                        }
                    });
             简写: 如果同时绑定enter和leave
                 .hover(
                   function(){ ... }, //mouseenter
                   function(){ ... } //mouseleave
                 )
             更简化: 如果enter和leave的处理函数，可统一为一个
                 .hover(function(){ ... })
                 ex: <style>------------使用hover(fn,fn),鼠标悬停在div上方，则突出显示；移出则取消突出显示
                             #target {
                                 border: 1px solid #eee;
                                 border-radius: 6px;
                                 padding: 10px;
                                 transition: all .5s linear;
                             }
                             #target.hover {
                                 border: 1px solid #aaa;
                                 box-shadow: 0 0 6px #aaa;
                                 background: red;
                                 color:#dddddd;
                             }
                      </style>
                      </head>
                      <body>
                         <div id="target">
                             <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Eligendi neque quae voluptatum ducimus culpa itaque maxime distinctio soluta cum cupiditate esse tenetur deserunt fuga perferendis sed veritatis asperiores. Numquam officia.</p>
                         </div>
                         <script src="js/jquery-1.11.3.js"></script>
                         <script>
                             /*$("#target").mouseenter(
                                 function(){
                                     $(this).addClass("hover")//$(this).toggleClass("hover")
                                 },
                                 function(){
                                     $(this).removeClass("hover")//$(this).toggleClass("hover")
                                 }
                             )*/-------------------------------------未简化版写法
                             $("#target").hover(
                                 function(){
                                     $(this).toggleClass("hover")
                                 }
                             )
                         </script>
                         11.鄙视题:jquery有几种事件绑定方式
                                 DOM:addEvenetlistener("事件名",fn);
                                     removeEvenetListener("事件名",函数名);
                                     强调:要想移除事件监听，必须使用有名函数；
                                          绑定事件监听，如果添加事件时使用匿名函数，则不可能移除.
     12.jquery 事件(加载)页面加载后执行2种:
     	 1.整个页面(html, css, js, 图片)加载后执行: 红线
              window.onload=function(){
                   //必须依赖css和图片的代码
                  }
          2. DOM内容(html,js)加载完成: 蓝线
              DOMContentLoaded
                 //$(document).ready(function(){
              //$().ready(function(){
              $(function(){
                //不依赖css和图片的代码: 比如事件绑定
              })
          说明: 几乎所有jQuery代码，都写在$(funtion(){ ... })
                $(function(){ ... }) 采用bind方式添加处理函数
          所以: 可绑定多个处理函数
     *****鄙视: jQuery中$函数的原理: 4种重载****************
                查找：
                封装：dom元素封装成jquery元素
                创建新元素
                事件绑定
     13.jquery动画:jquery中通过动画函数实现动画效果--高级函数
         1.问题: 1. 无法修改效果，不便于维护
                 2. 用js程序的定时器实现的——效率不如css的
     	2.简单动画：效果固定的一组动画API
     	   1.显示隐藏
     		   $("..").show()  显示
     		   $("..").hide()  隐藏
     		   $("..").toggle() 切换{显示/隐藏}
            没有参数时: 代替的是display:block/none ——推荐
            加了ms参数: 则有动画效果
            添加参数:速度
                默认三档:slow  normal fast
                自动定义毫秒数: 3000
                    $(""),show/hide/toggle(1000,fun);
     	   2.上下滑动
     		   $("...").slideUp();  隐藏
     		   $("...").slideDown();显示
     		   $("...").slideToggle();
     	   3.淡入淡出
     		   $("...").fadeIn();
     		   $("...").fadeOut();
     		   $("...").fadeToggle();
     	3.万能动画:可对多种css属性，自由改动
              $(...).animate({
                css属性: 目标值,
                  ... : ...
              }, ms,callback函数);
         **回调函数，动画结束后自动执行:
                   每个动画API都有最后一个回调函数参数
                   回调函数会在动画播放后，自动执行
                   回调函数中的this->正在播放动画的DOM元素
         **强调: animate只支持单个数值的属性
                 其中css属性仅对(数值)属性有效：left width height
                 不支持颜色动画
                ex:<style>
                       img { position: relative; }
                   </style>
                   </head>
                   <body>
                       <img id="s1" src="img/star.png"><br/>
                       <img id="s2" src="img/star.png"><br/>
                       <img id="s3" src="img/star.png"><br/>
                       <img id="s4" src="img/star.png"><br/>
                       <script src="js/jquery-1.11.3.js"></script>
                       <script>
                           $("#s1").click(function(){
                             var $s=$(this);
                             if(!$s.is(":animated"))
                               $s.animate({left:500},2000);
                             else
                               $s.stop(true);
                           });
                           $("#s2").click(function(){
                             var $s=$(this);
                             if(!$s.is(":animated"))
                               $(this).animate({left:500},2000).animate({top:200},2000);
                             else
                               $s.stop(true);
                           });
                           $("#s3").click(function(){
                             $(this).animate({left:500,top:500},2000)
                           });
                           $("#s4").click(function(){
                             $(this).animate({width:200,
                                             height:200,
                                             marginLeft:-36,
                                             marginTop:-36,
                                             opacity:0},
                                             3000,
                                             function(){$(this).hide()})-------------------回调函数，让display占用的块自动隐藏
                           });
                       </script>
         4.停止动画: $(...).stop()
             问题: 默认只能停止队列中正在播放的当前动画，后续动画依然继续执行
             解决: $(...).stop(true) 清空队列
                ex:<style>
                         #d1{
                             border:1px solid #aaa;
                             border-radius:6px;
                             background:#eee;
                             width:50px; height:50px;
                             position:absolute; top:120px; left:0;
                         }
                   </style>
                   </head>
                   <body>
                     <h1>animate</h1>
                     <button id="btn1">启动动画</button>
                     <button id="btn2">停止动画</button>
                     <div id="d1">abcd</div>
                     <script src="js/jquery-1.11.3.js"></script>
                     <script>
                         //测试animate支持哪些属性
                         $("#btn1").click(function(){
                             $("#d1").animate({
                                 width:150,
                                 height:200,
                                 padding:50,
                                 left:500
                             },2000);
                         });
                      //测试启动和停止动画
                         $("#btn2").click(function(){
                             $("#d1:animated").stop(true);
                         });
         5.并发与排队
            1.并发: 多个css属性同时变化，放在一个animate内的多个css属性，同时变化
                 $("..").animate({多个属性},speed);
            2.排队: 多个css属性，先后依次变化，先后对同一个元素调用多个动画API，则多个动画API排队执行
                   实质：其实每个元素都有一个等待队列，调用动画API，并不是执行动画的意思，只是将动画，加入等待队列中
                 $("..").animate({},speed).animate({},speed);
         6.选择器: :animated 获取或判断一个正在播放动画的元素
     14.类数组对象操作
            1.为jquery添加jquery(全局)函数
                 $.each();
                 什么是:不依赖于任何具体DOM对象,就可直接调用jquery函数.
                 1.如何:所有jquery全局函数都定义在jquery全局对象中
                     step1:选判是否加载jquery库
                           if(window.$===undefined)
                     step2:在jquery中添加自定义对象
                           (命名空间对象)
                                 $.对象名={}
                     step3:在自定义对象中添加自定义扩展方法
                           $.对象名.方法名=function(){}
                 2.如何调用:3步
                     1:先引入jquery.js!!!!
                     2:再引用自定义.js
                     3:调用 $.对象名.方法();
            2.为(jquery对象)添加方法
                $("..").each();
                1.何时:只要一项完整效果/功能需要复用,就要将效果封装为jquery插件函数,
                2.如何使用:jquery插件函数都添加到 jQuery.fn中即可
                     step1:选判是否加载jquery库
                           if(window.$===undefined)
                     step2:在jQuery.fn中添加方法
                           jQuery.fn.shLi=function(){
                                 }
            3.. 仅支持jQuery对象的:
                 $(...).each(function(i,elem){  })    arr.forEach( ... )
                 var i=$(...).index(elem)           arr.indexOf( value )
                 更简化: 如果在一个父元素内找:
                     $(elem).index();
            4. 支持所有类数组对象和数组对象的静态API
                 $.each(obj,function(i , elem){ ... })
                 $.inArray(value, arr)
            5.鄙视: $(...).each() vs $.each()
                 1. 存储位置: $(...).each() 保存在jQuery原型对象中
                     $.each() 直接定义在构造函数上——静态
                 2. 适用的对象:
                     $(...).each()  只能被jQuery类型的子对象调用
                     $.each()   可被任何数字下标的数组或类数组对象适用
                 ex:<ul id="list">
                     <li>98</li>
                     <li>85</li>
                     <li>33</li>
                     <li>99</li>
                     <li>52</li>
                    </ul>
                    <script src="js/jquery-1.11.3.js"></script>
                    <script>
                     //请给每个不足60分的成绩+10分，并将超过90分的成绩用绿色背景标识出来
                   /*  $("#list>li").each(function(i,elem){
                       console.log(i,elem);
                       var $elem=$(elem);
                       var num=parseInt($elem.html());
                           if(num<60){
                             num+=10;
                             $elem.html(num);
                           }else if(num>90){
                             $elem.css("backgroundColor","green");
                           }
                     });*/-------------------------------------$(...).each(function(i,elem))用法
                     var lis=document.querySelectorAll("#list>li");
                     $.each(lis,function(i,elem){
                       var $elem=$(elem);
                       var num=parseInt($elem.html());
                       if(num<60){
                         num+=10;
                         $elem.html(num);
                       }else if(num>90){
                         $elem.css("backgroundColor","green");
                       }
                     });-------------------------------------$.each(对象数组，function(i,elem))用法
                     var arr=[1,2,3,4,5];
                     $.each(arr,function(i,elem){
                       arr[i]=elem*2;
                     });
                     console.log(arr);
                   </script>
     15.自定义API
         向jQuery类型的原型对象中添加自定义函数--------如封装自定义插件例子tabs/accordion/dropdown
     15.jquery 插件:
         什么是: 为库/框架，添加新功能的小程序
         为什么: 添加新功能， 重用功能
         何时: 只要项目中出现相同的或类似的功能，都可封装为插件，反复使用。
         如何:
              1. 引入插件的css (如果有)
              2. 按照插件规定，编写HTML内容
              3. 先引入jQuery，再引入插件.js
              4. 在自定义脚本中调用插件API
         1. 官方插件:
              jQuery UI: 3大部分:
              1. 效果: 3件事:
                    1. 重写了animate方法，支持颜色动画
                    2. 为简单动画API，添加了更多动画效果
                    3. 为addClass/removeClass/toggleClass添加了动画效果
              2. 交互: 自学
              3. 小部件: 拥有独立样式和行为的小功能
                    1.手风琴效果:
                         1. 引入jquery-ui.css-------<link>
                         2. 按插件的要求，编写HTML内容----------html代码
                         3. 引入jQuery和jQuery UI 的js------script引入文件
                         4. 在自定义脚本中，调用插件函数-----自定义script文件编写
                    2.******原理: jQuery插件函数做了2件事：
                          1. 侵入: 根据插件自己的需要，隐式添加属性和样式
                          2. 事件绑定:
                    3.自动完成:-----------ex:difficult/jQuery框架实现input输入关键字
                                           文档结构：css/jquery-ui.css
                                                     data/products/getProductsByKw.php
                                                         init.php
                                                     js/jquery-1.11.3.js
                                                        jquery-ui.js
                        html: <input>
                        js: $(input).autocomplete({//---------------自动检索关键字
                             source: 本地数组/"xxx.php"
                        })
                        php: 只能有一个参数: term，传递文本框中的内容
                             必须直接返回结果集合
                             结果集合中的每个元素，必须带label属性
                    4.日历: datepicker-----ex:difficult/jQuery插件实现日历.html
                    5.对话框: dialog-----ex:difficult/jQuery插件实现模态对话框.html
              4.jQuery UI vs Bootstrap区别
                   jQuery UI: html: 不需要添加任何属性
                              js: 调用插件API: 2件事
                              1. 侵入: 自动在元素上添加class
                              2. 事件绑定
                   问题: 封装的太死了，不便于维护
                   Bootstrap: html: 手动添加class ——添加样式
                                    手动添加data-*扩展属性 ——添加行为
                              引入bootstrap.js时:查找所有data-*的元素，绑定事件
         2. 封装自定义插件:
              前提: 已经用普通的html,css,js实现了插件的样式和功能
              jQuery UI:
                   1. 将插件的css集中定义在独立的css文件中
                   2. 在独立的js文件中, 为jQuery.fn添加插件API函数:
                         1. 侵入class和自定义扩展属性:
                         2. 绑定事件
                   3.***如何使用: 同jQuery UI
                        1.引入插件.css
                        2.定义HTML内容
                        3.引入jQuery, 插件.js
                        4.定义自定义脚本: 调用插件API
              Bootstrap:
                   1. css同jQueryUI方式
                   2. 在独立的js文件中，查找具有自定义扩展属性的元素，绑定事件
                   3.***如何使用:
                        1. 引入插件css
                        2. 定义HTML内容，手动添加class和data-*扩展属性
                        3. 引入插件.js
         3.第三方插件:(jquery.com官网/plugins/Form)
              1.表单验证:jquery.com官网/plugins/Form Validation Engine----------第三方插件-表单验证-validate
                    下载：jquery-validation-1.17.0.zip  解压后看dist(发布版本)
                     messages_zh.js中有表单验证的所有项目，可根据实际要求自行选择
                     remote:远程
              2.文件上传: 3种:
                 1. HTML Form:
                      HTML:
                          <form method="post" enctype="multipart/form-data" action="xxx.php">---发文件必须用post，因为get有大小限制，且为一次请求
                          enctype:内容类型；multipart:多块；form-data:表单数据，兼容大数据格式；action:处理或者接收地址
                          <input type="file" name="xxx"/>
                      PHP:----过程
                         1.只要表单提交，文件已经自动上传到PHP服务器
                         2.只是暂时以随机文件名保存在临时目录中----------保存在xampp/tmp文件夹中
                             在php文件中可用$_FILES["字段名"]，获得描述文件信息的PHP对象
                                 $file=$_FILES["字段名"];-----------字段名为input表单元素中name=""的值;
                             其中: $file ["tmp_name"]属性 获得临时文件名
                                   $file["name"] 上传前的原始文件名
                                   说明：此文件是以类数组对象形式保存：格式为
                                           array(5) {
                                           ["name"]=> string(10) "Desert.jpg" -------------------原始文件名
                                           ["type"]=> string(10) "image/jpeg"
                                           ["tmp_name"]=> string(24) "C:\xampp\tmp\php5DA2.tmp" ----------------临时且随机的文件名
                                           ["error"]=> int(0)
                                           ["size"]=> int(845941)
                                           }
                         3.我们调用move_uploaded_file()，将临时目录中的临时文件，转储到目标位置：
                             move_uploaded_file($file["tmp_name"], 目标文件名)
                         4.当PHP执行完，临时目录中的临时文件都自动释放
                          ex:第一步：html文件：
                          <body>
                              <form id="form1" method="post" enctype="multipart/form-data" action="upload_file.php">
                                <label>选择本地文件:
                                  <input type="file" name="touxiang"/>
                                </label>
                                <br />
                                <input type="submit" name="submit" value="Submit" />//-----------此种方式必须type:submit
                              </form>
                            </body>
                          第二步：php文件：upload_file.php
                          <?php
                          $file=$_FILES["touxiang"];/*用input中name的value值获得表单中信息*/
                          if(!file_exists("upload/".$file["name"])){----------如果upload文件夹中没有此文件，才上传
                          	move_uploaded_file(
                          		$file["tmp_name"],//临时文件名
                          		"upload/".$file["name"]//保存在upload文件夹下，并以原文件名命名，"upload/".$file["name"]中.为php拼接路径方式
                          	);
                          	echo "保存成功!";
                          }else
                          	echo "文件已存在!";
                 2. ajax:
                     html: <form>元素不需要加特殊属性
                      js: $.ajax({
                          type:"post",
                          url:"upload_file.php",
                          data:new FormData($("#form1")[0]),//---------只有formData中的内容才支持上传，jquery的ajax中必须新建formData,并拿到DOM元素内容
                          contentType:false,//上传文件的内容不处理
                          processData:false//上传文件的数据不处理
                        }).then(text=>{ ... })//--------------------------如果引入的是jquery-3.2.1.js版本，是支持then功能的
                      php: 同普通模式的PHP
                         ex:第一步：html-----------请求了php必须在127访问
                             <form id="form1">
                                  <label>选择本地文件:
                                    <input type="file" name="touxiang"/>
                                  </label>
                                  <br />
                                  <input type="button" name="submit" value="上传"/>//-----------此种方式必须type:submit
                                </form>
                            	<script src="../js/jquery-3.2.1.js"></script>
                            	<script>
                            		$(":button").click(function(){
                            			$.ajax({//-------------------------此处使用jquery版本的ajax是因为之前自己封装的ajax并不支持文件上传功能
                            				type:"post",
                            				url:"upload_file.php",
                            				data:new FormData($("#form1")[0]),
                            				contentType:false,
                            				processData:false
                            			}).then(text=>{
                            				alert(text);
                            			})
                            		})
                            	</script>
                            	第二步：php与上面html内容一样
                 3. 插件:blueimp-jQuery-File-Upload-9.7.2-0-gc1392e0.zip
                     1.此插件已经包含服务端，有自己的php文件
                     2.默认将上传的文件保存在php/files文件夹下
                     ex:<input id="fileupload" type="file" name="files[]" data-url="php/" multiple>------files[]支持多个文件上传，data-url服务端路径
                        <script src="../js/jquery-3.2.1.js"></script>
                        <script src="../js/jquery.ui.widget.js"></script>
                        <script src="../js/jquery.iframe-transport.js"></script>
                        <script src="../js/jquery.fileupload.js"></script>
                        <script>
                        	$("#fileupload").fileupload({
                        		add(e,data){//选中文件时，触发----data相当于临时存储的口袋
                        			data.$btn=//将创建好的btn保存到data口袋中备用
                        				$("<button/>")//创建并设置上传按钮
                        					.text("上传")
                        					.click(function(){
                        						$(this).prop("disabled",true)
                        							.text("正在上传...");
                        						data.submit();//开始上传
                        					})
                        					.appendTo("body")//将上传按钮添加到body
                        					.before(//在上传按钮前添加上传文件名
                        						"<br><b>"+data.files[0].name+"</b>"
                        					);
                        		},
                        		progressall(e,data){},//正在上传 进度条设置
                        		done(e, data){//上传完成后触发，取出按钮改样式
                        			data.$btn.text("上传成功!")
                        				.css("background","lightGreen");
                        		}
                        	})
                        </script>
              3.wysiwyg: 富文本编辑:----------------多行文本，如微信聊天界面
                     $(文本框).wysiwyg("getContent") //获得富文本编辑器中的内容
                     $(文本框).wysiwyg("setContent","html片段")
                     ex:<link rel="stylesheet" href="../css/jquery.wysiwyg.css">
                         </head>
                         <body>
                          <textarea name="" id="txt" cols="90" rows="30"></textarea>
                        	<script src="../js/jquery-1.11.3.js"></script>
                        	<script src="../js/jquery.wysiwyg.js"></script>
                        	<script src="../js/wysiwyg.image.js"></script>
                        	<script src="../js/wysiwyg.link.js"></script>
                        	<script src="../js/wysiwyg.table.js"></script>
                        	<script>
                        		$("#txt").wysiwyg({//----***------------依赖于css/jquery.wysiwyg.bg.png和jquery.wysiwyg.gif两张图片
                        			controls:{
                        				html:{visible:true}//---------------让html显示出来，可以看到源代码
                        			}
                        		});
                        	</script>
              3.jQuery Ajax
                    $.ajax({
                         type:"get/post",
                         url:"url",
                         data:"参数"|$(form).serialize()|对象|new FormData(form),
                         dateType:"json"|"jsonp",
                         beforeSend:function(xhr){ //在发送请求之前调用 }
                         complete:function(xhr, statusCode){ //请求完成之后 }
                         success:function(data){ //请求成功后，自动触发}
                         error:function(xhr){ //请求出错时，调用 }
                    }).then(data=>{ ... })
     
                    $.get("url",data, success ,dataType)
                         $(parent).load("url",callback)
                         $.getJSON("url",data, success)
                         $.getScript("url",data,success)
                    $.post("url",data, success ,dataType)
     16.*****跨域:一个域名下的网页，向另一个域名下的服务端发送请求
           包括:
               URL	                            说明	                 是否允许通信
               http://www.a.com/a.js
               http://www.a.com/b.js	           同一域名下	                 允许
     
               http://www.a.com/lab/a.js
               http://www.a.com/script/b.js	同一域名下不同文件夹	          允许
     
               http://www.a.com:8000/a.js
               http://www.a.com/b.js	        同一域名，不同端口	              不允许
     
               http://www.a.com/a.js
               https://www.a.com/b.js	        同一域名，不同协议	           不允许
     
               http://www.a.com/a.js
               http://70.32.92.74/b.js	        域名和域名对应ip	           不允许
     
               http://www.a.com/a.js
               http://script.a.com/b.js	        主域相同，子域不同	           不允许
     
               http://www.a.com/a.js
               http://a.com/b.js	        同一域名，不同二级域名（同上）	       不允许（cookie这种情况下也不允许访问）
     
               http://www.cnblogs.com/a.js
               http://www.a.com/b.js	                不同域名	                不允许
           问题: xhr(ajax)禁止发送跨域请求
                 只要xhr类型的请求，都不能跨域
                 $.ajax, $.get, $.post, $.getScript, $.getJSON
           解决: 用script发送跨域请求
                 script: 请求一段js代码，并在客户端本地执行
     17.session:
         什么是: 服务器端，专门保存每个客户端临时数据的存储空间
         为什么: 保持多个请求之间的数据共享和连续性
         何时: 在多个请求之间保存一个用户的共享数据时
         原理:
             浏览器窗口第一次向服务器发送请求时，服务器会为当前客户端开辟一个session存储空间，并返回sessionid，保存在客户端cookie中
             每次客户端窗口向该服务器发送请求，都会自动携带sid，用于找到自己的session存储空间，反复存取数据
         如何:
             session其实是一个内存中的关联数组:
             session_start();
             $_SESSION["属性名"]=值
     ---------------------------------------------------mysql数据库----------------------------------------------------------
     1.数据库服务器分类
         网状数据库
         树形数据库
         关系型数据库!!!!
             MySQL**/SqlServer/Oracle/DB2....
             NOSQL数据库/Redis
           MySQL:公开->MySQL AB->SUN->Oracle
     2.下载,安装,使用
             版本:  5.5 (5.6) 5.7
             系统:  windows/linux/unix
             32/64位:右击我的电脑->64
             官网:http://www.oracle.com.cn/
             镜像:http://mirrors.sohu.com
             xampp 软件工具包(php/mysql/apache)
     3.MYSQL数据库数据的结构
             mysql服务器->库-->表-->行(记录)->列(字段)
     4.使用
             1:启动 mysql服务器 不要停止
             2:SQL语句  ---  重点&难点
                 Structured Query Language 结构查询语言，
                 专用于数据库增删改查数据库中的数据
             3:SQL语句分类
                 DDL(Data Define Language)      数据定义语句
                   CREATE/DROP/ALTER/TRUNCATE
                 DML(Data Manipluate Language)  数据操作语句
                   INSERT/DELETE/UPDATE
                 DQL(Data Query Language)       数据查询语句
                   SELECT (最难)
                 DCL(Data Control Language)     控制用户权限
                    GRANT/REVOKE
     5.在线手册:
         ? ALTER TABLE 回车
     6.保存sql脚本文件 utf8
           ANSI<-->GBK
     7.打开mysql窗口
           每次新打开窗口执行指令：SET NAMES UTF8;
     8.BUG    windows-->命令功能弱 只能正确显示gbk 中文
           mysql功能:将utf8数据转换 gbk显示
           指令:
             SET NAMES gbk;
             SELECT * FROM bb_book;
     9.如何进入 mysql系统中
                 xampp-->右击按钮[shell] 点击
                     #mysql -uroot -p
                     mysql 指令->进入mysql数据库
                     -u    输入用户名
                     root  root是mysql系统权限最大用户
                     -p    密码
       如何进入mysql服务器：mysql.exe -h127.0.0.1 -P3306 -uroot -p
       退出：quit;
     10.文件引入数据库
            第一种方法：SOURCE  d:/taobao.sql
            第二种方法：在windows界面：mysql -uroot < E:\zhang\1801class  (路径中无中文和空格，且后面无分号)
     11.库表的创建及增删改查：
     #? alert table----用法
         1.CREATE 创建库
             1.标准语法
                 CREATE DATABASE 库名;
                 (***重要：否则汉字无法显示)CREATE DATABASE 库名 CHARSET=utf8;
                     示例：
                          CREATE DATABASE web1702 CHARSET=utf8;
             2.大小写?库名
                 mysql指令 CREATE create 对
                     建议:大写
             3.表名，库名，列名
                 建议:小写
             4.表名，库名，列名->
                 字母开头,不要空格，不要中文
                 不要特殊字符
             5.mysql 坑
                 html/css/js/dom/jquery/php UTF-8
                 mysql                      utf8
         2.CREATE TABLE 创建表
             1.标准语法
                 CREATE TABLE 表名(
                    列名称1  列类型,
                    列名称2  列类型,
                    ...
                    列名称n  列类型
                 );
                 #(表名,列名)小写字母开头后面_数字
                  不要中文不要空格不要其它字符
             2.所有表第一列都要id编号
                   示例:
                   商品表 t_product
                         编号id   图片pic   名称name  价格price
             3.列类型（使用手册第11章）
                 INT         整型     -21亿~21
                 DECIMAL(10,2)  高精度浮点数   货币严谨，适用于工资类    //112345678.22
                 VARCHAR(N)  字符串   n字符(汉字，字母，数字，特字符串)n 1~20000
                 DATETIME    日期时间 *年*月*日*时*分*秒
                 BIGINT 时间使用
                 DOUBLE(M,N)浮点     m数字其中包含n位小数
                   示例:
                   USE web1702a;
                   CREATE TABLE t_product(
                            id INT PRIMARY KEY,
                            pic VARCHAR(100),
                            name VARCHAR(20) UNIQUE NOT NULL,
                            price DOUBLE(10,2)
                         );
                 ex:1   huahua   md5('1997-10-1')------------md5()是加密32位
                     select md5('123')；------------可以在数据库查询到加密码
                 详细分类：
                     (1)数值类型——可用引号括起来也可以不用
                         TINYINT：微整数，占用1个字节，-128~127    **UNSIGNED TINIINT  非负整数
                         SMALLINT：小整数，占用2个字节， -32768~32767
                         INT：整数，占用4个字节，-2147483648~2147483647
                         BIGINT：大整数，占用8个字节，很大   **用来存储时间
                         FLOAT(M,D)：单精度浮点小数，占4个字节，3.4E38，范围远大于INT，但精度不如INT，可能产生计算舍入误差
                         DOUBLE(M,D)：双精度浮点小数，占8个字节，1.79E308，范围远大于BIGINT，但精度不如BIGINT，可能产生计算舍入误差
                         DECIMAL(M,D)：定点小数，不会产生计算舍入误差，M代表总的有效位数，D代表小数点后允许出现的有效位数
                         BOOL：布尔类型，只能取值为TRUE(真/是/1)、FALSE(假/否/0)
                     (2)日期时间类型——必须用引号括起来
                         DATE：日期类型，如'2015-10-1'
                         TIME：时间类型，如'10:25:8'
                         DATETIME：日期时间类型，如'2018-10-2 22:10:5'
                     (3)字符串类型——必须用引号括起来
                         CHAR(M)：定长字符串，可能产生空间浪费，操作速度快，M不能超过255
                         VARCHAR(M)：变长字符串，不会产生空间浪费，操作速度慢，M不能超过65535
                         TEXT(M)：大型变长字符串，M不能超过2G
                 约束：
                     (1)主键约束 - PRIMARY  KEY
                         声明为主键的列上不能插入重复的值，也不能插入NULL值。
                         表中的记录会自动按照主键列上的值*由小到大*排序,
                         加快查找的速度,一个表最多*只能有一个主键列*。
     ****所有的约束中，主键约束推荐使用——可以提高查询的效率；其它约束是否使用取决于项目组的设计，可用可不用——有可能降低插入和更新操作的效率。
                         ex:aid INT PRIMARY KEY AUTO_INCREMENT--------------主键自增长
                     (2)唯一约束 - UNIQUE
                         声明了唯一约束的列上不能插入重复的值；但可以插入NULL值，而且可以插入多个NULL。
                     (3)非空约束 - NOT NULL
                         声明了非空约束的列上不能插入NULL值；但可以插入重复值。
                     (4)默认-DEFAULT
                     *** uname VARCHAR(32) PRIMARY  KEY,
                         uname VARCHAR(32) UNIQUE   NOT  NULL,
                         都能实现“唯一且非空”要求，区别在于：前者会自动排序，后者不会排序！  前者在一个表中只能出现一次，后者可以在多个列上出现
                     (5)检查约束：CHECK
                         检查约束可以对输入的数据范围进行检验
                         CREATE TABLE stu(age TINYINT CHECK(age>=18 AND age<=60) ) —— MySQL不支持，会降低插入和更新操作的效率
                     (6)外键约束：FOREGIN  KEY
                         声明了外键约束的列，取值必须在另一个表的主键列上出现过，外键列上可以出现重复值或NULL，主键和外键的类型必须一致。
                         ex:    FOREIGN KEY(familyId) REFERENCES xz_laptop_family(fid)
         3.验证创建库创建表指令
             1.查看当前 mysql中所有库名
                             SHOW DATABASES;
             2.进入指定库中
                             USE 库名;
             3.查询当前库中所有表名
                             SHOW TABLES;
             4.查询指定表名结构
                             DESC 表名;
         4.DROP 删除库 删除表
             1.注意:一但删除库或者表很难恢复
             2.生产环境:非常非常谨慎操作
             3.如果很重要的库->(备份)->删除
                     DROP DATABASE 库名;
             4.如果指定库名存在删除否则就什么都不做.
                     DROP DATABASE IF EXISTS 库名;
                     示例:
                     DROP DATABASE IF EXISTS web1702;
             5.什么删除操作一定谨慎
                     DROP TABLE 表名;
                     示例:产品表
                         DROP TABLE t_product;
         5.删除表中记录
             1.删除之前一定谨慎-->
             2.标准语法:
                 DELETE FROM 表名;
                 DELETE FROM 表名 WHERE id = 值;
                     示例:
                     DELETE FROM t_stu WHERE id=2;
         6.向表中添加一行数据(记录)
             1.标准语法:
                INSERT INTO 表名 VALUES(值1,值2,..);
                   注意：
                  1:如果当前列是(字符串)或(日期类型)
                     数据加单引号  'tom'  '2000-10-10'
                  2:所有语句以分号结尾
                  3:字符串类型数据区分大小写
                   示例:
                     INSERT INTO t_stu VALUES
                     (1,'tom','2000-10-10');
                     INSERT INTO t_stu VALUES(2,'jerry',
                     '2017-05-05');
                   ex:INSERT INTO xz_admin(aid,aname,apwd) VALUES(null,'huahua',md5('123'));
         7.更新表中某一些记录
             1.标准语法:
                 UPDATE 表名 SET 列名=新值;
                 UPDATE 表名 SET 列名=新值,列名=新值 WHERE 列=值;
                     示例:
                     UPDATE t_stu SET ctime = '2017-10-10'
                     WHERE name = 'tom';
                 99%-->原因 id==>INT
                     UPDATE t_stu SET ctime = '2017-10-10' WHERE id = 1;
         8.修改列类型:标准语法
             ALTER TABLE 表名 MODIFY  列名 新列类型;
                 示例：
                 ALTER TABLE t_user MODIFY upwd VARCHAR(32);
         9.查询记录
                 1.标准语法:SELECT 列名,列名... FROM 表名 WHERE  条件 ORDER BY 列名    **查询且排序
                 2.所有列
                     SELECT * FROM 表名;
                 3.多表查询
                     SELECT p.id,p.name,t.name FROM  t_product p, t_ptype t WHERE p.did = t.id
                 4.部门编号或者是1，或者是2
                     select * from jd_emp where deptId in (1,2);
                   工资在10000到12000之间
                     select * from jd_emp where salary between 10000 and 12000;
                   左连接
                     select e.ename,e.salary,d.dname from jd_emp e left join jd_dept d on e.deptId=d.did;
                   右连接
                     select e.ename,e.salary,d.dname from jd_emp e right join jd_dept d on e.deptId=d.did;
                   搜索此表0位置开始的8条数据
                     SELECT * FROM jd_product limit 0,8;
     *************binary(sql语句中密码必须验证大小写，原理其实是用unicode号做比较:)
                      ex:$sql="SELECT * FROM xz_user WHERE uname='$n' AND binary upwd='$p'"
                 ex:SELECT aid,aname,apwd FROM xz_admin;----------------不用*查询
         10.注释：
             单行注释：#...
             多行注释：/*...*/
         11.乱码：
             根源：MySQL默认存储数据使用Latin-1字符集，无法表示中文！
             解决：1.Settings-editor-file encodings-project encoding-utf-8（或者编辑器右下角改成utf-8）
                   2.创建文件之前，在头部写入SET NAMES UTF8;
                   3.CREATE DATABASE *** CHARSET=UTF8;
         12.标准SQL语句的分类：
            (1)DDL: Data Define Language 定义数据列
                 CREATE / DROP / ALTER(修改) / TRUNCATE(截断)
            (2)DML: Data Manipulate Language 操作数据行
                 INSERT / DELETE / UPDATE
            (3)DQL: Data Query Language 查询数据
                 SELECT
            (4)DCL: Data Control Language 控制用户权限
                 GRANT(授权) / REVOKE(收权)
     ----------------------------------------------------------php-----------------------------------------------------------
     1.php概述、语法
     	1.作用: 负责接收客户端请求，处理请求,查找请求资源并且将结果返回给客户端浏览器.
         	(电话餐厅 大堂经理)
         2.web服务器<--->apache
     2.web服务器种类
     	1.静态web服务器(apache)
     	    提供的内容任何时间任何人访问完全相同
     		属于静态web范畴技术：
     		 	HTML/CSS/JS/Flash/视频/音频/图片
     	2.动态web服务器(apache)
             提供的内容在不同时间由不同人访问可能不完全相同.属于动态web范畴技术
     			 1) JSP = HTML + JAVA
     			 2) ASP.NET = HTML + C#
     			 3) PHP = HTML + PHP (简单)
     			 4) NodeJS = HTML + Node.JS
     3.php 背景知识
     		php是一种运行在(服务器)端编程序语言，用于生成动态网页.
     		php 2000 zend
     		php特点:开源，简单，易于手，
     		跨平台(windows/linux/mac)
     		!!!适合中小型应用开发(微博.微信.微信公众平台..)
         	php版本 5.1 5.4 5.5  .. 6.0  7.0
     4.php是如何工作的
     	 a:前提条件: apache服务器启动正常工作
     	 b:客户端浏览器在地址栏输入一个程序地栏,按回车发送请求 {请求}
     			http://127.0.0.1/day03/1.php
          c:apache接收请求，并且负责查找相应资源
     			1.php
          d:如果apache没有找到相应的资源,返回错误消息给客户端浏览器
     			404 NOT FOUND
          e:如果资源存在,apache发现请求是一个php程序,apache将处理php任务交给php解析引擎,php.exe解析处理执行代码
          f:php.exe将执行后的结果转html/css/js 文件发送apache
          g:apache将结果(html/css/js) {响应}发送给客户端浏览器
          h:客户端浏览器显示apache返回内容(html/css/js)
     			示例:bbs/select_user.php(day03)
     5.搭建php运行环境
     		1:安装软件 apache
     		2:安装软件 php解析器
     		3:所有php只能保存在c:/xampp/htdocs/1.php
         	4.启动apache
     		5:访问php程序(运行)
     		6:唯一方法:
     			浏览器地址栏http://127.0.0.1/1.php 回车
         		127.0.0.1 地址运行apache软件计算机地址
     			本机
     6.php语法:
     	   a:注意程序位置  c:/xampp/htdocs/...
     	   b:创建一个程序
     		   <?php
     			   php程序;
     			 ?>
     	   c:声明变量(直接声明立即赋值)
     		   $age = 10;
            	   $name = "tao";
     	   d:输出字符串,数字
     		   echo $age;
     	   e:运行(唯一方式)http://127.0.0.1/1.php
     	   f:一个php程序由html/css/js/php 混合组成
     			示例:2.php(day02)
     			示例:3.php 四个示例
     7.php中数据类型
     	   1)值类型/标量类型(原始类型)
     		     string
     			 boolean/bool
     			 int/integer
     			 float/double
     	   2)复合类型
     			 object   php面向对象 2005出现
     			 array    索引/关联
     	   3)特殊类型
     			 null/NULL
     			 resource 资源类型(数据库连接)
     			 示例:4.php(day02)
            4)数组使用
     			1.数组分类
     				1：索引数组:下标自动生成
     				2：关联数组:下标需要手工指定
     			2.索引数组
     				1:声明
                     	$arr=array(10,203,3,4);  旧版本 5.3
                         $arr=[10,20,30,10,100];  新版本 5.4
     				2:读取数组元素修改数组元素
     					$arr[0];
     					$arr[1]=10;
     				3:循环数组
     					  count($arr)返回值 5
     						函数:count计算数组中元素个数
     				4:向数组末尾追加元素
     					  $arr[] = 11;
     			3.关联数组
     				1:声明
     					  $arr = ['eid'=>1001,'ename'=>'tom','age'=>20];
     				2:读取数组元素修改数组元素
     					  $arr['eid'] = '1002';
     				3:循环数组合
     					  foreach($arr as $k=>$v){
     							  echo($v);
     							}
     					 示例:5.php
     					 示例:6.php
     8.php连接mysql  重点&难点	php中操作mysql数据库的函数
     	   php最初提供一套连接操作mysql函数   mysql_xxx();
     	   后来提供了增强版函数              mysqli_xxx();
     	 1.使用php连接mysql服务器步骤:
     		 1:创建到mysql服务器连接
     		   $conn = mysqli_connect(url,uname,upwd,dbname);
     			 url   mysql服务器地址 '127.0.0.1'
     			 uname mysql用户名  'root'
     			 upwd  mysql密码    ''
     			 dbname 连接哪个库  'dangdang'
     		 2:向mysql服务器发送sql语句
     		   $result = mysqli_query(数据连接,sql语句);
     		 3:读取mysql服务器返回结果
     		   if($result===true){
     			  执行成功
     			 }else{
     			  执行失败
     			 }
     		 4:断开与mysql服务器连接---(可以省略)
     			 mysqli_close($conn);
     				示例:8.php 添加数据(day02)
     					dangdang/dd_category(id,name,bcount);
     		 5.坑:*****php->数据库记乱码!
     			 1.原因:默认情况下 php-->mysql添加数据
     					 编码latin_1
     			 2.解决:在创建连接之后加一行指令
     					 $conn = mysqli_conn.......
     					 mysqli_query($conn,"SET NAMES UTF8");
     						 PHP发送sql转码--latin_1-->utf8
     					综合示例:fetch_01.php
     		 6.php 常用函数
     				 die('') 终止当前php文件的执行,并且向客户端输出一个终止原因说明.
     				 @       压制住当前行代码警告消息.
     				 time()  返回当前系统时间，以秒为消息的整数
     				 $id = mysqli_insert_id($conn);返回连接上刚刚执行insert语句产生自增编号.
     				 $size = mysqli_affected_rows($conn);返回连接上刚执行增删改语句影响行数
     				 mysqli_fetch_all($result,MYSQLI_ASSOC);从查询结果集中抓取所有记录，并且返回二维数组.
     					示例:mysql_news_02.php(day03)
     				 strripos($filetype,"image"),查找image在$filetype中位置，找到返回数字下标，未找到返回false
     				 ex:$filetype=$_FILES["myfile"]["type"];
                         if(strripos($filetype,"image")===false){//找到返回数字，未找到返回false
                             die('{"code":-1,"msg":"上传文件类型不正确，请重选!"}');
                         }
     		 7.explode和implode   爆炸和粘贴
     ---------------------------------------------------------------http-----------------------------------------------------
     1.学习http协议的目标
     	1:调试ajax应用的中"看不见模不着"的错误
     	2:进行web访问优化--高阶面试
     2.URL
     	世界上任何一个建筑必须有一个"地址",互联网上任何一个资源(html/img/css/js/php)
     	必须有一个"URL"才能被访问.
     	标准URL:
     		<scheme>://<user>:<pwd>@<host>:
     		<port>/<path>;<params>?<query>#
     3.URL/URN/URI
     	Unified Resource Locator    统一的资源定位符
     	Unified Resource Naming     统一的资源命名符
     	Unified Resource Identifier 统一的资源识别符
     		图示:uri_urn_url.png(day03)
     	URI = URL+URN
     	URL: <a href="http://tmooc.cn/logo.gif"></a>
     		 <img src="http://tmoo.cn/1.jpg" />
     	URN:
     		 <a href="mailto:admin@tmooc.cn">...</a>
     		 <a href="javascript:void(0)">...</a>
     4.完整URL格式:
     	<scheme>://<user>:<pwd>@<host>:<port>/<path>;<params>?<query>#
     5.<scheme> 方案:
     	指定以哪种(协议)从服务器上获取指定资源
     	常见方案:http/https/ftp/file/telnet.
     	  http://www.ccb.com/cn/home/indexv3.html
     	  https://ibsbjstar.ccb.com.cn----安全，加密方式
     6.<host> 主机名 资源所在服务器ip地址或者域名
     	127.0.0.1      <-----> localhost
     	61.135.169.121 <-DNS-> www.baidu.com
     7.<port> 端口号 每一项服务在计算机上都有一个监听端口号，整数
     	netstat -an  查找端口
         端口：1-65535   可用范围：1023-65535
             apache  80/443 (1~65535)
             mysql   3306
             ftp	    21	文件上传下载
             ssh	    22  安全的远程登录
             telnet	23  远程登录
             smtp    25	邮件传输
             dns		53  域名解析  baidu<->61..
             http	80  超文本传输协议(发送网页)
             pop3	110 邮件接收
             https	443 加密超文本传输协议
     8.<query> 参数
     	http://127.0.0.1/1.php?uname=tom&upwd=123
     9.相对URL/绝对URL
     	1：以方案开头绝对URL
     		<a href="http://127.0.0.1/1.html">
     	2：不以方案开头相对URL
     		<a herf="1.html"/>
     10.HTTP 协议概述
     	互联网早期没有http协议
     	IETF (互联网任务委员会)
     	 1990年 http/0.9 有严重缺陷
     	 1996年 http/1.0 标准 RFC1945
     	 1999年 http/1.1
     11.http协议工作方式:请求响应方式
     	1:客户端浏览器发送请求给web服务器(apache)request
     	    {请求}
     	2:web服务器接收请求，处理数据，并且将结果返回客户浏览器 response
     	    {响应}
     12.请求次数
     	1:地址输入地址             回车
     	2:<img src="1.jpg">..</a>  请求
     	3:<script src="jquery.js"> 请求
     	4:<link href="1.css">      请求
     13.http/1.1比http/1.0改进了哪些地方?
     	1:支持虚拟主机技术，在一个web服务器上同时并存多个不同域名网站，即在一台物理服务器同时创建多个虚拟主机,充分利用服务器资源
     		 tmooc/tts/jobshow
     	2:支持持久连接技术，早期http1.0不支持持久连接：提升服务器与浏览器传输数据效率
     		三次握手/四次挥手
     		客户端和服务器之间连接保持一段时间
     		(x秒钟) 30S
     		Connection:keep-alive 持久化
     	3:支持代理连接：路由器
     	  Proxy:xxx
     14.http协议详解
     	 a:02.html 盗链
     	 b:缓存.jpg
     15.http请求和响应的内容
     	1.标准格式：
     		请求消息(request) --客户端浏览器发送服务器
     		响应消息(response)--服务器发送客户端浏览器
     	2.请求方式:用于标明此次请求的目的
             GET: 表示客户端想"获取"服务器端指定资源，无请求主体
             POST:表示客户端想“上传/发送/添加”数据给指定服务器,相关数据请求主体中，有请求主体
             PUT:表示客户端想"上传/更新"服务上指定资源，相关数据请求主体中，有请求主体
             DELETE:表示客户端想"删除"服务器指定资源
             HEAD:表示客户端想获取服务器上资源，不要资源内容（不要响应主体）
             TRACE:追踪请求路径
             OPTION: 选项，保存以后使用
             CONNECT:连接测试
         3.GET请求与POST请求区别，以及其他请求发起方式 *****
             1.语义:
                 GET:客户端想获取服务器资源
                 POST:客户端想传递数据给服务器
             2.安全级:
                 GET:不安全
                 POST:不安全
             3.数据长度
                 GET:客户端发送数据最长1KB
                     &wd=%E4%B8%9C%E4%B8%9C
                 POST:没限定
             4.如何发起
                 GET: 地址栏输入URL回车/超链接/js跳转/src/href/表单GET提交/AJAX GET 请求.
                 POST:表单POST提交/AJAX-POST请求
                 PUT请求:AJAX-PUT请求
                 DELETE请求:AJAX-DELETE请求
             5.是否需要编码
                 GET： 发送字符中数据不转码
                 POST：发送字符串数据时自动转码-->中文没问题
             6.http服务器响应状态码 status
                   100-199   提示信息
                       100 Continue  继续
                       101 Switching Protocols   协议切换
                   200-299   成功响应
                       200  OK
                       201 Created
                   300-399   需要客户重定向
                       301 Moved Permanently 永久移动
                       304 Not Modifed   该资源没有被修改
                       302
                   400-499   客户端错误
                       400 Bad Request   错误请求
                       403 Forbidden 请求权限不足
                       404 Not Found 请求资源不存在
                       405 Method Not Allowed    请求方法不支持
                   500-599   服务器错误
                       500 Internal Server Error 服务器内部错误(程序出错)
     16.请求数据：
         1.请求起始行：
             1.请求方式：(8种方式：get,post,put,delete,head,option,trace,connect)
             2.请求地址：
             3. 协议版本：HTTP/1.1
         2.请求头：
             1.Host: tmooc.cn                    告诉服务器请求是哪一个虚拟主机
             2.Connection: keep-alive            告诉对方启用持久化连接
             3.Accept-Language: zh-CN,zh;q=0.9   告诉服务器自己接收自然语言
             4.Referer: http://tmooc.cn/         引用页,告诉服务器此次请求来源自哪个网页
             5.User-Agent: Mozilla/5.0           告诉服务器自己的类型
             6.Accept-Encoding: gzip, deflate    告诉服务器自己可以接收压缩类型
             7.Cache-Control: no-cache           告诉对方如何缓存当前的主体内容
             8.Pragma: no-cache  HTTP 1.0        版本缓存控制
             9.Content-length                    请求主体数据长度
             10.Content-Type
                 1.text/plain  请求数据是普通文本,未经过编码 (有的服务器拒绝)
                 2.application/x-www-form-urlencoded   请求主体是经过编码后的表单数据(POST)
                 3.multipart/form-data  表单中包含上传文件数据
         3.请求主体：
     17.响应数据：
         1.响应起始行：
             1.协议版本：HTTP/1.1
             2.响应状态码：100/200/300/400/500
             3.短语
         2.响应头：
         3.响应主体：
     --------------------------------------------------------------ajax------------------------------------------------------
     1:ajax :Asynchronous JavaScript AND Xml
     	异步的js与xml
     2.ajax简介:
     	2002年 Google GoogleSuggest搜索建议:提出AJAX概念
     	AJAX=HTML+CSS+JS+DOM+HTTP+XML
     3.ajax作用:
     		实现(无刷新)(无提交)(无跳转)的情况下页面内容局部更新.
     4.ajax应用场合:
     		股票走势图、搜索建议、聊天室、注册...
     5.15.AJAX知识点.jpg 思维导图
     6.浏览器中发起请求种类
     	a:同步请求:
     	  浏览器请求后，一片惨白，等待服务器响应,刷新网页(输入内容清空);
     	  地址栏输入地址,表单提交,超接链
     			js跳转
     		示例:
     			01.html  02.php
     	b:异步请求:
     	  浏览器中有内容，同时又发起请求处理响应.(原有内容没有任何改变)
     		AJAX
     7.快速入门:电话餐厅推出新业务{微信订餐}
     	示例一:(day05)
     		1:添加用户 ajax实现功能
     		2:user_add.php        一点都没变
     			manager/t_user
     		3:user_add_input.html 表单 js一块写
     			创建表单
     			变化    ajax_01.zip
     		4:获取用户输入{用户名和密码} js
     		5:发送get请求 user_add.php   js
     			a:创建ajax对象var xhr =  XMLHttpRequest()
     			b:绑定事件        xhr.onreadystatechange
     			c:接收服务器返回数据
     					xhr.responseText //
     			d:打开连接        xhr.open('GET','user_add.php',true);
     			e:发送请求        xhr.send(null);
     		6:获取php返回结果 "添加失败";js
     8.AJAX对象与属性
     	 a:XHR对象: 作用向web服务器发起异步请求,并且接收返回响应消息(数据);
          	构建XHR
     			 1.W3C(ch/ff/sa/IE9+):标准对象 XMLHttpRequest
     			 2.IE(8-): ActiveXObject("Microsoft.XMLHTTP");
     			 3.if(window.XMLHttpRequest){
     				  var xhr = new XMLHttpRequest();
     				 }else{
     				  var xhr = new ActiveXObject("Microsoft.XMLHTTP");
     				 }
          b:XHR对象属性
           	readyState:表示xhr对象当前状态，不能手动赋值,其值会随请求-响应过程自动改变.
     			 1.可取值
     				0 UNSEND  请求信息尚未发送
     				1 OPENED  xhr己经打开到web服务器连接
     				2 HEADERS_RECEVICED xhr己经接收到响应头部
     				3 LOADING xhr正在加载响应的消息主体
     				4 DONE    xhr接收完成响应消息
          c:status: 服务器响应状态码 200
     	 d:responseText:响应文本(响应数据)
     	 e:responseXML:成员方法
          f:open(method,url,isAsyn);  打开到服务器连接
          g:method:请求方法 GET/POST/DELETE..
     			url:   请求地址
     			isAyn  是否是异步请求  true
     			       同步请求  false
          h:send(请求主体);
     			GET:	send(null);
     			POST:   send('name=tom&age=10');
     	 i:成员事件:
     			onreadystatechange: 当前xhr状
                  readyState(0->1)1->2 2->3 3->4
     			  状态改变规则:
     			  (0)------->(1)------>(2)--->(3)--->(4)
     			  初始 open()    send()    自然  自然
     9.使用XHR发起异步请求消息步骤--重点
     			 1) 创建对象XHR
     			    var xhr = new XMLHttpRequest();
     			 2) 绑定监听(监听状态改变)事件
     			    xhr.onreadystatechange = function(){}
     			 3) 打开一个连接(web服务器)
     			    xhr.open('GET',url,是否是异步请求);
     			 4) 发送请求消息
     			    xhr.send(请求主体);
     10.ajax处理不同的数据类型
        	     纯文本     -->掌握
     		 文本与网页 -->重点掌握 text/html
     		 xml        -->掌握 application/xml
     		 json       -->重点掌握!!!(工业标准) application/json
     		 javasript  -->掌握 application/javascript
     	1.text/html
     			  <div><span>css指南</span></div>
     			  <div><span>js指南</span></div>
     			  <div><span>h5指南</span></div>
     	2.application/xml  100 字节
     			  <books>
     				   <book>
     						<name>css指南</name>
     				   </book>
     				   <book>
     						<name>js指南</name>
     				   </book>
     				   <book>
     						<name>h5指南</name>
     				   </book>
     			  </books>
     	3.application/json    25字节
     		  示例：[
     				 {"name":"css指南"},
     				 {"name":"js指南"},
     				 {"name":"h5指南"}
     			   ]
     		  1.XML是字符串格式描述数据，麻烦->重量级
     			JSON是字符串格式描术数据，简单->轻量级
     		  2.业界标准:php/java/nodejs/.net...
     			JSON:易于阅读和编定,语法js语句,但是目前己被各种语言所支持."异构系统交互数据标准"
     		  3.异构系统: java---> json-->php js
     					 c   ---> json-->
     		  4.JSON字符串语法要求
     			  1:一个JSON字符串有且只有一个根: {}对象   [] 数组
     				1.[1,2,3,4]
     				2.{"name":"tao","age":10}
     				3.[{"name":"tao"},
     					{"name":"james"}
     				  ]
     				  ex:{--------{"A":[{"a":"1","b":"2"},{}],"B":[{"a":"1","b":"2"},{}]}
     				  "recommended":[{"pid":"8","title":"Apple MacBook Air\u7cfb\u5217","details":"\u5185\u5b58","pic":"img\/index\/study_computer_img1.png","price":"6988.00","href":"product_details.html?lid=1","seq_recommended":"1","seq_new_arrival":"1","seq_top_sale":"1"},
     				  {},
     				  {}],
     				  "top_sale":[{},
                                   {},
                                   {}]
     				      }
     				4.error:
     						{"name":"tao"}
     						{"name":"james"}
     			  2:JSON中可以表示数字,bool,null,字符串,----如果字符串必须用双引号
     			  3:[]数组可以包含多个值，使用逗号分隔
     			  4:{}对象可以包含多个键值对,使用逗号分隔，键和值之间用冒号;键必须是用双引号
     				  简单示例:
     						[1,2,4,2,10,10]
     						{"name":"tom","age":10}
     						[{"name":"jerry"},{"name":"kk"},{"age":19}]
     		  5.php函数:将常用数据类型转换json字符串
     					$arr = ["name"=>"tom","age"=>19];
     					$str = json_encode($arr);
     					$arr = [1,10,100,9];
     					$str = json_encode($arr);
     					echo $str;
     			  示例:json格式字符串(day06)
     					json_01.php
     					json_book02.php
     		  6.格式转换:
     				服务器:php
     				1:将数组转换json字符串
     				  $str = json_encode($arr);
     				2:发送客户端浏览器
     					echo $str;
     				客户端:js
     				3:将json字符串--转换-->js对象
     					1:客户端对象JSON.parse(str);
     						var result = JSON.parse(str);
     					2:[]-->js数组  {}-->js Object
     						json_book02_input.html(day06)
     		  7.json数据流程.jpg
     	4.application/javascript 使用xhr接收响应消息
     		提示:一般.js文件中,script请求(任何人)(任何时间)js内容一样.
     		场景:需要服务器端返回 "动态js",根据客户端不同或访问时间不同,js也不同.
           	1.服务器端:
     			header("Content-Type:application/javascript");
     			echo "var msg = '你好';alert(msg);";
           	2.客户端:
     			eval(xhr.responseText);
     				示例：(day08)
     				 i18n_04.php
     				 i18n_04.html
     11.解答二个问题
     	1.ajax:哪些元素动态创建:绑定事件，冒泡/事件代理
     	2.这个元素是使用什么方式创建
     		1:document.createElement();
     		2:menu.innerHTML = xhr.response;
     12.jquery中的ajax
     	1.ajax操作封装函数--load();
     		1.使用语法:
     		   $("选择器").load(URL,[data],[fn]);
     			 URL : 请求url地址
     			 data: 参数
     			       'name=tom&age=10'
     						 {name:"tom",age:10}
     			 fn  : 回调函数.ajax请求返回结果自动
     			       调用函数
                  []   可选
     			 $("ul").load("x.php");
     	   	2.作用含义:
     			 发起一个XHR请求，data为null则为GET
     			 否则发起POST请求,把服务器端返回的响应数据(必须是html片段).追加为选定元素的innerHTML;
     			 若有参数fn,则调用该函数;
            	3.使用限制
     			  1:服务器只有返回是html片段
     			  2:选中元素内容必然被清除
     	   	4.示例:客户端页包含
     			1:创建header_01.php 包含全站每个页面都必须页头内容
     			2:创建footer_01.php 包含全站每个页面都必须页尾内容
     			3:创建index_01.php  主页
     				   <div id="header">..</div>
     				   <div id="main">首页主体内容</div>
     				   <div id="footer"></div>
     				$("#header").load("header_01.php");
     	2.jquery中对ajax操作封装函数--get();
     		1.使用方法:
     			$.get(URL,[data],[fn]);
     			$.get("x.php",function(){});
     		2.作用:
     			发起一个XHR GET请求，如果服务器返回成功响应消息,调用fn,在函数中处理响应数据.
     				案例演示:动态加载下拉列表的内容(day08)
     					1:weiduomei.sql
     					  t_cake_type 蛋糕类别
     						id  name
     						10  巧克力蛋糕
     						20  水果蛋糕
     						30  芝士蛋糕
     					2:编写php type_list.php
     							  向客户返回所有蛋糕类别 json
     					3:编写html type_list.html
     							  提供select 缺少有效数据，待页面加载
     								完成后，异步请求type_list.php
     								将返回数据
     								<option value="10">水果</option>
     	3.jquery中对ajax操作封装函数--post();
     		1.使用方法:
     			$.post(URL,[data],[fn]);
     			$.post('x.php','name=tom&age=10',fn);
     			$.post('x.php',{name:"tom",age:10},fn);
     		2.作用:
     			发起一XHR POST请求，并在请求主体中提交请求数据.如果服务器返回成功响应消息
     			调用参数fn,在该方法中处理响应数据.
     		3.ajax处理数据格式:{文本/网页/js/xml/json}
     			99% - json
     			99% - $.ajax({})
     		4.示例:
     			编写php: cake_type_add.php
     			name 保存数据库,返回数据类JSON
     			$str = '{"code":-2,"msg":"类型名是必须的"}'
     			添加成功:
     					$str = '{"code":1,"msg":"添加成功"}';
     			编写html: cake_type_add.html
     					创建表单-->POST
     			  echo '{"code":-1,"msg":"添加失败"}';
     			  echo "{'code':-1,'msg':'添加失败'}";
     	4.jquery中对ajax操作封装函数--getScript();
     	5.jquery中对ajax操作封装函数--getJSON();
     	6.jquery中对ajax操作封装函数--ajax();--万能************
     		使用方法:
     		  $.ajax({
     					type:'GET',    请求方式POST/PUT/DELETE..
     					url:'x.php',   请求地址*** ok
     					data:{k1:v1,k2:v2}  请求参数
     					beforeSend:fn, 请求消息发送之前回调函数
     					success:fn,    响应完成且成功回调
     					error:fn,      响应完成且失败回调
     					complete:fn    响应完成回调(不论成败)
     				});
     13.XML (java 旧项目)
     	1.html:超文本标记语言，所有标签预定义好
     		h1 h2 h9 用于描述一个网页结构
         2.xml:可扩展的标签语言，所有标签都是自定义的，用于描述一段数据-尤其复合数据;
     		<book>
     			<id>10</id>
     			<name>js大全</name>
     			<price>100.00</price>
     		</book>
     	3.xml语法
     		1:xml文档类型声明
     			<?xml version="1.0" encoding="utf-8"?>
     		2:整篇xml有且只有一个根元素
     			<books>
     			</books>
     		3:标签有开始必须有结束，开始标签与结束的签完全相同
     			<book></book>
     		4:标签可以嵌套不能交叉
     			<book><id><i></i></id></book> ok
     			<id><book></id></book> err
     		5:标签可以有任意属性,必须有单引号或双引号括起来.
     		6:总结:XML和HTML用途不同，xml语法更加严格
     			示例一:books.xml(day08)
     			示例二:cakelist_02_xml.php
     		7.服务器端:
     			header("content-type:application/xml");
     			echo "<?xml version='1.0' encoding='utf-8'?>";
     			echo "<cakelist>";
     			echo "<cake><id>1</id><pic>1.jpg</pic><price>100.00</price></cake>";
     			echo "<cake><id>2</id><pic>2.jpg</pic><price>100.00</price></cake>";
     			echo "<cake><id a='1'>3</id><pic>3.jpg</pic><price>100.00</price></cake>";
     	  ....
     			echo "</cakelist>";
     		8.客户端: DOM 标准 html DOM
     			cakelist_02_xml.html(day08)
     			var doc = xhr.responseXML;
     			var cakes = doc.querySelectorAll("cake");
     			var id  =   cake.querySelector("id");
     			var txt = id.innerHTML;
     			var v =   id.getAttribute("a");
     		9.标准流程:
     			php发送xml
     				<cakelist>
     				   <cake></cake>
     				   <cake></cake>
     			    </cakelist>
     14.跨域(ajax跨域)-->了解
         www.tts.com/1.php --> www.tmooc.cn/2.php
     	a.com-->c.com
     	b.com-->a.com
     	c.com..
     	1:跨域精确定义
     		1:两个域名不同   a.com  b.com
     		2:协议名不同     http://a.com/1.php
     					     https://a.com/2.php
     	    3:主机名/ip不同
     					     http://127.0.0.1/1.php
     					     http://localhost/2.php
     	    4:端口号不同     http://127.0.0.1:80/1.php
     					     http://127.0.0.1:8080/2.php
     	2:浏览器允许跨域请求情形
     		 <img src="跨域图片允许" />
     		 <link href="跨域css允许" />
     		 <script src="跨域js允许" ></script>
     		 <iframe 跨域访问></ifram>
         3:浏览器禁止跨域访问
     	 	浏览器禁止XHR(ajax) -->可能会导致数据安全风险
         4:解决方案:JSONP
     	    JSON with Padding (填充式json)
     			是一种使用json数据方法，用于解决浏览器xhr跨域限制.
     		JSONP.jpg 图示(day09)
     		  示例:
     			01_crossdomain.php
     			<meta charset="utf-8">
     			#强制浏览器按utf-8显示网页内容
     			02_crossdomain.php
     	5:jsonp思路:
     		发起(异步)请求，不使用xhr,使用一个动态创建,script标签代替xhr
     			<script async src="跨域程序"></script>
     		要求服务器必须返回一段js片段,包含服务器端js数据
     			callback('hello')
     		客户端特意提供一个callback(data)函数
     		注意:
     			访问第一个程序 01_crossdomain.php
     			http://127.0.0.1/01_crossdomain.php
       	6:使用jquery实现jsonp跨域请求
     		  $.ajax({
     			   url:"http://localhost/02.php",
     				 dataType:'jsonp',
     			 success:function(){
     					console.log(arguments);
     				 }
     			});
     		  function callback(data){
     			  console.log(data);
     			}
     =======================================================H5================================================================
     1.html5新特性 (网页漂亮,功能强,动画效果)
         (1)html5新特性--新的语义标签
         (2)html5新特性--增强型表单(2.0)
         (3)html5新特性--音频和视频
         (4)html5新特性--Canvas绘图(重点)-大鱼小鱼
         (5)html5新特性--SVG绘图(地图)
         (6)html5新特性--地理定位
         (7)html5新特性--拖放API
         (8)html5新特性--Web Worker
         (9)html5新特性--Web Storage
         (10)html5新特性--Web Socket
     2.增强型的表单
         1.新input type
             h4:text/password/button/submit/radio/checkbox/image/file/hidden..
             h5:email/url/number/tel/color/range/date/month/week
             ex:<form action="#" method="post">
                    用户名：<input type="text" name="uname"><br>
                    密码：<input type="password" name="upwd"><br>
                    年龄：<input type="number" name="uage"><br>
                    您的网站：<input type="url" name="uurl"><br>
                    邮件：<input type="email" name="myemail"><br>
                    颜色：<input type="color" name="mycolor"><br>
                    <!--兼容性差-->
                    日期：<input type="date" name="mydate"><br>
                    月份：<input type="month" name="mymonth"><br>
                    星期：<input type="week" name="myweek"><br>
                    <!--电话不存在任何验证-->
                    电话：<input type="tel" name="mytel"><br>
                    范围：<range type="range" name="myrange"></range><br>
                    <input type="submit" value="注册">
                </form>
         2.新表单元素
             h4:input;button;select/option;textarea
             h5:datalist/progress/meter/output
             1.datalist  (数据列表)
                 <datalist id="list3">------------datalist本身不可见
                     <option>xx</option>
                     <option>yy</option>
                 </datalist>
                 <input type="text" list="list3" />
                 datalist为input 提供建议列表用户从中选取，也可以手工输入
                 ex:<datalist id="list3">
                        <option>便宜坊</option>
                        <option>九花山</option>
                        <option>全聚德</option>
                    </datalist>
                    中午去吃烤鸭
                    <input type="text" name="point" list="list3">
             2.progress(显示一个进度条，有两种形式)
                 <progress></progress>  左右晃动进度条
                 <progress value="0.1" /> 具有指定进度值的进度条(0~1)
                 ex:<h1>进度条</h1>
                                   <progress></progress>
                                   <progress value="0.5" id="t1"></progress>
                                   <script>
                                       var t1=document.getElementById("t1");
                                       var value=0.1;
                                       var timer=setInterval(
                                           function(){
                                               value+=0.1;
                                               t1.value=value;
                                               if(value>0.9){
                                                   clearInterval(timer);
                                                   alert("下载完成！");
                                               }
                                           } ,500);
                                   </script>
             3.meter(刻度尺)
                 meter:用于标识一个值所处范围:不可接受(红色)可接受(黄色)非常优秀(绿)
                 <meter min="最小值" max="最大值" low="下限" high="上限"   optimum="最佳值" value="当前值" />
                     薪水
                 ex:<meter id="m1" min="0" max="100000" low="20000" high="90000" optimum="99999" value="0" ></meter>
                    <script>
                        var m1=document.getElementById("m1");
                        var val=0;
                        var timer=setInterval(
                            function(){
                                val+=500;
                                m1.value=val;
                                if(val>99999){
                                    clearInterval(timer);
                                }
                            }
                            ,100);
                    </script>
             4.output(输出,语义标签，没有任何外观样式，样式等同span)
                 商品单价:￥3.50
                 商品数量:<input type="number" value="2"/>
                 小计:<output>￥3.50</output>
                 ex:商品单价：3.50<br>
                    商品数量：<input type="number" value="1"><br>
                    小计：<output>3.50</output>
         3.新属性
             h4:type;name;id;value;style;readonly;disabled;
             h5:
                 (1)placehodler:占位符
                 (2)autofocus:自动获取焦点
                 (3)multiple:允许输入多个值(使用逗号分隔) email
                 (4)form:用于把输入域放置form 外部
             ==与验证相关属性
                 (5)rquired:必填项
                 (6)minlength:指定字符最小长度
                 (7)maxlength:指定字符最大长度
                 (8)min:数值最小值
                 (9)max:数值最大值
                 (10)pattern:正则表达式
             ex:<form action="#" id="f3">
                   用户名: <input type="text" autofocus  placeholder="请输入用户名" required minlength="3" maxlength="8" name="uname"> <br>
                   手机<input type="text" pattern="1[345678][0-9]{9}">
                   <input type="submit" value="登录">
                 </form>
                 邮件 <input type="email" name="uemail" form="f3" multiple/>
     3.音频和视频(重点)
         1.Flash被H5取代体现的方面：
             Flash绘图(AS/Flex)  ==>  Canvas/SVG
             Flash动画         ==>  定时器+Canvas
             Flash 视频和音频   ==>  video/audio
             Flash 客户端存储  ==>   WebStorage
         2.视频(重点)：
             1.H5提供了一个新的标签用于播放视频：video本身是300*150的inline-block元素
                 <video src="x.mp4"></video>
                 <video>--------------如果怕浏览器不兼容的写法
                     <source src="x.mp4"></source>
                     <source src="x.ogg"></source>
                     <source src="x.webm"></source>
                     您的浏览器版本太低，请升级
                 </video>
             2.成员属性
                 autoplay:false   自动播放
                 controls:false   是否显示播放控件
                 loop:false      循环播放
                 muted:false    静音
                 poster:""      在播放第一帧画面之前显示的海报
                 preload:""     视频的预加载策略
                 auto:		 预加载视频元数据以缓冲一定时长
                 metadata: 只预加载视频元数据(尺寸，时长，第一帧画面)
                 none		 不预加载任何数据
             ----js对象属性
                 currentTime    当前播放时长
                 paused:true    当前视频是否处理暂停状态
                 volume:1      音量(0~1)
                 playbackRate:1 回放速率(1 5)
             ----js成员方法
                 play()         播放视频
                 pause()       暂停播放
             ----js事件
                 onplay        当视频开始播放时触发的事件
                 onpause       当视频开始暂停时触发的事件
         3.音频(兼容性差 chrome不支持)：
             1.默认是一个300*30的inline-block.但若没有controls属性,则display:none
                 <audio src="x.mp3"></audio>
                 <audio>
                 <source src="x.mp3"></source>
                 <source src="x.ogg"></source>
                 <source src="x.wav"></source>
                 您的浏览器版本太低，请升级!
                 </audio>
                 <embed src="x.mp3">
                 旧标签,过时标签
                 </embed>
             2.成员属性:
                 autoplay:false   自动播放
                 controls:false   是否显示播放控件
                 loop:false      循环播放
                 muted:false    静音
                 preload:""     视频的预加载策略
                 auto:		 预加载视频元数据以缓冲一定时长
                 metadata: 只预加载视频元数据(尺寸，时长，第一帧画面)
                 none		 不预加载任何数据
             ----js对象属性
                 currentTime    当前播放时长
                 paused:true    当前视频是否处理暂停状态
                 volume:1      音量(0~1)
                 playbackRate:1 回放速率(1 5)
             ----js成员方法
                 play()         播放视频
                 pause()       暂停播放
             ----js事件
                 onplay        当视频开始播放时触发的事件
                 onpause       当视频开始暂停时触发的事件
     4.canvas--(重点)-(网页漂亮/炫/强大/游戏<商业>)
         1.网页中绘图技术：网页中实时走势图,网页游戏,地图应用都要绘图技术，有三种绘图技术:
             (1)Canvas:2D位图绘图技术，H5新技术
             (2)SVG:2D矢量图绘图技术，2000年出现，后纳入h5标准
             (3)WebGL:3D位图绘图技术，尚未纳入h5标准
         2.Canvas绘图技术---canvas:画布---canvas标签在浏览器默认300*150的inline-block,
             ***注意事项:1.画布宽度高度只能用html/js属性来赋值，
                         2.不能用css样式赋值(缩放)
                         3.每个画布上有且只有一个"画笔"对象--使用该对象来绘图
             步骤：1.获取html中canvas元素
                   2.获取画笔对象
                   <body>
                       <canvas width="500" height="400" id=c2>
                           您的浏览器版本太低，请升级
                       </canvas>
                   </body>
                   <script>
                       var c2=document.getElementById("c2");
                       var ctx = c2.getContext("2d");  //ctx画笔对象
                       ...
                   </script>
             1.矩形(长方形) :矩形定位点在自己的左上角
                 ctx.lineWidth = 1;       //描边宽度
                 ctx.fillStyle = "#000"     //填充样式或颜色
                 ctx.strokeStyle = "#000";  //描边样式
                 ctx.fillRect(x,y,w,h);      //填充矩形
                 ctx.strokeRect(x,y,w,h);   //描边矩形
                 ctx.clearRect(x,y,w,h);    //清除一个矩形范围内所有元素
             2.文本:一段文本定位点在在其文本基线起点
                 ctx.textBaseline = "alphabetic";    ---文本基线，可设置“top”
                 ctx.font="12px sans-serif";		文本大小和字体
                 ctx.fillText(str,x,y);				填充一段文本
                 ctx.strokeText(str,x,y);			描边一段文本
                 ctx.measureText(str)			基于当前文本大小测量文本,返回一个对象 {width:x}
             3.渐变对象
                 线性渐变:linearGradient
                 径向渐变:radiaGradient
                 var g = ctx.createLinearGradient(x1,y1,x2,y2);  起点坐标终点坐标
                 g.addColorStop(offset,color);
                 g.addColorStop(offset,color);
                 ctx.strokeStyle = g;
                 ctx.fillStyle = g;
             4.路径
                 path:由多个坐标点组成的任意形状,路径不可见,可用于"描边","填充".
                 ctx.beginPath();      开始一条新路径
                 ctx.closePath();      闭合当前路径
                 ctx.moveTo(x,y);     移动到指定点
                 ctx.lineTo(x,y);       从当前点到指定点画直线
                 ctx.arc(cx,cy,r,start,end) 绘制圆拱形路径----0*Math.PI/180,180*Math.PI/180
                 cx,cy 圆心 r 半径 start 开始角度 end 结束角度
                 ctx.stroke();        描边
                 ctx.fill();          填充
                 ctx.clip();          裁剪
             5.图像
                 Canvas属于客户端技术，图片在服务器中,所以浏览器必须先下载,要绘制图片，且等待图片下载完成，才绘制图片.
                     var p3 = new Image();   1:创建图片对象
                     p3.src = "img/p3.png";  2:下载图片
                     p3.onload = function(){  3:绑定事件onload 图片下载成功
                         绘制图片
                         ctx.drawImage(p3,x,y);     原始大小图片
                         ctx.drawImage(p3,x,y,w,h);  拉伸绘图
                     }
             6.Canvas绘图--变形
                 Canvas绘图中也有变形技术,可以针对某一个图片/图形的绘制过程变形:rotate;translate;
                     ctx.rotate(弧度)     旋转画笔，轴点是画布原点
                     ctx.translate(x,y);  将整个画布的原点平移到指定点
                     ctx.save()           保存画笔当前状态(颜色，角度..)
                     ctx.restore()        恢复到画笔最近一次保存状态(颜色，角度...)
             7.贝塞尔曲线
                 起点  控制点  终点
     5.SVG绘图
         1.位图与矢量图区别：
             位图:由一个一个像素点组成，每个点各有自己颜色，色彩细致，但放大失真
             矢量图:由一个又一个线条组成，每个线条可以指定颜色，方向，可以无限缩放，但是细节不够丰富
         2.canvas与svg区别：**************
                             canvas	                                      svg
             类型：	        2D位图	                                    2D矢量图
             如何绘图：	    使用js代码	                                使用标签绘图
             事件绑定：	    每个图形不是元素，无法直接绑定事件.	        每个图形是元素，可以直接绑定事件监听
             应用场合：	    特效,游戏	                                   地图
         3.svg技术在HTML5中如何绘制图形
             <svg id width height></svg>-------------------------------画布
             <circle r="" cx="" cy="" fill="" stroke=""  fill-opacity="" stroke-opacity=""></circle>--------绘制圆形
         4.SVG绘图特点
             (1)所有的图形默认只有填充黑色,没有描边色
             (2)svg图形的样式可以使用元素声明方法，也可以使用css形式来声明，但用CSS声明时，只能使用svg专用样式，不能用CSS样式，
                 如: 边框只能stroke,而不用border
             (3)动态添加svg图形
                 1.html字符串拼接:
                      var html = `<circle></circle>`;
                      svg.innerHTML = html;
                 2.使用:
                      var circle = document.createElementNS("http://www.w3.org/2000/svg","标签名");
                      circle.setAttribute("fill","red");
                      svg.appendChild(circle);
             (4)图形可以用js对属性赋值
                 circle.getAttribute("width");
                 circle.setAttribute("width","");
         5.矩形
              <rect x="" y="" width height fill stroke fill-opacity></rect>
                  ex:<svg id="s3" width="500" height="400">
                         <rect x="50" y="350" width="100" height="1" fill-opacity="0.6" fill="red" stroke="blue"
                         stroke-opacity="0.6" stroke-width="3" id="r3"></rect>
                     </svg>
                     <script>
                         var s3=document.getElementById("s3");
                         var h=1;
                         var r3=document.getElementById("r3");
     
                         var timer=setInterval(function(){
                             r3.setAttribute("height",h);
                             h++;
                             var y=r3.getAttribute("y");
                             y--;
                             r3.setAttribute("y",y);
                             if(h>300){
                                 clearInterval(timer);
                             }
                         },100);
                     </script>
         6.椭圆
               <ellipse rx="" ry="" cx="" cy=""></eliipse>
                   rx:水平半径
                   ry:垂直半径
                 ex:<svg id="s3" width="500" height="400">
                        <ellipse rx="200" ry="10" cx="250" cy="200" fill="blue" fill-opacity="0.6"></ellipse>
                        <ellipse rx="10" ry="200" cx="250" cy="200" fill="blue" fill-opacity="0.6"></ellipse>
                    </svg>
         7.直线、折线
               <line x1="" y1="" x2="" y2=""></line>
                   x1 y1 起点坐标
                   x2 y2 终点坐标
                       ex:<svg id="s3" width="500" height="400">
                              <line x1="10" y1="10" x2="10" y2="10" stroke="blue" stroke-width="5" stroke-linecap="round"></line>
                              <line x1="15" y1="10" x2="30" y2="10" stroke="blue" stroke-width="5" stroke-linecap="round"></line>
                              <line x1="10" y1="20" x2="10" y2="20" stroke="blue" stroke-width="5" stroke-linecap="round"></line>
                              <line x1="15" y1="20" x2="30" y2="20" stroke="blue" stroke-width="5" stroke-linecap="round"></line>
                              <line x1="10" y1="30" x2="10" y2="30" stroke="blue" stroke-width="5" stroke-linecap="round"></line>
                              <line x1="15" y1="30" x2="30" y2="30" stroke="blue" stroke-width="5" stroke-linecap="round"></line>
                          </svg>
               一条折线可以有任意多个连接点
                   <polyline points=" 50,50 100,120 38,24 "  stroke="#f00" fill="transparent">
                   </polyline>
                        ex:<svg id="s3" width="500" height="400">
                                <polyline id="s3" points="250,200 350,200 275,270 250,200" stroke="red" fill="transparent"></polyline>
                           </svg>
         8.多边形
              <polygon points="50,50 100,20 .."  fill=""></polygon>
                 ex:<svg id="s3" width="500" height="400">
                         <polygon id="s3" points="200,200 200,300 400,300 400,200 300,250" stroke="red" fill="red"></polygon>
                         <polygon id="s3" points="300,240 380,200 220,200" stroke="red" fill="red"></polygon>
                    </svg>
         9.文本
              svg画布上不允许使用普通html元素绘制文本,span,p
              <text font-size="" fill="" x="" y="">文本内容</text>
                 ex:<svg id="s3" width="500" height="400">
                         <text font-size="28"  x="100" y="100" fill="transparent" stroke="black" alignment-baseline="before-edge"> hello terana</text>
                    </svg>
         10.图形
              svg画布不允许使用普通用html 元素 <img>
              <image xlink:href="x.png" x="" y="" width="" height="">
                 ex:<svg id="s3" width="500" height="400">
                         <image xlink:href="p3.png" x="250" y="200"></image>
                    </svg>
         11.渐变对象,过滤器
              渐变对象属于一种特效对象--单独定义
              <defs>    #defs 所有特效对象都定义在此标签
                 <linearGradient id="g3" x1= y1= x2= y2=>
                   <stop offset="0%" stop-color="red" stop-opacity="" />
                   <stop offset="50%" stop-color="red" stop-opacity="" />
                   <stop offset="100%" stop-color="red" stop-opacity="" />
                 </ linearGradient>
              </defs>
              <ANY fill="url(#g3)"  stroke="url(#g3)"></ANY>----------any指代任何标签
                  ex:<svg id="s3" width="500" height="400">
                         <defs>
                                 <linearGradient id="g3" x1="0%" y1="0%" x2="100%" y2="0%">
                                     <stop offset="0%" stop-color="red"></stop>
                                     <stop offset="100%" stop-color="white"></stop>
                                 </linearGradient>
                         </defs>
                         <rect fill="url(#g3)" x="0" y="0" width="500" height="200"></rect>
                     </svg>
     6.地理定位
         Geolocation:地理定位,使用JS获取当前浏览器所有在地理坐标
         (经度,纬度,海拨,速度)数据,用于实现LBS应用(Location Based Service)
             如:饿了么，高德导航，滴滴打车，企业网站(我的位置,路线)...
         (1)手机浏览器如何获取定位信息
             #首选手机中的GPS芯片与卫星通信,定位精度米
             #次选手机通讯基站进行定位获取，定位精度公里
         (2)PC浏览器获取定位信息
             #通过IP地址反向解析，定位精度
             HTML5中提供一个新的对象,用于获取当前浏览器定位信息
                 window.navigator.geolocation{
                     getCurrentPosition:fn,    获取定位信息(google)
                     watchPosition:fn        监视定位数据改变
                     clearPosition:fn         取消监视
                 }
         (3)第三方服务厂商(百度地图,腾讯地图)
             1.注册百度开发者帐户
                 http://lbsyun.baidu.com/
             2.创建一个网站,登录百度地图，为网站申请地图AccessKey
             3.在自己的网页中嵌入百度地图提供API,将地图功能加入网页
                 百度地图坐标拾取器
                 http://api.map.baidu.com/lbsapi/getpoint/index.html
     7.拖放API:Drag & Drop 拖动和释放
           HTML5为拖动行为提供了7个事件，分为两组
               1.拖动的源对象(会动)可以触发事件:
                   dragstart  拖动开始
                   drag      拖动中
                   dragend   拖动结束
               2.拖动的目标对象(不动)可以触发事件:
                   dragenter 拖动进入
                   dragover  拖动着悬停在上方
                   dragleave 拖动离开
                   drop     在上方释放
               3.整个拖动事件1:dragenter*1+dragover*n+dragleave*1
                 整个拖动事件2:dragenter*1+dragover*n+drop*1
               4.注意:必须阻止dragover 的默认行为,drop才可以触发
     8.Web Worker
           1.程序:program  指可以被CPU执行代码，存储磁盘中.
           2.进程:process  指程序被OS调用内存中，并且分配空间,随时供CPU调用执行
           3.线程:Thread   线程是进程内部执行代码基本单位
           4.chrome浏览器中的线程模型
           一个chrome进程内，多个线程组件,可以"并发"向web服务器，发起HTTP请求，以获取所需资源.------------资源请求线程
             并发:宏观上同时执行，微观上依次循环执行
             还有一个线程负责所有内容绘制到浏览器中--UI主线程(执行代码)
           5.创建一个并发执行新线程，让它来执行耗时js任务，解决方案是创建线程
               语法规则:
               var w2 = new Worker("执行js程序");
           6.Worker线程缺陷：
               浏览器不允许Worker线程操作任何DOM/BOM对象!!
               原因:浏览器只允许UI主线程操作DOM和BOM！若多个线程同时都可以操作DOM结构，页面将混乱!所以，类似JQUERY的JS程序不能用Worker来加载执行.
           7.解决方法：Worker线程可以给UI主线程发送数据--------------h5/webworker创建多线程
                 Worker: postMessage(str);
                 UI:    var w = new Worker("js/01.js");
                        w.onmessage = function(e){e.data}
               #UI主线程发送数据Worker线程
                 UI:    var w = new Worker("js/01.js");
                        w.postMessage(str);
                 Worker:onmessage = function(e){e.data}
           8.项目中worker应用“
                 (1)只要js中有DOM和BOM就不能用worker
                 (2)worker适合于执行耗时JS任务,复杂计算,加密解密
     9.Web Storage：在浏览器中存储当前用户专有的数据:购物车,订制样式
             1.在客户端存储数据可以使用的技术
                 (1)Cookie技术:浏览器兼容性;不能超4KB,操作复杂
                 (2)Flash存储:依束Flash播放器
                 (3)H5 WebStorage:不能超8MB，操作简单
                 (4)IndexDB:可存储数据，还不是标准技术
             2.Session:会话,浏览器从打开某个网站第一个页面开始，中间可以打开多个网页，直到关闭浏览器,整个过程称为"浏览器与web服务器一次会话"
             3.WebStorage技术中，为用户提供二个对象
             (1)sessionStorage 类数组对象
                 在会话开始时在内存中分配一块区块，保存数据,此区域可供此次会话中所有页面共同使用,但是，浏览器关闭数据取消.
                 1.作用:登录用户编号
                     sessionStorage.setItem(key,value);      //保存数据
                     sessionStorage[key] = value;           //保存数据
                     var value = sessionStorage.getItem(key); //获取数据
                     var value = sessionStorage[key];       //获取数据
                     sessionStorage.removeItem(key);      //删除一组数组
                     sessionStorage.clear();               //清除所有数据
                     sessionStorage.length;               //保存几对数据
                     var key = sessionStorage.key(i);        //获取第i个key
             (2)localStorage 类数组对象
                 localStorage，保存数可供此次会话及后续后会中页面共同使用，即使浏览器关闭数据也不会消失
                 1.作用:在当前客户端保存常期数据
                     localStorage.setItem(key,value);      //保存数据
                     localStorage [key] = value;           //保存数据
                     var value = localStorage.getItem(key); //获取数据
                     var value = localStorage [key];       //获取数据
                     localStorage.removeItem(key);      //删除一组数组
                     localStorage.clear();               //清除所有数据
                     localStorage.length;               //保存几对数据
                     var key = localStorage.key(i);        //获取第i个key
                 2.localStorage中若数据发生了修改，会触发一次 window.onstorage事件，可以监听此事件，实现监视localStorage数据改变目的,
                   但是，不能监听sessionStorage数据
                     **如果数据安全性要求比较高，不能存储客户端(登录密码)
     10.WebSocket:
         WebSocket协议:属于"广播-收听"模型,客户端连接到服务器就不再断开，永久的连接，双方随时可以向对方发送数据.
         1.ws 服务器端应用
             监听指定端口,接收客户请求，向对方发送消息，并接收消息.
             可以php/java/node.js
         2.ws 客户端应用
             主动发起连接请求，保持永久连接，向对方消息，并接收消息.
         3.html5新对象
             使用html5创建ws客户端
             (1)连接ws服务器
                 var socket =  new WebSocket('ws://127.0.0.1:9001');
             (2)向服务器发送消息
                 socket.send(strMes);
             (3)接收服务器数据
                 socket.onmessage = function(e){e.data}
             (4)断开连接
                 socket.close();
     **错误集锦:
       (1) Parse error: syntax error   line 17  语法错误
       (2)下载错误 header内容写错
       (3) mysql_connect(): Access denied line 9访问被拒绝, 数据库，用户名或密码错
       (4) mysql_connect(): MySQL server has gone away in
          mysql_connect()-->升级-->mysqli_connect();
       (5) Uncaught SyntaxError: Illegal return statement line 20：F12/控制台，语法错误:仔细检查
       (6) 网络故障:
       (7) 404 (Not Found) $.ajax url:"??"   程序地址写错了?
       (8)终级秘籍:F12->NETWORK->response
       (9)验证码错误  -> ctrl+h 清空缓存
       (10)输验证码只能小写
       (11)undefine  F12->network->responses/headers
       (12)Table 'xz.xz_admin1' doesn't exist   表不存在 xz_xz_admin1
       (13)mysqli_fetch_all() expects parameter 1 to be mysqli_result, boolean
              原因:sql语法不正确
              解决3种方法:
                  (1)发送sql之后加判断  if(mysqli_error($conn)){echo mysqli_error()}
                  (2)输出sql语句  echo $sql;
                  (3)输出使用变量 echo $offset.$pageSize;
       (14)http://localhost:63342/h5/admin/product_list.html 没有访问apache
            解决:http://127.0.0.1/h5/admin/product_list.html
       (15)没反应
            解决:一行一行调试
            console.log(0);
            console.log(1);
       (16)返回数据错误 undefined
            解决: php 错误
            F12->NEWORK->response|header
       (17)网络故障
            F12->NEWORK->response|header
       (18)Uncaught TypeError: data is not iterable   js控制台错误
     ======================================================Bootstrap=======================================================
     Responsive Web Page（响应式页面）
     1.在HTML中指定视口的信息:
         声明元标签 viewport (手机适配):viewport元标签
               早期3G手机为了浏览大尺网页，只能强行把网页缩小，导致文字，图片，超链变小。
               IOS提出了"视口",视口用于盛放网页的内容，尺寸可以任意指定，超过部分，滑动显示.
               Android也借鉴此概念.
         <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">(移动端必备！！！)
                                                设备宽度             视口是否缩放
     2.如何编写响应式网页
         1.必须声明视口
         2.文字要使用相对尺寸：em（父元素字体大小倍数），rem（根元素字体大小的倍数），尽量不要使用绝对尺寸（px,pt）
         3.容器元素使用相对尺寸（%，auto），尽量不用绝对尺寸（px）
         4.图片使用相对尺寸（%,auto），尽量不用绝对尺寸
         5.页面元素尽量使用流式布局
             流式布局方法：
                 1.float
                 2.display:inline-block;
                 3.display:flex;
     3.(****重点****)响应式网页使用CSS3 Media Query（CSS3媒体查询）技术（最重要）
         Media:指浏览网页的设备，如screen(pc/pad/phone),print,tv
         Media Query:查询出当前浏览网页设备的类型，以及特性(解析度，尺寸，手持方向等)不同，而有选择性的执行某些CSS代码，而忽略另外一些.
         1.作用：可以根据不用的媒体类型以及特性去执行不同的CSS
         2.语法：@media MEDIA-TYPE and/not/only (MEDIA-FEATURE)
             1.MEDIA-TYPE:媒体类型
                 取值：1.all，默认值，所有设备
                       2.screen,电脑屏幕，智能手机，平板电脑
                       3.tv，电视设备
                       4.pint 打印机
             2.MEDIA-FEATURE：媒体特性
                 取值：1.width:判断是否为指定浏览器窗口大小
                       2.min-width:判断浏览器窗口宽度的最小值
                       3.max-width:判断浏览器窗口宽度的最大值
             @media MEDIA-TYPE and/not/only (MEDIA-FEATURE) and/not/only (MEDIA-FEATURE)
                  ex: @media screen and (min-width:768px) and (max-width:991px){样式规则1{}样式规则2{}}
                       媒体类型是屏幕类型（PC,PAD,PHONE）并且浏览器最小宽度（视口）768像素，并且最大宽度为991像素时，执行css
             3.尺寸类型取值：pc>992px
                         991px>pad>768px
                         phone<767px
     4.@media用法:2种用法
         1.选择性执行css内容：
             @media screen and (min-width:768px) and (max-width:991px){样式规则1{}样式规则2{}}
         2.选择性执行某个外部css文件：
             <link rel="stylesheet" href="cs文件路径" media="MEDIA-TYPE and/not/only(MEDIA-FEATURE)">
               ex:<link  media="screen and (min-width:768px) and (max-width:991px)" rel="stylesheet" href="css/05.css">
             注意：即使不满足当前设备条件的css文件也会被请求，但不会生效
     5.bootstrap：重点：bootstrap.css提供了上千个class，行为依赖于JS库-jQuery
         1.5部分：
             1.起步-引入Bootstrap框架到网页中
                 1.<html lang="zh-cn">指定当前文档的基础语言zh-cn,zh-tw,jp,en
                 作用：1.为浏览器自动翻译功能指定语言基础
                      2，为读屏软件指定基础发音
             2.全局css样式-用于改变页面元素样式的class
             3.组件-使用复杂结构拼出特殊效果
             4.JS插件-页面元素的行为
             5.定制-自定义bootstrap中的内容
         2.必须：<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"/>
                 <meta http-equiv="x-ua-compatible" content="IE=edge"/>
                  x-ua-compatible：Cross UserAgent Compatible 跨（IE）浏览器兼容性：指定用哪个IE内核来进行页面的渲染
                  IE=edge：指定渲染页面的IE浏览器的内核（IE=6：指定用IE6内核渲染页面）
         3.引入Bootstrap.css
           <link rel="stylesheet" href="css/bootstrap.css"/>
         4.两个JS
           1.html5shiv.min.js
             第三方JS，自调函数，用于让老IE（IE8以下）支持html5新标记
             <script src="JS文件路径"></script>
           2.respond.min.js
             第三方JS，自调函数，用于让老IE（IE8以下）支持css3媒体查询（Media Query）技术-响应必备
             <script src="JS文件路径"></script>
             通过头部引用Hack判断当前浏览器是否为IE8及以下
             <!--[if lt IE 9]>
                 <script src=""></script>
             <![endif]-->
         5.两个JS-jQuery,Bootstrap
             1.尽量在页面底部</body>的位置进行引用
             2.注意顺序
                 1.先引入jquery.js
                 2.再引入bootstrap.js
         6.引入测试JS文件：用于检查页面结构是否按照Bootstrap的要求进行编写的
             1.引入bootlint.js，位置位于Bootstrap.js之后
             2.编写代码
             ... ...
     9.Bootstrap第二步-全局css样式-按钮
         1.css reset
             *{box-sizing:border-box;}
         2.上千个class
             bootstrap.css
                 .container{...}
                 .btn-default{...}
         3.Bootstrap默认将屏幕分成四大类
             1.大型屏幕（lg）:w>=1200px
             2.中型屏幕（md）:992px<=w<=1199px (pc机屏幕)
             3.小型屏幕（sm）:768<=w<=991px (pad屏幕)
             4.超小型屏幕（xs）:w<=767px (phone屏幕)
         4.Bootstrap提供的容器元素
             1.定宽容器：.container(在不同宽度大小的设备上，均提供了固定的宽度值)
                 lg:width:1170px
                 md:width:970px
                 sm:width:750px
                 xs:width:100%
             2.变宽容器：.container-fluid(在任何设备中，宽度都是100%)
         5.所有的按钮都依赖于.btn类（基类），页面中允许设置为按钮样式的元素有：
                                         1.button    （一定记得写type="button"）
                                         2.input(submit,reset,button)
                                         3.a
                                ex:<button type="button">HTML默认按钮</button>
                                   <a href="#" class="btn btn-default">链接作为按钮</a>
                                   <input type="button" value="INPUT按钮" class="btn btn-default">
                                   <button type="button" class="btn btn-default">BUTTON按钮</button>
           1.按钮样式： .btn
                     .btn-default 白底深色字效果的按钮
                     .btn-danger/success/warning/info/primary
                     ex:<button type="button" class="btn btn-success">
                            我的购物车
                            <span class="caret"></span>
                        </button>(按钮后的三角效果)
           2.不同尺寸按钮: .btn-lg/sm/xs
           3.块级按钮: .btn-block
         6.列表  .list-unstyled:不带标识的列表
                 .list-inline:行内列表（类似于导航栏，显示同一行）
                 .list-horizontal:水平定义列表,用在<dl>身上
         7.图片  .img-rounded:
                 .img-circle:
                 .img-thumbnail:
                 .img-responsive:
         8.表格  .table-bordered:带边框的表格
                 .table-striped:隔行变色表格（tbody内容）
                 .table-hover:鼠标悬停效果
                 .table-responsive:响应式表格（为table的父元素添加）
                 注意：<table class="table"></table>  记得加基类class=table，   thead不受隔行变色限制
         9.文本
             1.文本颜色相关   .text-danger/success/warning/info/primary
                             .bg-denger/success/warning/info/primary
             2.文本大小写     .text-uppercase:全大写
                             .text-lowercase:全小写
                             .text-captalize:首字符大写
             3.文本对齐方式   .text-left:文本左对齐
                             .text-center:文本居中对齐
                             .text-right:文本右对齐
                             .text-justify:文本两端对齐
         10.栅格布局系统
             1.使用方式：
                 1.栅格布局系统的最外层，必须是bootstrap提供的两个容器类之一
                     .container或.container-fluid
                 2.允许在容器中放置若干“行”
                     .row:表示一行
                     <div class="container">//容器
                         <div class="row"></div>//行1
                         <div class="row"></div>//行2
                     </div>
                     每行中最多等分为12列
                 3.行（div.row）中放置列，但是每列需要指定宽度（当前列要占据几列的宽   1/12,2/12）
                 4.列  根据适用的屏幕分为四种类型
                     .col-xs-* 在超小屏幕中，占几列的宽
                         ex:col-xs-1  在超小屏幕中，占一列的宽（8.33%）
                            col-xs-1  在超小屏幕中，占两列的宽（8.33*2%）
                     .col-sm-* 在小型屏幕中，占几列的宽
                 5.列偏移数量
                     每个列都可以指定向右偏移几列的位置
                     .col-xs-offset-n :在xs屏幕下，当前向右偏移n列的位置距离
                     .col-sm-offset-n
                     .col-md-offset-n
                     .col-lg-offset-n
             2.嵌套   .container>.row>.col-*-*>.row>.col-*-*
     		        .col-*-* : 相当于是一个 容器
         11.适用于不同屏幕的列的class(xs/sm/md/lg),可以兼容更大的屏幕
                 col-xs-6 : 在 超小 屏幕中占6列宽
                 col-lg-5 : 在 大型 屏幕中占5列宽
                 .col-xs-* : 适用于 xs/sm/md/lg
                 .col-sm-* : 适用于 sm/md/lg
                 .col-md-* : 适用于 md/lg
                 .col-lg-* : 适用于 lg
             注意：大屏幕的内容不能够兼容小屏幕的，所以大屏幕的内容放在小屏幕中显示占100%(即纵向排列)
         12.可以在一个div中，指定在不同屏幕下的宽度占比
     		<div class="col-xs-12 col-sm-6 col-md-3 col-lg-2"></div>
                 在 xs 中占12列的宽(一行中只能显示一列)
                 在 sm 中占6列的宽(一行中能显示2列)
                 在 md 中占3列的宽(一行中能显示4列)
                 在 lg 中占2列的宽(一行中能显示6列)
         13.指定列在特定屏幕下不显示
                 .hidden-lg : 在 lg 下隐藏
                 .hidden-md : 在 md 下隐藏
                 .hidden-sm : 在 sm 下隐藏
                 .hidden-xs : 在 xs 下隐藏
         14.全局样式 - 表单
             Bootstrap中，表单控件会属于某个表单控件小组(form-group),表单小组中，允许包含：1、label 2、表单控件 3、提示文本(可选)
             1、表单控件小组
                 .form-group : 定义表单控件组 （包裹表单的最外层div的class）
             2、表单控件
                 .form-control : 定义表单控件基本样式(checkbox ,radio 除外)  （用在input后的class里）
             3、标签(label)
                 .control-label : （用在label后的class里）
             4、提示文本(可选)
                 .help-block : 定义提示文本的样式  （一般用在span后的class里）
         15.表单分类：
                 1、默认表单
                    <form>
                      <div class="form-group">
                        <label class="control-label">用户名</label>
                        <input class="form-control">
                        <span class="help-block">字母数据下划线3~8位</span>
                      </div>
                    </form>
                 ex:<div class="container">
                      <form action="#">
                        <div class="form-group">
                          <lable for="uname" class="control-label">用户名</lable>
                          <input type="text" id="uname" class="form-control">
                          <span class="help-block">字母数字下划线3-8位</span>
                        </div>
                        <div class="form-group">
                          <label for="upwd" class="control-label">密码</label>
                          <input type="text" id="upwd" class="form-control">
                          <span class="help-block">字母数字下划线3-8位</span>
                        </div>
                        <div class="form-group">
                          <div class="checkbox">
                            <label><input type="checkbox"/>七天免密登录</label><!--此功能最好不做-->
                          </div>
                        </div>
                        <div class="form-group">
                          <input type="text" value="登录" class="btn btn-success">
                          <input type="text" value="取消" class="btn btn-danger">
                        </div>
                      </form>
                    </div>
                 2、行内表单
                 <form class="form-inline">
                       <div class="form-group">
                         <label  class="sr-only">用户名</label>
                         <input class="form-control"/>
                       </div>
                 </form>
                 ex:<div class="container">
                      <form action="#" class="form-inline">
                        <div class="form-group">
                          <label for="uname2" class="sr-only">用户名</label>
                          <input type="text" placeholder="请输入用户名" id="uname2" class="form-control">
                        </div>
                        <div class="form-group">
                          <label for="upwd2" class="sr-only">用户名</label>
                          <input type="password" placeholder="请输入密码" id="upwd2" class="form-control">
                        </div>
                        <div class="form-group">
                          <input type="button" value="登录" class="btn btn-success">
                        </div>
                      </form>
                     </div>
                 3、水平排列的表单(小难点)
                     	        默认栅格系统	水平表单
                     最外层元素	div.container	form.form-horizontal
                     行	        div.row	        div.form-group
                     列	        div.col-*-*	    div.col-*-*
                    <form class=" form-horizontal ">
                        <div class="form-group">
                           <div class="col-*-*"></div>
                        </div>
                    </form>
                     ex:<div class="container">
                          <form action="#" class="form-horizontal">
                            <div class="form-group">
                              <div class="col-sm-2">
                                <label for="uname3" class="control-label">用户名</label>
                              </div>
                              <div class="col-sm-5">
                                <input type="text" class="form-control" value="用户名" id="uname3">
                              </div>
                              <div class="col-sm-5">
                                <span class="help-block">字母数字下划线3-8位</span>
                              </div>
                            </div>
                          </form>
                        </div>
         16.组件-下拉菜单
             1、外层元素 必须是 .dropdown 或 position:relative
             2、内层
                 1、触发元素
                     由 <button> 或 <a>
                     class="dropdown-toggle"
                     data-toggle="dropdown" : 轮流切换菜单的显示和隐藏
                 2、菜单
                     由 <ul> 或 <div>
                     class="dropdown-menu"
                     li.divider : 分割线
                     li.disabled : 禁用菜单项
                     li.dropdown-header : 标题
                 ex:<div class="dropdown">
                      <a href="#" data-toggle="dropdown">名表</a>
                      <ul class="dropdown-menu">
                        <li><a href="#" class="dropdown-header">名表系列</a></li>
                        <li><a href="#">电子表-小猪佩奇</a></li>
                        <li><a href="#">石英-小猪乔治</a></li>
                        <li><a href="#">金表-120斤</a></li>
                        <li><a href="#" class="dropdown-header">电话系列</a></li>
                        <li><a href="#">小天才</a></li>
                        <li><a href="#">小猪</a></li>
                        <li><a href="#">小猪小妹</a></li>
                      </ul>
                    </div>
             3、组件-导航(非导航条)
                 1、所有的导航都依赖于 .nav
                 2、导航分类
                     1、标签页式导航
                     <ul class="nav nav-tabs">
                         <li>
                             <a href="#">...</a>
                         </li>
                     </ul>
                     2、胶囊式导航
                     <ul class="nav nav-pills"></ul>
                 3、实现点击切换效果
                 <li>
                     <a data-toggle="tab">...</a>  （有下拉菜单的不能切换显示）
                 </li>
             ex:<div class="container">
                <h1>导航-标签</h1>
                  <ul class="nav nav-tabs">
                    <li><a href="#" data-toggle="tab">十元套餐</a></li>
                    <li class="active"><a href="#" data-toggle="tab">二十元套餐</a></li>
                    <li><a href="#" data-toggle="tab">三十元套餐</a></li>
                  </ul>
                <h1>导航-胶囊</h1>
                  <ul class="nav nav-pills">
                    <li><a href="#" data-toggle="tab">十元套餐</a></li>
                    <li class="active"><a href="#" data-toggle="tab">二十元套餐</a></li>
                    <li><a href="#" data-toggle="tab">三十元套餐</a></li>
                  </ul>
                </div>
             4、组件-图标字体(glyphicon)
                 Web项目中常用的图标字体
                   (1)FontAwersome-675个免费图标
                   (2)Glyphicons-800个收费图标
                   服务器端使用字体方法
                   (1)服务器端保存字体文件
                   (2)css中声明一个新的字体，并指定字体文件下载位置(??)
                    @font-face {
                     font-family: 'Glyphicons Halflings';
                     src: url('../fonts/glyphicons-halflings-regular.eot');
                    }
                   (3)css指明一个基础class,使用该字体
                    .glyphicon{
                      font-family: 'Glyphicons Halflings';
                     }
                   (4)在html页面上输入图标对象unicode码
                    .glyphicon-music:before {
                     content: "\e002";
                    }
                 使用方法：
                     1、创建一个元素，必须保证为空
                     2、class="glyphicon glyphicon-*"  （*为文档中查找的图标名称）
             6、组件-按钮组，将多个按钮放在一个组中(btn-group)
                 1、基本按钮组
                     <div class="btn-group">
                         <button>
                     </div>
                 2、将一组 .btn-group 组合进一个 .btn-toolbar(按钮工具栏)
                 3、按钮组的尺寸
                     为 .btn-group 增加 .btn-group-*类设置尺寸
                         .btn-group-lg : 超大号
                         .btn-group-sm : 小号
                         .btn-group-xs : 超小号
                 4、按钮组可以嵌套
                 5、两端对齐按钮组
                     .btn-group .btn-group-justified
                 6、垂直显示的按钮组
                     .btn-group-vertical
             7.组件
                 面包屑：ul.breadcrumb
                 数字翻页条：ul.pagination
                 前后页分页条：ul.pager
                 新闻前彩色标签：ul>li>span.label label-default/success/warning/info/primary...
                 徽章（收件箱后数字统计）：ul>li>span.badge
                 巨幕（大段文字后背景）：div.jumbotron(里头包含文字标签)
                 页头（页眉下有横线）：div.page-header(里头包含文字标签)
                 水井（与巨幕很像的有文字背景）：div.well
                 进度条：条上有字但无斜线装饰的：
                         ex:  <div class="progress">
                                <div class="progress-bar progress-bar-primary" style="width:10%">
                                  10%
                                </div>
                              </div>
                         条上有字且有斜线装饰的：
                         ex:<div class="progress">
                                <div class="progress-bar progress-bar-success progress-bar-striped" style="width:40%">
                                  20%
                                </div>
                              </div>
                         条上无字：
                         ex:<div class="progress">
                              <div class="progress-bar progress-bar-success progress-bar-striped" style="width: 40%">
                              </div>
                            </div>
             8、组件-警告框(alert) 所有的警告框都依赖于 .alert  （可以关闭的警告框）
               <div class="alert alert-四种颜色">
                 <span class="close" data-dismiss="alert">X</span>
                 <p>...</p>
               </div>
                 1、警告框中的连接  <a class="alert-link"></a>
                 2、允许关闭的警告框
                     1、元素必须依赖于 alert-dismissible
                     2、激发关闭的元素 data-dismiss="alert"
                     ex:<div class="alert alert-danger alert-dismissible">
                          <button type="button" class="close" data-dismiss="alert">&times;</button>
                            Lorem ipsum dolor sit amet, consectetur adipisicing elit.
                          <p>点击<a href="#" class="alert-link" data-dismiss="alert">这里</a>实现关闭</p>
                        </div>
             9、组件-缩略图(thumbnail)（类似于dl列表的图文结合形式）
                 1、基本缩略图 .thumbnail
                   <div class="thumbnail">
                      <img src="x.jpg" />
                      <div class="caption">....</div>
                   </div>
                   ex:<a href="#" class="thumbnail">
                        <img src="images/1.jpg">
                      </a>
             10、组件-媒体对象(media)  (左边或右边有图，后面文字段落，一般出现在书评，影评)
               <div class="media">
                 <div class="media-left">img</div>
                 <div class="media-body">p/div</div>
                 <div class="media-right">img</div>
               </div>
                 ex:div.media>(div.media-body>h*.media-heading+p)+(div.media-left/right>a>img.mdid-object)
             11、组件-列表组(list-group)  （博客左边的列表介绍）
                 ul.list-group>li.list-group-item
             12、面板
                 <div class="panel panel-default/success/">
                     <!-- 面板头部(可选) -->
                     <div class="panel-heading">头内内容
                         <h3 class="panel-title">标题元素</h3>
                     </div>
                     <!-- 面板主体(必有) -->
                     <div class="panel-body">...</div>
                     <!-- 面板底部(可选) -->
                     <div class="panel-footer">...</div>
                 </div>
             13、组件-导航条(navbar)
                 1、基本导航条                         响应式导航条
                     1、向 nav 元素添加
                         .navbar .navbar-default
                         必须要包含一个容器(.container/.container-fluid)
                     2、向 navbar的容器中 添加 div.navbar-header,允许包含 a.navbar-brand 元素（一直显示给用户看的div.navbar-header>a.navbar-brand）
                     3、允许向导航条中添加链接列表，需要添加 .nav , .navbar-nav 两个类  （.navbar-toggle>span.icon-bar）
                 2、导航条中的表单
                     导航条中的表单不适用于bootstrap中的默认类
                     使用的时候，需要为表单添加 .navbar-form 来实现表单效果
                     可以通过 navbar-right / navbar-left 来调整格式
                 3、导航条中的按钮
                     .navbar-btn 允许向不在form中的按钮增加样式
                 4、导航条中的文本
                     .navbar-text 保证文本的格式
                 5、导航条内容对齐方式
                     允许添加 .navbar-left 实现左浮动
                     允许添加 .navbar-right 实现右浮动
                 6、实现导航固定
                     让导航条一直都在可视化区域中
                     固定在页面顶端：.nabvar-fixed-top
                     固定在页面底端：.navbar-fixed-bottom
                     注意：最好为body设置至少 50px 的内边距
             14.Bootstrap基于jQuery提供十几个插件函数(bootstrap.js)
                调用方法两种
                (1)js编码方法
                  $(".dropdown>a").dropdown();
                (2)data扩展属性方法
                  <a data-toggle="dropdown"></a>
                   <a data-toggle="collapse" href="#my-target">展开/收起</a>
                   <button data-toggle="collapse" data-target="#my-target ">展开/收起</button>
                   <div id="my-target" class="collapse in">
                     内容
                   </div>
                  折叠插件本身比较简单，但有重要用途
                  手风琴 = 多个面板+多个折叠插件
             15、JS插件 - Plugins
                     Bootstrap提供了一组行为(对元素操作的动作，如：下拉菜单，导航列表内容切换)
                     Bootstrap 提供的行为 基于 jQuery(Javascript 框架/库)，并且在 jQuery 的基础上提供了 十几个插件函数,每个函数都是一个独立的JS文件，可以一次性引入全部的JS操作 - bootstrap.js
                     每个插件函数都有两种调用方式：
                     1、data-*
                         <a data-toggle="dropdown">
                         <a data-dismiss="alert">
                     2、JS编程方式
                         手动编写JS代码完成行为的调用
                         <script src="jquery.js">
                         <script src="bootstrap.js">
                         <script>
                             $("选择器") : 在Javascript中获取指定选择器所对应的元素
                                 $("#nav"):获取 页面 id为nav的元素
                                 $(".container"):获取页面class为container的元素
                                 $("div p"):
                         </script>
                     3、JS插件-工具提示
                         为元素添加
                             data-toggle="tooltip" /*鼠标移入的行为*/
                             title="提示的文本";
                             data-placement="top/right/bottom/left"
                             ex:<button type="button" class="btn btn-danger" data-toggle="tooltip" title="让你碰你就碰啊!"
                                data-placement="bottom">碰我试试!!!
                                  </button>
                         必须配合 JS 代码
                             $("选择器").tooltip();
                             ex:$("[data-toggle='tooltip']").tooltip();
                     4、JS插件-弹出框
                         为元素添加
                             data-toggle="popover";/*指定弹出框打开方式*/
                             data-placement="top/right/bottom/left";
                             title="弹出框标题";
                             data-content="弹出框内容";
                             ex:<button type="button" class="btn btn-success" data-toggle="popover"
                                data-placement="right" title="你点我" data-content="让你点你就点啊！！！">点我试试!!!</button>
                         必须配合 JS 代码
                             $("选择器").popover();
                             ex:$("[data-toggle='popover']").popover();
                     5、JS插件-标签页(tab)
                         标准的标签页分为两部分组成
                         1、标签导航部分  <ul class="nav nav-tabs"></ul>
                             a 标记属性
                                 1、data-toggle="tab"
                                 2、href="#显示内容的ID"
                         2、内容部分  <div class="tab-content"></div>
                             1、class 必须为 tab-content
                             2、在内容组中 增加对应显示的内容模块（与导航要对应）
                                 1、class = tab-pane
                                 2、id 提供给关联的标签导航的a元素
                             ex:<ul class="nav nav-tabs">
                                      <li class="active">
                                        <a href="#tab1" data-toggle="tab">三国演义</a>
                                      </li>
                                </ul>
                                <div class="tab-content">
                                      <div class="tab-pane active" id="tab1">
                                        <div class="well">
                                          <h3>三国演义具体内容</h3>
                                          <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit.</p>
                                        </div>
                                      </div>
                     6、模态对话框:模态对话框组成的两部分（点击按钮或者链接可以弹出的对话框，可以关闭）
                         1、触发元素:通常由 a / button 组成
                             <a data-toggle="modal" href="#modal的ID"></a>
                             <button data-toggle="modal" data-target="#模态框ID"></button>
                         2、模态框元素(例子见：Bootstrapday04-ex.html) model一般放在container上面或者下面，不再里面
                             //class="modal" , 提供了半透明的遮罩层
                             //data-backdrop:必须通过关闭按钮才能关闭模态框
                             <div id="" class="modal" data-backdrop="static">
                                 //class="modal-dialog"，提供了内容区域宽度，高度，定位
                                 <div class="modal-dialog">
                                     //class=modal-content，提供了，背景，边框，倒角，阴影
                                     <div class="modal-content">
                                         <div class="modal-header"></div>
                                         <div class="modal-body"></div>
                                         <div class="modal-footer"></div>
                                     </div>
                                 </div>
                             </div>
                     7、轮播图
                            1.轮播
                            div.carousel+slide  轮播data-ride="carousel"
                              div.carousel-inner
                                div.item+active
                                  img
                            2.时间
                            div.carousel .slide 轮播data-ride="carousel" data-interval="（**）ms单位"
                            3.说明文本
                            div.carousel+slide 轮播data-ride="carousel"
                               div.carousel-inner
                                 div.item+active
                                   img
                                   div.carousel-caption>h*(标题)+p（文本）
                            4.左右方向箭头
                             id="mycar" div.carousel .slide 轮播data-ride="carousel"
                                  div.carousel-inner(里面包含图片类)
                                  a.carousel-control+left/right  data-slide="prev/next"  href="#mycar"
                                     span.glyphicon glyphicon-chevron-left/right
                                  a......right
                            5.带圆点导航轮播
                            id="macar"div.carousel .slide 轮播data-ride="carousel"
                                ul.carousel-indicators(与a平级)
                                    li data-target=#carousel的ID  data-slide-to="0~n" class=active
                            ex:<div class="container">
                               <h1>轮播广告</h1>
                                   <div class="carousel" data-ride="carousel">
                                       <div class="carousel-inner">
                                           <div class="item active"><img src="img/banner1.png"></div>
                                           <div class="item"><img src="img/banner2.png"></div>
                                           <div class="item"><img src="img/banner3.png"></div>
                                           <div class="item"><img src="img/banner4.png"></div>
                                       </div>
                                   </div>
                               </div>
                               <h1>稍复杂的轮播</h1>
                               <div class="container">
                               <div class="carousel slide" data-ride="carousel" data-interval="1500" data--pause="null">
                                   <div class="carousel-inner">
                                       <div class="item active"><img src="img/banner1.png"></div>
                                       <div class="item"><img src="img/banner2.png"></div>
                                       <div class="item"><img src="img/banner3.png"></div>
                                       <div class="item"><img src="img/banner4.png"></div>
                                   </div>
                               </div>
                               </div>
                               <h1>带广告序号和上下页的指示器</h1>
                               <div class="container">
                                   <div id="ad6" class="carousel slide" data-ride="carousel">
                                       <div class="carousel-inner">
                                           <div class="item active"><img src="img/banner1.png"></div>
                                           <div class="item"><img src="img/banner2.png"></div>
                                           <div class="item"><img src="img/banner3.png"></div>
                                           <div class="item"><img src="img/banner4.png"></div>
                                       </div>
                                       <a href="#ad6" class="carousel-control left" data-slide="prev">
                                           <span class="glyphicon glyphicon-chevron-left"></span>
                                       </a>
                                       <a href="#ad6" class="carousel-control right" data-slide="next">
                                           <span class="glyphicon glyphicon-chevron-right"></span>
                                       </a>
                                       <ul class="carousel-indicators">
                                           <li data-slide-to="0" data-target="#ad6" class="active"></li>
                                           <li data-slide-to="1" data-target="#ad6"></li>
                                           <li data-slide-to="2" data-target="#ad6"></li>
                                           <li data-slide-to="3" data-target="#ad6"></li>
                                       </ul>
                                   </div>
                               </div>
         折叠效果：
         class=.panel-collapse .collapse 可以放在panel-body和panel-footer外面，用panel-headding来做控制折叠效果
            ex:<div class="container">
                 <div class="panel">
                     <div class="panel-heading">
                       <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#pnl">好东西</button>
                     </div>
                     <div class="collapse panel-collapse" id="pnl">
                       <div class="panel-body">
                         <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit.</p>
                       </div>
                       <div class="panel-footer">
                         <button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#pnl">关闭</button>
                       </div>
                     </div>
                 </div>
               </div>
     
     
               <div class="panel-group" id="pnl000">
               触发元素上加： data-parent="#pnl000"
     ===================================================Bootstrap 定制 & Less================================================
     1、Less语言
     	官网：http://lesscss.org
     	中文网：http://less.bootcss.com
     	Less是一个 CSS预处理语言，它扩充了CSS，在静态的CSS基础上增加了一部分动态内容 如：变量，混合(Mixin),Less中完全支持和兼容CSS
     	在Web中使用Less的两种方式:
     	1、在客户端浏览器中编译Less - 不推荐
     		1、编写 xx.less 文件
     		2、编写 xx.html , 引入 xx.less同时引入编译文件 less.js
     		3、浏览器在访问 xx.html 会自动下载 xx.less 和 less.js，然后在客户端进行编译
     2、在服务器端编译 Less - 推荐
     		1、编写 xx.less
     		2、在服务器端搭建Less编译器，将 xx.less 编译成 xx.css
     		3、编写 xx.html 直接引入 xx.css 即可
     3、搭建Less编译器 (乱点)lesscss.cn---官网
     	Less编译器由JS进行编写的
     	1、安装独立的JS解释器 - NodeJS
     		命令行中：执行 node -v 结果为：0.12.4 或 4.4.7
     	2、安装 Less 编译器程序
     		lessc.cmd 文件存在即可
     	3、将 Less 转换为 CSS
     		控制台中 找到 lessc.cmd 的位置
     		输入：
     			lessc.cmd D:\1.less > D:\1.css
     	4、在WebStorm中，配置FileWatchers(文件监视器)
     		由WS自动检测Less文件的编写与更改，自动进行编辑得到CSS
     		Ws-->File-->Settings-->Tools-->FileWatchers --> 添加 选择Less --> 指定 lessc.cmd文件地址即可
     4、Less语法
     	1、Less 完全支持 CSS语法
     	2、Less 支持单行注释 和 多行注释，只有多行注释能被编译到CSS中
     		单行：// 注释内容
     		多行：/*   */
     	3、Less 支持 变量(Variable)
     		变量：在Less中表示的是一个可以变化的数据
     		语法：
     			@变量名:值;
     			变量名：英文，数字，_,-并且不要以数字开头
     			ex:
     				1、@jd_color:#e4393c;
     				2、@border_width:3px;
     				3、@base-font:"微软雅黑";
     				4、@border:1px solid #000;
     	4、Less 中变量允许使用运算符
     		+,-,*,/,%
     		ex:5%2=1
     	5、Less 中支持 在一组样式中 混入(Mixin) 另一组样式
     		选择器1{ ... }
     		选择器2{  ... ;选择器1; ...}
     		最终：选择器2中 包含 选择器1 定义好的样式
     	带参数的混合
     		声明选择器的时候，允许使用 "参数" 来表示暂时不确定的数据，在最终 混入的时候，将确定的数据传递进来
     		语法：
     			选择器1(@参数名){
     				border:@参数名 solid #ff6500;
     			}
     			带多个参数
     			选择器3(@参1,@参2,@参3){
     				border:@参1 @参2 @参3;
     			}
     		使用 带参数的混合写法
     			选择器2{
     				选择器1(值);
     			}
     	6、嵌套规则
     		在 less 中，允许在一个选择器内再声明另一个选择器，以便完成子代选择器 或 后代选择器
     		选择器1{//生成：选择器1{}
     			...;
     			...;
     			选择器2{ //生成：选择器1 选择器2{}
     				...;
     				...;
     			}
     			>选择器3{//生成：选择器1>选择器3{}
     				...;
     				...;
     			}
     		}
     	7、函数
     		1、杂项函数
     			1、image-width('URL')
     			2、image-height('URL')
     		2、颜色定义函数
     			1、rgba(red,green,blue,alpha)
     		3、颜色操作函数
     			1、darken(color,num%)
     				background-color:darken("#e4393c",20%)
     			2、lighten(color,num%)
     		4、数字相关
     			1、ceil(@num)
     				对数字向上取整
     				ex
     					ceil(123.456789)
     					结果为：124
     			2、floor(@num)
     				对数字向下取整
     				ex
     					floor(123.456789)
     					结果为：123
     	8、@import 功能
     		在 Less 中，@import 用于在服务器端将多个less文件中的内容整合到一个Less文件中
     		语法：
     			xx.less 文件中
     				@import "xxx.less";
     
     =======================================================Nodejs============================================================
     1.概述:
         NODEJS不是JS,是一种服务器端技术，它竞争对手是php/jsp/asp.net
         官网:www.nodejs.org
         版本:0.12(16初) 4.x(16年中) 6.x(16年底)
         09开发 16年 io密集型
         LTS:Long Term Support 长期稳定支持版本
         https://npm.taobao.org/mirrors/node----------阿里巴巴镜像网站
         ****************netstat -an  命令窗口查找是否监听端口被占用
         “' or 1=1 #”   “' or 1=1 :select into ”
     2.JS和NODEJS区别
         1.JS运行于客户端浏览中，存在兼容性问题;数据类型：值类型+引用类型(ES+DOM+BOM+自定义);
         2.NODEJS运行服务端(V8),不存在兼容性问题,数据类型:值类型+引用类型(ES+扩展对象+自定义);
             Current:最新版本
     3.安装与使用
          node-v6.10.2-x64.msi  windows 64位
          node-v6.10.2-x86.msi  windows 32位
             鼠标右击->我的电脑->属性-> 64位
     4.两种运行模式
         1)交互模式--一般用于临时测试
                 REPL:输入一行代码执行一行--Read Evaluate Print Loop
                 操作步骤：
                     cmd窗口：1.node -v      2.node 回车   3.退出：ctrl+c(输入两次，退出交互模式)
         2)脚本模式--正式项目中使用方式
                把要执行所有语句编写成一个文本文件，(后缀名任意,没有都行),一次性提交
                  node解释器执行
                  node  完整路径名/x.js 回车  -------ex:node e:/x.js
     5.运算符
         算术运算符  +-*/。。。
         比较运算符  大于  小于。。。
         逻辑运算符  与 或 非
         位运算符
         三目运算符 ？：
         赋值运算符 += -= *= /=
         特殊运算符 .typeof（数据类型） .instanceof（实例化）
     6.逻辑结构 if..else  switch..case
         循环结构：  while  do while  for  for of  for in
         选择结构：
     7.通用小程序
         九九乘法表，100以内的质数，数组排序..
          练习:打印出100以内所有质数
          练习:7.js
     8.函数和对象
     9.常用的组件，第三方工具，框架
     10.nodejs模块
         1.一个web项目功能可以分不同"模块",如商品模块，用户管理模块，支付模块，商家管理...
         2.nodejs按照功能把不同函数，对象分到不同文件/目录,nodejs模块 "Module" user product manager
         3.每个模块可以使用自己函数 require()
          函数引入另一个模块--底质本质就是创建指定模块一个对象实例.
             require("./模块文件名");
                练习:
                  8_module_user.js 声明变量 创建函数
                  9_app.js
         4.每个模块可以使用exports对象向外公开(导出)一些自己内部成员其它模块使用.
             exports.成员名 = 成员值;
             require("./模块名称");
                 练习1:创建文件模块 10_Circle.js
                  其中定义常量PI,声明一个方法getSize(r)
                  根据传入圆形半径，返回面积;
                  以及一个方法getPerimeter(r)
                  根据传入圆形半径返回其周长;
                  再创建一个应用主模块 11_app.js
                 引用 10_Circle.js,调用其公开两个成员方法
                 练习2:编写模块12_ArrayUtil,包含一个方法
                      sum(arr),返回指定数组中所有数值的和,
                      一个方法 avg(arr)返回指定数组中中所有
                      数值平均值,使用 module.exports导出上述二个成员.
                      13_app.js 模块引入 12_ArrayUtil,
                      调用其公开方法.
         5.NODEJS模块系统原理：
             1.NODEJS中每一个.js文件都是一个"Module",每个模块可以引入其它的模块;也可以导出自己的成员供其它模块来使用.
             2.NODEJS中的每一个模块都是一个独立构造函数，解释器会为每个.js文件添加如下代码.
                 (function(exports,require,module,__filename,__dirname){
                      var age = 20;
                      var stop = function(){
                 }
                 exports.age = age;
                 module.exports.stop = stop;
                 })
         6.nodejs中模块分类
             1.nodejs官方提供原生模块- require("模块名")
             2.第三方编写模块(mysql/oracle/..)
             3.用户自定义模块
                 exports.x    require("./模块名称");
             4.node预定模块 - Global
                 该模块提供可以直接使用,而无需require()
                 示例：
                     14.js
         7.nodejs官方提供原生模块：(fs,querystring,url,buffer,http)
             1.fs-->重点
                 file(文件)：fs模块提供对文件系统中文件/目录增删改查、读写功能.
                 1.同步读取写入文件方法(API) 等待
                     1.同步读取文件中内容
                         const fs =  require("fs");
                         var data = fs.readFileSync(file);
                     2.同步向文件中写出内容(删除己有内容)
                         fs.writeFileSync(file,str/buf);
                     3.同步向文件中追加写入内容(不删除己有内容)
                         fs.appendFileSync(file,str/buf);
                         15_fs.js
                         16_fs.js
                         17_fs.js
                 2.异步读取写入文件方法(API) 不等待
                     1.异步读取文件的内容
                         fs.readFile(file,function(err,data){})
                     2.异步写文件的内容
                         fs.writeFile(file,data,function(err){})
                         提示:后续的项目中，文件读写可以同步或异步，但推荐使用异步方法--最大限度发挥nodejs优势.
                     3.异步追加内容
                         fs.appendFile('./public/user.do',data,(err)=>{
                             res.send("<h1>注册成功</h1>");
                         }
             2.querystring
                 querystring模块用于处理HTTP请求URL中查询字符串
                     var obj = qs.parse(str)      把查询字符串解析js对象
                     var str = qs.stringify(obj)  把js对象转换为查询字符串
             3.url
                 1.url模块用于解析一个http请求地址，获取其中各个不同部分。
                     var obj = url.parse(str);   把一个URL字符串解析为js对象---query解析为字符串
                     var obj = url.parse(str,true); 把一个URL字符串解析为js对象，并把其中查询字符串也解析为对象.---解析为对象
                 2.练习:仿写NODEJS提供一个模块:URL
                     创建模块文件myurl 向外导出一个方法resolve(url),该方法接收参数形如下:
                         http://www.jd.com:80/ad/index?uname=qiangdong
                     返回对象：形如
                         {
                         protocol:'http',
                         hostname:'www.jd.com',
                         port:80,
                         url:"/ad/index?uname=qiangdong"
                         }
                     再编写一个主模块，引入上述模块并调用.
             4.Buffer
                 Buffer:缓冲区本质是一块内存区域，用于暂存以后要用到的数据(可能数字，字符串，图片，音频，视频)，该区域称为“缓存”。
                         buffer预定义模块无需加载
                     1.分配一个指定大小缓冲区  {1024单位字节}
                        var buf1 = Buffer.alloc(1024);
                     2.使用一个数字数组创建缓冲区
                        var buf2 = Buffer.from([1,3,5]);
                     3.使用一个字符串创建一个缓冲区
                        var buf3 =  Buffer.from('abcde');
                     4.把一个缓冲区中数据转字符串
                        var str = buf3.toString();
             5.http-->重点
                 1.HTTP模块可用于编写基于HTTP协议客户程序(即浏览器)，也可以编写基于HTTP协议的服务器程序(即web服务器)
                 2.用http模块编写一个web服务器
                     1.接收客户端http请求消息
                     2.解析客户端请求消息
                     3.读取客户端请求文件
                     4.向客户端发送HTTP响应消息，主体就是客户端请求文件.
                         const http = require("http");
                         var server = http.createServer();
                         server.listen(8080);
                         server.on('request',function(request,response){
                          request   请求消息
                          response  响应消息
                         });
                 3.练习:NodeJS创建一个web服务器，根据客户请求的地址不同，输出不同html页面内容,如
                         http://127.0.0.1:8080/login.html
                     服务器应该返回 ./public/login.html 中读内容
                         http://127.0.0.1:8080/news.html
                     服务器应该返回 ./public/news.html 中读取内容
                     若请求资源在public目录不存在,则返回404响应消息.
         8.第三方编写模块(mysql)
             1.使用nodejs访问mysql服务器
                 1.说明：为了精简nodejs解释器，官方没有提供访问任何数据库相关的模块，必须使用npm工具下载第三方模块.
                 2.使用npm工具下载mysql(www.npmjs.org 搜索关键字)
                 3.NPM 包管理器-了解
                     1.Node Package Manager Node.js的第三方模块/包管理器，可用于下载，更新，删除，维护依赖关系的工具。
                     2.npm工具默认到www.npmjs.org网站下载所需的第三方模块包
                     3.在node命令窗口输入：
                           npm install    包名(示例:npm i mysql--->下载mysql模块)
                           npm uninstall  包名
                 4.mysql模块的使用步骤
                     1:创建到mysql数据库的连接
                         const mysql = require("mysql");
                         var conn = mysql.createConnection({
                           host:'127.0.0.1',
                           user:'root',
                           password:'',
                           database:'jd',
                           port:3306
                           });
                     2:发送sql语句
                         conn.query("SQL",function(err,result){
                             3:关闭连接--------------非阻塞，此步骤放入其中
                             conn.end();
                         });
     
             2.Express框架
                 1.使用说明：
                       使用官方提供http模块可以创建一个web服务器应用,但是此模块非常底层，要处理各种情形,比较繁琐。
                       推荐使http 模块进一步封装简化模块--express.
                       第三方模块，是一个基于nodejs的http模块而编写高层模块,简化web服务端应的开发,
                       express是一个请求处理工具，用于接客户端请求消息，返回响应消息.
                       可以到 npmjs.org上下载该模块
                       该模块还有自己专用官网: http://expressjs.com
                       中文镜像网站:         http://www.expressjs.com.cn
                 2.使用方法
                       1.下载 express模块----www.expressjs.com.cn(官网)
                         npm i express
                       2.在自己的模块中引入express模块
                         const express = require("express");
                       3.使用 http 模块创建一个 web服务器对象，让
                         express()担当请求处理函数.
                         var app = express();
                         var server = http.createServer(app);
                         server.listen(8080);
                 3.使用Express处理客户端GET请求
                       app.get(url,(req,res)=>{
                            res.send("向客户端返回html字符串响应");
                            res.sendFile(绝对路径__dirname/客户端输出指定文件内容);----------------必须是绝对路径（__dirname+"/login.html"）
                            res.json(obj);//将obj转换json字符串,输出客户端,并修改响
                                      //应头
                       });
                     练习一:使用express创建一个web服务器,可以向客户提供一个/index响应，
                           内容是一个index.html，其中还使用一个css文件,一个图片jquery.js文件
                               <html>
                                   <head>
                                       <link ... href="/index.css" />
                                   </head>
                                   <body>
                                       <img src="/logo" /> <script src="/jquery"></script>
                                   </body>
                               </html>
                           接收GET请求中的查询字符串
                                GET /user?uid=10&loc=bj
                                app.get("/user",(req,res)=>{
                                 #express为每个req对象添加query 属性
                                 console.log(req.query.uid);
                                 console.log(req.query.loc);
                               });
                           接收GET请求中的请求参数
                                GET /user/jsj/60
                                app.get("/user/:type/:id",(req,res)=>{
                                    #express为每个req对象添加一个params属性
                                    console.log(req.params.type);//jsj
                                    console.log(req.params.id);
                               });
                 4.使用express处理客户端的POST请求
                    app.post(url,[req,res]=>{})
                         提示:客户端推荐使用ajax异步请求,提交post请求
                    示例:
                        app.post("/user",(req,res)=>{
                         //接收请求主体数据
                         req.on("data",(buf)=>{
                            var obj = qs.parse(buf.toString());
                       })
                       })
                 5.使用express处理客户端的PUT请求
                     app.put(url,(req,res)=>{})
                         提示:客户端推荐使用AJAX异步请求，提交put请求
                     示例:
                        app.put("/user",(req,res)=>{
                         //put 接收请求主体中的数据
                         req.on("data",(buf)=>{
                          var obj = qs.parse(buf.toString())
                       });
                       })
                 6.使用 express处理客户端的delete请求
                        app.delete(url,(req,res)=>{});
         9.用户自定义模块两种形式
             1.文件模块
                  创建一个js文件，如m3.js导出需要公开的数据，其它模块可以require("./m3")模块
             2.目录模块
                 方式1:创建一个目录，假设名为m4,在m4目录中创建名为index.js的文件，
                     导出需要公开数据。其它模块可以require("./m4");
                 方式2:创建一个目录，假设名为m5,其中创建package.json文件，
                     其中声明main属性指定默认执行js文件，如5.js,其中导出需要公开数据。其它模块可以require("./m5");
                 方式3:创建一个目录,必须名node_modules,其中创建目录模块，
                     假设m6,其中创建文件package.json文件,其中声明main属性指定默认执行启动js文件,
                     如：6.js 其中导出需要公开数据，其它模块可以require("m6");
             3.使用方法：
                 exports.x    require("./模块名称");
             4.练习:使用方式3：
                 创建两个目录模块，circle,rectangle，都对外公开两个方法：size()  perimeter()返回指定图形的面积和周长
                 circle.size(r)
                 circle.perimeter(r)
                 rectange.size(w,h)
                 rectange.perimeter(w,h)
     12.连接池
         为了提升数据库操作性能，nodejs提供完善功能连接池.
             1:创建连接池
                 var pool = mysql.createPool({...})
             2:从连接池中获取连接
                 pool.getConnection((err,conn)=>{
             3: 释放连接，回到连接池
                 conn.release();
             4.示例：
                 const mysql=require("mysql");
                 var pool=mysql.createpool();
                     //用连接池
                 var pool=mysql.createPool({
                   host:'127.0.0.1',
                   user:'root',
                   password:'',
                   database:'jd',
                   connectionLimit:5
                 });
                 pool.getConnection(function(err,conn){
                   if(err){
                     console.log(err);
                   }else{
                     conn.query("select * from jd_dept",function(err,result,fields){
                       console.log(result);
                       conn.release();
                     });
                   }
                 });
     =================================================三大框架===============================================================
     -----------------------------------------------------Vue----------------------------------------------------------------
     错误集锦：
         1. Uncaught ReferenceError: Vue is not defined
           vue.js文件引入错误
         2. Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.
            组件中缺少根标签
     1. 认识框架
         (1) 什么是框架？
             一套解决问题的代码规范，主要应用于项目开发。
         (2) 框架和库的区别
             框架（framework）是基于项目开发，库(library)关注某一个点
         (3) 框架的优点
             提高项目的开发速度
             提高代码的质量
             提高代码的可维护性
         (4) 常用的框架
             Vue     angular     react
     2.Vue概述：
         1.用于构建前端应用的渐进性JavaScript框架，采用的是M V V M的设计模式
             (1) 优势
                 官方手册 https://cn.vuejs.org/
                 学习线路的相对平缓
             (2) 使用
                 ①命令行的方式(cli) command line interface
                     # 全局安装 vue-cli
                     $ npm install --global vue-cli
                     # 创建一个基于 webpack 模板的新项目
                     $ vue init webpack my-project
                     # 安装依赖，走你
                     $ cd my-project
                     $ npm run dev
                 ②script标签引入形式
                      <script src="vue.js"></script>
                      <div id="app"> {{msg}} </div>
                       <script>
                         new Vue({
                            el: '#app',
                            data:{  msg: 'hello'  }
                         });
                       </script>
                 ex:<!--1.引入vue文件-->
                   <script src="js/vue.js"></script>
                   </head>
                   <body>
                   <!--3.指定数据渲染位置-->
                   <div id="app"><!----------view-->
                       {{msg}}<!----双花括号:插值表达式-->
                   </div>
                   <!--2.新创建script标签-->
                   <script>
                   //引入vue文件后，会产生vue构造函数
                       new Vue({//实例化vue对象
                           el:'#app',//指定data数据渲染的区域-----viewModel----即选择器
                           data:{//存放数据-----model
                               msg:"hello world"
                           }
                       });
                   </script>
                   </body>
                   </html>
             (3) MVVM设计模式
                 M   -> model       模型(数据)
                 V   ->view         视图（界面）
                 VM  -> viewmodel  调度者(中间角色)
         2. 插值表达式
             {{ expression }}
         3. 指令:指令是一种特殊的标签属性，以v-开头
             (1) 选择指令
                 v-if="expression"
                 v-else-if="expression"
                 v-else
             ex:<div id="app">
                    <h2 v-if="seen">{{msg}}</h2>
                    <hr>
                    <p v-if="answer=='a'">A 第一种情况</p>
                    <p v-else-if="answer=='b'">B 第二种情况</p>
                    <p v-else-if="answer=='c'">C 第三种情况</p>
                    <p v-else-if="answer=='d'">D 第四种情况</p>
                    <p v-else>E 第五种情况</p>
                </div>
                <script>
                    new Vue({
                        el:'#app',
                        data:{
                            msg:"hello vue",
                            seen:true,
                            answer:'e'
                        }
                    });
                </script>
             (2) 循环指令
                 v-for="(tmp, index) in books"
                 tmp 数组中每一项
                 index  数组中每一项的下标
                 books 要遍历的数组
                 ex:<div id="app">
                        <table >
                            <thead>
                                <tr>
                                    <th>序号</th>
                                    <th>姓名</th>
                                    <th>年龄</th>
                                    <th>性别</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr v-for="(tem,index) in stu" v-if="tem.age>=25">
                                    <td>{{index+1}}</td>
                                    <td>{{tem.name}}</td>
                                    <td>{{tem.age}}</td>
                                    <td>{{tem.gender}}</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <script>
                        new Vue({
                            el: '#app',
                            data: {
                                msg: "hello vue",
                                stu:[
                                    {name:'tom',age:22,gender:'boy'},
                                    {name:'marry',age:25,gender:'girl'},
                                    {name:'james',age:30,gender:'boy'},
                                    {name:'lily',age:32,gender:'girl'}
                                ]
                            }
                        });
                    </script>
             (3) 事件绑定指令
                 1.v-on:click="handleClick('str')"
                    @click="handleClick('str')"
                 2.在vue中的 methods下添加方法
                     methods:{
                        handleClick: function(s){    }
                      }
                     ex: <div id="app">
                             <button v-on:click="handleClick('vue')">按钮1</button>
                             <button @click="handleClick('js')">按钮2</button>
                         </div>
                         <script>
                             new Vue({
                                 el: '#app',
                                 data: {
                                     msg: "hello vue"
                                 },
                                 methods: {//存放所有方法
                                     handleClick:function(str){
                                         alert(str);
                                     }
                                 }
                             });
                         </script>
                 3.事件修饰符
                     stop  停止冒泡        @click.stop
                     prevent 取消默认操作
                     once  指绑定一次
     
                         ex:<div id="app">
                                <a href="http://www.tmooc.cn" @click.prevent>tmooc</a>
                                <div @click.once="divClick" >
                                    <button @click.stop="buttonClick">click me</button>
                                </div>
                            </div>
                            <script>
                                new Vue({
                                    el: '#app',
                                    data: {
     
                                    },
                                    methods:{
                                        buttonClick:function(){
                                            alert('button clicked');
                                        },
                                        divClick:function(){
                                            alert('div clicked');
                                        }
                                    }
                                });
                            </script>
             (4) 属性绑定指令
                 v-bind:src="expression"
                 :src="expression"
                 ex:<div id="app">
                        <a :href="website">tmooc</a>
                        <img v-bind:src="myUrl" alt="">
                        <img :src="'img/'+filename" alt="">
                    </div>
                    <script>
                        new Vue({
                            el: '#app',
                            data: {
                                myUrl:"img/404_img1.png",
                                filename:"404_img1.png",
                                website:"http://www.tmooc.cn"
                            }
                        });
                    </script>
             (5) 双向数据绑定指令
                  v-model="data"
                  前提： 双向数据绑定只能出现在表单中。
                  ex:<div id="app">
                         <input type="checkbox" v-model="bool">是否同意本站协议<br>
                         <button :disabled="!bool">注册</button>
                     </div>
     
                     <script>
                         new Vue({
                             el: '#app',
                             data: {
                                 bool:false
                             }
                         });
                     </script>
             (6) 其它指令
                 插值表达式 {{  }}，不能正常的解析html标签
                 v-html="expression" 会正常解析数据中的html，之前标签中的内容会被覆盖
                 v-text="expression" 不能正常解析html标签，也会覆盖标签之间的内容
                 ex:<div id="app">
     
                        <div v-html="article">原始内容</div>
                        <div v-text="article">原始内容</div>
                    </div>
                    <script>
                     new Vue({
                            el: '#app',
                            data: {
                                msg:"hello",
                                article:`
                                    <h3>昨晚</h3>
                                    <p>交互上</p>
                                `
                            }
                        });
                    </script>
         4. 组件化
             组件是一个可以反复使用的，带有特定功能的视图,组件扩展了html的标签
             1.创建组件：
                 ①全局组件
                     Vue.component('my-top-nav', {
                       template: '<h2>模板中的标签</h2>'
                     })
                     ex:<div id="app">
                            <my-com></my-com>
                        </div>
                        <script>
                            Vue.component('my-com',{
                                template:`
                                         <div>
                                            <h2>这是logo</h2>
                                            <p>这是登录部分</p>
                                            <p>这是注册部分</p>
                                        </div>`
                            });
                            new Vue({
                                el: '#app'
                            });
                        </script>
                 ②局部组件
                     new Vue({
                         el:"#app",
                         data:{
                             msg:"hello"
                         },
                         components: {
                             'my-com': {  template: '<h2></h2>'   }
                         }
                     })
                     ex:<div id="app">
                            <my-com></my-com>
                            <my-com2></my-com2>
                        </div>
                        <div id="app2">
                            {{msg}}
                            <my-com2></my-com2>
                        </div>
                        <script>
                            Vue.component('my-com2',{
                                template:'<h2>这是全局组件</h2>'
                            });
                            new Vue({
                                el: '#app',
                                data: {},
                                methods:{
                                    //所有的方法
                                },
                                components:{//所有的局部组件
                                    'my-com':{
                                        template:'<h2>这是一个局部组件</h2>'
                                    },
                                }
                            });
                            new Vue({
                                el:'#app2',
                                data:{
                                    msg:"hello"
                                }
                            });
                        </script>
             2.调用：
                 <my-top-nav ></my-top-nav >
             3.注意事项：
                 ①组件的命名采用烤串命名的方法
         ********②模板中如果有多组标签，需要添加一个根标签（div, form..）
                 ③注册全局组件一定要写在vue实例化之前
         5. v-if 和 v-show:两者都是用于控制显示与隐藏
             v-if 如果是false，不会渲染到视图中
             v-show 如果是false，就会添加display:none;
             ex:<div id="app">
                    <button @click="bool=!bool">切换</button>
                    <h2 v-show="bool">{{msg}}</h2>
                    <h1 v-if="bool">{{msg}}</h1>
                </div>
                <script>
                    new Vue({
                        el: '#app',
                        data: {
                            bool:true,
                            msg:'hello'
                        }
                    });
                </script>
     作业：分页效果
     <style>
             .current{
                 background: dodgerblue;
             }
         </style>
     </head>
     <body>
     <div id="app">
         <!--<button @click="modifyPage(false)" v-if="curPage>1">上一页</button>--><!--第一种方法-->
         <button @click="modifyPage(false)" :disabled="curPage==1">上一页</button>
         <button v-for="tmp in pageList" :class="{current:tmp==curPage}" @click="getPage(tmp)">{{tmp}}</button>
         <!--<button @click="modifyPage(true)" v-if="curPage<5">下一页</button>--><!--第一种方法-->
         <button @click="modifyPage(true)" :disabled="curPage==5">下一页</button>
     </div>
     <script>
         new Vue({
             el: '#app',
             data: {
                 pageList:[1,2,3,4,5],
                 curPage:1//用来记录当前的页码值
             },
             methods:{
                 getPage:function(p){
                     this.curPage=p;
                 },
                 modifyPage:function(bool){
                     if(bool){
                         this.curPage++;
                     }else{
                         this.curPage--;
                     }
                 }
             }
         });
     </script>
     </body>
     作业：计算器
     ex:<div id="app">
            <form action="#" @submit.prevent="cal">
                <input type="number" v-model="msg"><br>
                <input type="number" v-model="msg2"><br>
                <button >计算</button>
                <br>
                <textarea>{{result}}</textarea>
            </form>
        </div>
        <script>
            new Vue({
                el: '#app',
                data: {
                    msg:0,
                    msg2:0,
                    result:0
                },
                methods:{
                    cal:function(){
                        this.result=parseInt(this.msg)+parseInt(this.msg2)
                    }
                }
            });
        </script>
         6. 自定义指令
             1.创建 Vue.directive('test', {
                     bind: function(el, bindings){
                         //el当前的dom元素，可以js操作
                         //bindings.value 获取传递的参数
                     },
                     inserted: function(el,bindings){
                         //当元素渲染到视图后，执行这个钩子函数
                         el.focus();
                     },
                     update: function(){
                         //当传递的参数数据变化，会执行这个钩子
                     }
             })
             2.调用： <p v-test="1">
             ex:<div id="app">
                    <h2 v-test="'50px'">{{msg}}</h2>
                    <input type="text" v-focus>
                    <h3 v-change="mycolor">hello world</h3>
                    <button @click="changeColor">更新</button>
                </div>
                <script>
                    Vue.directive('test',{
                        //钩子：一些方法或者函数
                        //第一次绑定时调用这个方法
                        bind:function(el,bindings){
                            console.log("绑定成功");
                            console.log(el);
                            console.log(bindings.value);
                            el.style.fontSize=bindings.value;
                        }
                    });
                    Vue.directive('focus',{
                        inserted:function(el,bindings){
                            console.log('渲染到视图中');
                            console.log(el);
                            el.focus();
                        }
                    });
                    Vue.directive('change',{
                        bind:function(el,bindings){
                            el.style.background=bindings.value;
                        },
                        update:function(el,bindings){
                            el.style.background=bindings.value;
                        }
                    });
                    new Vue({
                        el: '#app',
                        data: {
                            msg:"hello",
                            mycolor:'red'
                        },
                        methods:{
                            changeColor:function(){
                                this.mycolor='green'
                            }
                        }
                    });
                </script>
             3.练习：创建一个指令，可以改变文字颜色
             ex:<div id="app">
                    <p v-change-color="'red'">{{msg}}</p>
                    <p></p>
                </div>
                <script>
                    Vue.directive('change-color',{
                        bind:function(el,bindings){
                            el.style.color=bindings.value;
                        },
                    inserted:function(){
                            console.log("渲染到了视图中")
                    }
                    });
                    new Vue({
                        el: '#app',
                        data: {
                            msg:"hello Vue.js"
                        }
                    });
                </script>
         7. 过滤器（管道）
             用于对数据进行筛选，整合，过滤等， 返回一个处理后的数据。
             过滤器的本质，就是一个方法。
             在Vue1.*含有自带的过滤器；
             Vue2.*取消了自带的过滤器，支持自定义过滤器。
             1.创建
                 Vue.filter('myfilter', function(myinput, arg1,..){
                     //myinput是要过滤的数据----即调用中的num
                     // args调用过滤器时，所传递的参数
                     return ...; //把过滤的结果返回
                 });
             2.调用
                 {{num | myfilter('$',...)}}
                 ex:<div id="app">
                        <h2>{{number | myfilter('￥','china')}}</h2>
                    </div>
                    <script>
                        Vue.filter('myfilter',function(myvalue,arg1,arg2){
                            console.log(myvalue);
                            console.log(arg1);
                            return arg1+myvalue+arg2;
                        });
                        new Vue({
                            el: '#app',
                            data: {
                                msg:"hello",
                                number:123
                            }
                        });
                    </script>
             3.练习：
                 1创建一个过滤器，把数据转成大写或者小写, 如果传递的参数是true，转成大写，否则false转成小写
                     {{ msg| trans(false) }} Hello World
                 2 创建一个过滤器，对数据（0 或者 1）进行过滤
                     如果0， 继续判断，如果传递的参数时true，返回中文的男，否则返回英文的 boy;
                     如果1， 继续判断，如果传递的参数时true，返回中文的女，否则返回英文的 girl
                     {{ gender | mygender(true) }}   gender: 0
                     ex:<div id="app">
                            <h1>{{gender | myGender(true)}}</h1>
                            <p>{{msg | trans(true)}}</p>
                            <p>{{msg | trans(false)}}</p>
                        </div>
                        <script>
                            Vue.filter('myGender', function (myValue,bool) {
                                return myValue==1 ? (bool ? '女': 'girl') : (bool ? '男' : 'boy');
                            });
                            Vue.filter('trans', function (myValue,bool) {
                                if(bool) {
                                    //转大写
                                    return myValue.toUpperCase();
                                }else{
                                    //转小写
                                    return myValue.toLowerCase();
                                }
                            });
                            new Vue({
                                el: '#app',
                                data: {
                                    msg: 'Hello Vue',
                                    gender: 1
                                }
                            });
                        </script>
         8. 复合组件
             在一个组件中嵌套其它的组件。
             1.回顾组件创建
                 Vue.component('my-com', {
                     template: '<div>....</div>'
                 })
                 <my-com></my-com>
             2.练习：
                 创建一个复合组件 my-login
                     my-input ( label  input )
                     my-button( button )
                     ex:<div id="app">
                            <my-login></my-login>
                        </div>
                        <script>
                            Vue.component('my-login', {
                                template: `
                                    <form>
                                        <h2>用户登录</h2>
                                        <my-input></my-input>
                                        <my-input></my-input>
                                        <my-button></my-button>
                                    </form>
                                `
                            });
                            Vue.component('my-input', {
                                template: `
                                    <div>
                                        <!--<label>用户</label>-->
                                        <input type="text">
                                    </div>
                                `
                            });
                            Vue.component('my-button', {
                                template: `<button>登录</button>`
                            });
                            new Vue({
                                el: '#app',
                                data: {
                                    msg: 'hello vue'
                                }
                            });
                        </script>
         9. 生命周期函数
             1.初始化 (beforeCreate / created)
                 created后，之后的钩子都可以获取到data中的数据
             2.挂载到视图（beforeMount / mounted）
                 mounted 后，编译的模板内容就会出现在视图中
             3.数据更新( beforeUpdate / updated )
             4.销毁   (beforeDestroy / destroyed)
             5.练习：
                 在组件挂载到视图后，创建一个周期性的定时器，实现组件中h1标签，透明度 0~1(+0.1) 透明动画效果
                     ① 使用mounted钩子函数（生命周期函数）
                     ② 前提是已经创建了组件 （组件的创建）
                     ③ 把数据绑定给opacity属性（属性绑定）
                         ex:<div id="app">
                             <my-com></my-com>
                            </div>
                            <script>
                             Vue.component('my-com',{
                                 template:`
                                     <div>
                                         <h1 :style="{opacity:myOpacity}">life circle study</h1>
                                         <button @click="stop">停止</button>
                                     </div>
                                 `,
                                 data:function(){--------------------组件中data必须用函数表达，并返回值
                                     return {
                                         myOpacity:0,
                                         myTimer:null
                                     }
                                 },
                                 methods:{
                                     stop:function(){
                                         clearInterval(this.myTimer);
                                     }
                                 },
                                 mounted:function(){
                                     this.myTimer=setInterval(()=>{
                                         this.myOpacity+=0.1;
                                         if(this.myOpacity>=1){
                                             this.myOpacity=0;
                                         }
                                     },300)
                                 }
                             });
                             new Vue({
                                 el: '#app',
                                 data: {
                                     msg: "Hello World"
                                 }
                             });
                            </script>
         10. watch和 computed
             (1) watch 侦（监）听器，用于对数据进行侦听，前提是*结合双向数据绑定**
                 watch:{  msg: function(new,old){
                     // new 变化后的数据
                     //old 变化前的数据
                 }  }
                 ex:<div id="app">
                     <input type="text" v-model="msg"/>
                    </div>
                    <script>
                     new Vue({
                         el: '#app',
                         data: {
                             msg: "Hello World"
                         },
                         watch:{
                             msg:function(newVal,oldVal){--------msg与data中监听的数据名称一致
                                 console.log(newVal);
                                 console.log(oldVal);
                             }
                         }
                     });
                    </script>
             (2) computed计算属性，用于处理一些复杂的业务逻辑
                 1.创建
                     computed: {
                     myComp: function(){   }
                     }
                 2.视图中调用
                     {{myComp}}
                 3.和methods中方法的对比？
                     computed中计算属性含有缓存，如果执行的内容相同，只执行一次；methods中的方法有多少次就执行多少次。
                     ex:<div id="app">
                            {{myFun()}}<!--方法直接调用必须加()-->
                            {{myFun()}}
                            {{myFun()}}
                            <br>
                            {{myComp}}<!--计算属性不能加括号-->
                            {{myComp}}
                            {{myComp}}
                        </div>
                        <script>
                            new Vue({
                                el: '#app',
                                data: {
                                    msg: 'hello vue'
                                },
                                methods: {
                                    myFun: function () {
                                        console.log('自定义方法执行了');
                                    }
                                },
                                computed: {
                                    myComp: function () {
                                        console.log('计算属性调用了');
                                    }
                                }
                            });
                        </script>
                 4.练习：
                     实现todos
                     ex:<div id="app">
                        	<todobox></todobox>
                        </div>
     
                        <script>
                        	Vue.component('todobox',{
                        		template:`
                        			<div>
                        				<todoinput></todoinput>
                        				<todolist></todolist>
                        			</div>
                        		`
                        	});
                        	Vue.component('todoinput',{
                        		template:`
                        			<div>
                        				<h1>待做事项列表</h1>
                        				<form action="#">
                        					<input type="text" placeholder="输入项目..."/>
                        					<button>Add</button>
                        				</form>
                        			</div>
                        		`
                        	});
                        	Vue.component('todolist',{
                        		template:`
                        			<ul>
                        				<todoitem></todoitem>
                        				<todoitem></todoitem>
                        			</ul>
                        		`
                        	});
                        	Vue.component('todoitem',{
                        		template:`
                        				<li v-if="bool">
                        					<button @click="del">delete</button>
                        					<span>健身</span>
                        				</li>
                        		`,
                        		data:function(){
                        			return {
                        				bool:true
                        			}
                        		},
                        		methods:{
                        			del:function(){
                        				this.bool=false
                        			}
                        		}
                        	});
                        	new Vue({
                        		el: '#app',
                        		data: {
                        			msg: "Hello World",
                        			bool:false
                        		}
                        	});
                        </script>
         11.组件之间的数据传递：
             1.父组件传递给子组件数据（父传子）
                  父组件 传递   <son pname="1"></son>
                  子组件 接收   props: [ 'pname' ]
                  ex:<div id="app">
                     	<my-header></my-header>
                     </div>
                     <script>
                     	Vue.component('my-header',{
                     		template:`
                     			<div>
                     				<h2>网页头部</h2>
                     				<my-cart pname="香蕉" pid="100"></my-cart>-----①必须在父组件中的子组件命名
                     			</div>
                     		`
                     	});
                     	Vue.component('my-cart',{
                     		data:function(){
                     			return {
                     				num:1
                     			}
                     		},
                     		template:`
                     			<h3>{{num}}这是购物车:{{pname}}--{{pid}}</h3>-----②在子组件中表达式使用
                     		`,
                     		props:['pname','pid']---------------------------------③props属性下保存变量
                     	});
                     	new Vue({
                     		el: '#app',
                     		data: {
                     			msg: "Hello World"
                     		}
                     	});
                     </script>
                  ex:登录组件嵌套   my-login   my-input  my-button
                      <div id="app">
                         <my-login></my-login>
                      </div>
                      <script>
                         Vue.component('my-login',{
                             template:`
                                 <form>
                                     <h2>用户登录</h2>
                                     <my-input pname="用户名" myid="myname" mytype="text"></my-input>
                                     <my-input pname="密码" myid="mypwd" mytype="password"></my-input>
                                     <my-button myval="登录"></my-button>
                                     <my-button myval="注册"></my-button>
                                 </form>
                             `
                         });
                         Vue.component('my-input',{
                             template:`
                                 <div>
                                     <label :for="myid">{{pname}}</label>
                                     <input :type="mytype" :id="myid" />
                                 </div>
                             `,
                             props:['pname','myid','mytype']
                         });
                         Vue.component('my-button',{
                             template:`
                                 <button>{{myval}}</button>
                             `,
                             props:['myval']
                         });
                         new Vue({
                             el: '#app',
                             data: {
                                 msg: "Hello World"
                             }
                         });
                      </script>
             2. 子组件传递给父组件数据（子传父）
                  原理：需要在父组件中创建一个自定义事件，子组件触发这个父组件中自定义的事件
                  第一步：父组件（接收）
                      <son @customEvent="rcvMsg"></son>
                      methods: {
                         rcvMsg: function(msg){  msg就是传递的数据  }
                      }
                  第二步：子组件(发送)
                      this.$emit('customEvent', 'mydata');
                      ex:<div id="app">
                             <father></father>
                         </div>
                         <script>
                             Vue.component('father',{
                                 template:`
                                     <div>
                                         <h2>这是小头爸爸</h2>
                                         <son @customEvent="rcvMsg"></son>--------①父组件中子元素设置接收事件，且命名触发事件
                                     </div>
                                 `,
                                 methods:{
                                     rcvMsg:function(msg){-------------②携带接收参数
                                         console.log(msg)
                                     }
                                 }
                             });
                             Vue.component('son',{
                                 template:`
                                     <div>
                                         <h3>这是大头儿子</h3>
                                         <button @click="handleClick">大头说：</button>-------③点击发送事件
                                     </div>
                                 `,
                                 methods:{
                                     handleClick:function(){
                                         this.$emit('customEvent','hi,小头同志你好');---------④发送触发事件及事件内容
                                     }
                                 }
                             });
                             new Vue({
                                 el: '#app',
                                 data: {}
                             });
                         </script>
                      ex：实现聊天室功能
                          my-chatroom   展示用户列表信息(ul  li )
                          my-user       每个用户组件（label  input  button）
                          <div id="app">
                              <my-chatroom></my-chatroom>
                          </div>
                          <script>
                              Vue.component('my-chatroom',{
                                  data:function(){
                                      return {
                                          //记录聊天信息
                                          list:[]
                                      }
                                  },
                                  template:`
                                      <div>
                                          <ul>
                                              <li v-for="temp in list">{{temp}}</li>
                                          </ul>
                                          <my-user @send="rcvMsg"  uname="lily" uid="lilyid"></my-user>
                                          <my-user @send="rcvMsg" uname="lucy" uid="lucyid"></my-user>
                                      </div>
                                  `,
                                  methods:{
                                      rcvMsg:function(myMsg){
                                          this.list.push(myMsg);
                                      }
                                  }
                              });
                              Vue.component('my-user',{
                                  data:function(){
                                       return {
                                           msg:''
                                       }
                                   },
                                  template:`
                                      <div>
                                          <label :for="uid">{{uname}}</label>
                                          <input type="text" :id="uid" v-model="msg">
                                          <button @click="handleClick">发送</button>
                                      </div>
                                  `,
                                  methods:{
                                      handleClick:function(){
                                          this.$emit('send',this.uname+':'+this.msg);
                                          //发送成功，清空表单中数据
                                          this.msg='';
                                      }
                                  },
                                  props:['uname','uid']
                              });
                              new Vue({
                                  el: '#app',
                                  data: {}
                              });
                          </script>
             3. 直接获取子组件中数据
                  ① 给子组件设置ref属性（起别名）
                  ② 在父组件中， this.$refs.myson.dataName
                  ex:<div id="app">
                         <father></father>
                     </div>
                     <script>
                         Vue.component('father',{
                             template:`
                                 <div>
                                     <h2>这是父组件</h2>
                                     <son ref="myson"></son>----------------①父组件中的子组件设置ref属性，起别名
                                     <button @click="handleClick">按钮</button>----------②点击触发事件
                                 </div>
                             `,
                             methods:{
                                 handleClick:function(){
                                     //直接获取子组件数据referrence
                                     console.log(this.$refs.myson.uname);---------------③触发事件内容：获取子组件中uname数据
                                 }
                             }
                         });
                         Vue.component('son',{
                             data:function(){
                                 return {
                                     uname:'大头儿子'----------------③子组件中被获取的数据
                                 }
                             },
                             template:`
                                 <div>
                                     <h3>这是子组件</h3>
                                 </div>
                             `
                         });
                         new Vue({
                             el: '#app',
                             data: {}
                         });
                     </script>
             4. 直接获取父组件中数据
                 在子组件中  this.$parent.dataName
                 ex:<div id="app">
                        <father></father>
                    </div>
                    <script>
                        Vue.component('father',{
                            data:function(){
                                return {
                                    uname:'小头爸爸'-----------------①父组件中被获取的uanme数据
                                }
                            },
                            template:`
                                <div>
                                    <h2>这是父组件</h2>
                                    <son></son>
                                </div>
                            `
                        });
                        Vue.component('son',{
                            template:`
                                <div>
                                    <h3>这是子组件</h3>
                                    <button @click="handleClick">按钮</button>-------------②点击事件触发获取事件
                                </div>
                            `,
                            methods:{
                                handleClick:function(){
                                    //获取父组件数据
                                    console.log(this.$parent.uname);--------------③获取父组件数据事件内容
                                }
                            }
                        });
                        new Vue({
                            el: '#app',
                            data: {}
                        });
                    </script>
             5. 兄弟组件之间传递数据
                   ①需要创建总线   var bus = new Vue();
                   ②接收方 需要创建自定义的事件
                         在created生命周期函数中，绑定事件
                         bus.$on('customEvent', (msg)=>{ //msg就是接收的数据  })--------------箭头函数解决this问题
                   ③发送方 触发接收方的自定义事件
                         bus.$emit('customEvent', 'dataMsg')
                   练习：熊二回复熊大 "俺来了"
                      <div id="app">
                          <xiongda></xiongda>
                          <hr>
                          <xionger></xionger>
                      </div>
                      <script>
                          var bus=new Vue();----------------------------①创建总线
                          Vue.component('xiongda',{
                              created:function(){
                                  bus.$on('rcvEventX2',function(msg){
                                      console.log('熊二说：'+msg)
                                  });
                              },
                              template:`
                                  <div>
                                      <h3>这是熊大</h3>
                                      <button @click="sendX2">通知熊二</button>-----------④点击事件触发发送事件
                                  </div>
                              `,
                              methods:{
                                  sendX2:function(){
                                      //触发熊二中自定义事件
                                      bus.$emit('rcvEventX1','光头强又来砍树了')-----发送事件中自定义事件名称和发送内容
                                  }
                              }
                          });
                          Vue.component('xionger',{
                              created:function(){---------------------------------②接收方在created钩子函数中创建接收事件
                                  //创建自定义事件
                                  bus.$on('rcvEventX1',function(msg){-------------③接收msg数据
                                      console.log('熊大说：'+msg)
                                  });
                              },
                              template:`
                                  <div>
                                      <h3>这是熊二</h3>
                                      <button @click="sendX1">通知熊大</button>
                                  </div>
                              `,
                              methods:{
                                  sendX1:function(){
                                      bus.$emit('rcvEventX2','俺来了')
                                  }
                              }
                          });
                          new Vue({
                              el: '#app',
                              data: {}
                          });
                      </script>
                   练习：
                      实现todos中，todo-input中点击发送，传递数据到todo-list
                      <div id="app">
                          <todo-box></todo-box>
                      </div>
                      <script>
                          var bus=new Vue();
                          Vue.component('todo-box',{
                              template:`
                      			<div>
                      				<todo-input></todo-input>
                      				<todo-list></todo-list>
                      			</div>
                      		`
                          });
                          Vue.component('todo-input',{
                              data:function(){
                                  return{
                                      msg:''
                                  }
                              },
                              template:`
                      			<div>
                      				<h1>待做事项列表</h1>
                                      <input type="text" placeholder="输入项目..." v-model="msg"/>
                                      <button @click="sendMsg">Add</button>
                      			</div>
                      		`,
                              methods:{
                                  sendMsg:function(){
                                      bus.$emit('addEvent',this.msg);
                                      this.msg='';
                                  }
                              }
                          });
                          Vue.component('todo-list',{
                              data:function(){
                                  return {
                                      list:[]
                                  }
                              },
                              created:function(){
                                  bus.$on('addEvent',(msg)=>{
                                      this.list.push(msg);
                                  });
                              },
                              template:`
                      			<ul>
                      				<todo-item v-for="(temp,index) in list" :key="index" :item="temp"></todo-item>
                      			</ul>
                      		`
                          });
                          Vue.component('todo-item',{
                              template:`
                                  <li v-if="bool">
                                      <button @click="del">delete</button>
                                      <span>{{item}}</span>
                                  </li>
                      		 `,
                              props:['item'],
                              data:function(){
                                  return {
                                      bool:true
                                  }
                              },
                              methods:{
                                  del:function(){
                                      this.bool=false
                                  }
                              }
                          });
                          new Vue({
                              el: '#app',
                              data: {
                                  msg: "Hello World",
                                  bool:false
                              }
                          });
                      </script>
         12. 动画&过渡
              transition: all 0.5s linear 0s;
              vue动画是需要结合着显示/隐藏
              1.默认的动画类名
                   .v-enter/.v-leave-to    进场前/离开后
                   .v-enter-active/.v-leave-active 进场后/开始离开
                 显示动画的位置，添加
                   <transition> 动画的内容 </transition>
              2.指定的动画类名
                    1.先创建  .fade-enter/.fade-leave-to ....
                    2.调用
                       <transition name="fade">...</transtion>
                    3.durantion 控制动画的时间
                        duration="100"  进出场时间相同
                        :duration="{enter:100, leave:200}"
                    ex:<style>
                               .v-enter,.v-leave-to{
                                   transform:translate(200px);
                                   opacity: 0;
                               }
                               .v-enter-active,.v-leave-active{
                                   transition:all .5s;
                               }
                               /*其他类型动画*/
                               .fade-enter,.fade-leave-to{
                                   transform:translateY(200px);
                               }
                               .fade-enter-active,.fade-leave-active{
                                   transition:all .5s;
                               }
                       </style>
                       </head>
                       <body>
                       <div id="app">
                           <button @click="show=!show">显示隐藏</button>
                           <transition duration="100">
                               <h2 v-if="show">{{msg}}</h2>
                           </transition>
                           <hr>
                           <br>
                           <button @click="show2=!show2">切换2</button>
                           <transition name="fade" :duration="{enter:100,leave:500}">
                               <h1 v-if="show2">动画的区域</h1>
                           </transition>
                       </div>
                       <script>
                           new Vue({
                               el: '#app',
                               data: {
                                   msg:"hello",
                                   show:true,
                                   show2:true
                               }
                           });
                       </script>
              3.使用第三方动画（animate.css）
                    ① 引入 <link href="animate.css" />
                    ② <transition enter-active-class="animated zoomIn" leave-active-class="animated zoomOut">
                    ex:<head>
                           <meta charset="UTF-8">
                           <title>Title</title>
                           <script src="js/vue.js"></script>
                           <link rel="stylesheet" href="css/animate.css">
                       </head>
                       <body>
                       <div id="app">
                           <button @click="show=!show">按钮</button>
                           <transition enter-active-class="animated zoomIn" leave-active-class="animated zoomOut">
                               <h2 v-if="show">{{msg}}</h2>
                           </transition>
                       </div>
                       <script>
                           new Vue({
                               el: '#app',
                               data: {
                                   msg:'hello',
                                   show:false
                               }
                           });
                       </script>
         13. 创建组件的其它方式
              (1)指定组件中的模板为外部的模板
                  创建:
                  <script type="text/x-template" id="mycom">
                     <div>...</div>
                  </script>
                  使用:  template: '#mycom'
              (2) 使用.vue文件创建组件
                 <template>模板中的标签</template>
                 <script>组件的js代码</script>
                 <style></style>
                  ex:<div id="app">
                         {{msg}}
                         <my-com></my-com>
                         <!--创建模板-->
                         <script type="text/x-template" id="mycomponent">
                             <div>
                                 <h2>标题</h2>
                                 <p>段落</p>
                             </div>
                         </script>
                     </div>
     
                     <script>
                         Vue.component('my-com',{
                            template:"#mycomponent"
                         });
                         new Vue({
                             el: '#app',
                             data: {}
                         });
                     </script>
              ex：实现todos中，点击删除按钮，删除父组件中对应的数据
                 <div id="app">
                     <todo-box></todo-box>
                 </div>
                 <script>
                     var bus=new Vue();
                     Vue.component('todo-box',{
                         template:`
                 			<div>
                 				<todo-input></todo-input>
                 				<todo-list></todo-list>
                 			</div>
                 		`
                     });
                     Vue.component('todo-input',{
                         data:function(){
                             return{
                                 msg:''
                             }
                         },
                         template:`
                 			<div>
                 				<h1>待做事项列表</h1>
                                 <input type="text" placeholder="输入项目..." v-model="msg"/>
                                 <button @click="sendMsg">Add</button>
                 			</div>
                 		`,
                         methods:{
                             sendMsg:function(){
                                 bus.$emit('addEvent',this.msg);
                                 this.msg='';
                             }
                         }
                     });
                     Vue.component('todo-list',{
                         data:function(){
                             return {
                                 list:[]
                             }
                         },
                         created:function(){
                             bus.$on('addEvent',(msg)=>{
                                 this.list.push(msg);
                                 console.log(this.list);
                             });
                         },
                         template:`
                 			<ul>
                 				<todo-item v-for="(temp,index) in list" :key="index" :item="temp" :myid="index" @customEvent="rcvMsg"></todo-item>
                 			</ul>
                 		`,
                         methods:{
                             rcvMsg:function(id){
                                 console.log(id);
                                 this.list.splice(id,1);
                             }
                         }
                     });
                     Vue.component('todo-item',{
                         template:`
                             <li>
                                 <button @click="del">delete</button>
                                 <span>{{item}}</span>
                             </li>
                 		`,
                         props:['item','myid'],
                         methods:{
                             del:function(){
                                 this.$emit('customEvent',this.myid)
                             }
                         }
                     });
                     new Vue({
                         el: '#app',
                         data: {
                             msg: "Hello World",
                             bool:false
                         }
                     });
                 </script>
         14.路由
              1. 路由是用来建立组件和路径之间的对应关系。
                  通过gmail页面
                         路径     组件
                         #all     所有邮件
                         #inbox  收件箱
                         #imp    重要邮件
                  通过路由可以实现局部刷新
                  SPA - single page application  单页应用
              2. 路由的使用步骤
                  ① 引入 vue-router.js
                  ② 创建组件切换的区域 <router-view></router-view>
                  ③ 创建所需要的组件
                      var allComponent = Vue.component('all-com', {});
                      ....
                  ④ 使用路由插件配置路由
                     var myRouter = new VueRouter({
                     routes: [ //路径和组件对应关系
                             {path: '', component: home},
                         {path: '/all', component: allComponent },
                             ....
                           ]
                         });
                     注意事项：
                       如果path为空表示页面，默认显示的路由
                  ⑤ 把配置好的路由注册到当前vue实例
                        new Vue({
                       router: myRouter
                        });
                  练习： 登录 注册 路由切换
                  <script src="js/vue.js"></script>
                      <script src="js/vue-router.js"></script>
                  </head>
                  <body>
                  <div id="app">
                      <router-view></router-view>
                  </div>
                  <script>
                      var loginComponent =  Vue.component('login', {
                          template: `
                              <h2>这是登录组件</h2>
                          `
                      });
                      var regComponent = Vue.component('reg', {
                          template: `
                              <h2>请注册</h2>
                          `
                      });
                      //配置路由
                      var myRouter = new VueRouter({
                          routes: [
                              // login   loginComponent
                              // reg     regComponent
                              {path: '/login', component: loginComponent},
                              {path: '/reg', component: regComponent}
                          ]
                      });
                      new Vue({
                          el: '#app',
                          data: {
                              msg: 'hello vue'
                          },
                          router: myRouter
                      });
                  </script>
              3. 路由跳转
                   ①  <router-link to="/home">首页</router-link>
                       router-link会被渲染成a标签
                   ②  this.$router.push('/home');   js的方式跳转
                   ex:<script src="js/vue.js"></script>
                          <script src="js/vue-router.js"></script>
                      </head>
                      <body>
                      <div id="app">
                          <router-view></router-view>
                      </div>
                      <script>
                          // 首页组件  学习用品
                          var myHome = Vue.component('index', {
                              template: `
                                  <div>
                                      <h2>这是首页</h2>
                                      <router-link to="/study">学习</router-link>
                                  </div>
                              `
                          });
                          var myStudy = Vue.component('study', {
                              template: `
                                  <div>
                                      <h3>这是学习用品</h3>
                                      <router-link to="/home">回到首页</router-link>
                                      <button @click="handleClick">首页</button>
                                  </div>
                              `,
                              methods: {
                                  handleClick: function () {
                                      //通过js跳转
                                      this.$router.push('/home');
                                  }
                              }
                          });
                          var myRouter = new VueRouter({
                              routes: [
                                  {path: '', component: myHome},
                                  {path: '/home', component: myHome},
                                  {path: '/study', component: myStudy}
                              ]
                          });
                          new Vue({
                              el: '#app',
                              data: {
                                  msg: 'hello vue'
                              },
                              router: myRouter
                          });
                      </script>
              4. 参数传递
                   ① 在路由配置中，设置接收参数的名称
                     {path: '/article/:myid', component: ..}
                   ② 接收
                      this.$route.params.myid
                      ex:<script src="js/vue.js"></script>
                             <script src="js/vue-router.js"></script>
                         </head>
                         <body>
                         <div id="app">
                             <router-view></router-view>
                         </div>
                         <script>
                             var listComponent = Vue.component('list', {
                                 data: function () {
                                     return {
                                         plist: [1,2,3,4]
                                     }
                                 },
                                 template: `
                                    <div>
                                         <h2>笔记本列表</h2>
     
                                         <ul>
                                             <li v-for="tmp in plist">
                                             <router-link :to="'/article/'+tmp">{{tmp}}</router-link>
                                             </li>
                                         </ul>
                                    </div>
                                 `
                             });
                             var articleComponent = Vue.component('article', {
                                 data: function () {
                                    return {
                                        myid: ''
                                    }
                                 },
                                 created: function () {
                                     //接收传递的参数
                                     //并且把接收的参数放入到myid
                                     this.myid = this.$route.params.lid;
                                 },
                                 template: `
                                     <div>
                                         <h2>这是商品详情-{{myid}}</h2>
                                     </div>
                                 `
                             });
                             var myRouter = new VueRouter({
                                 routes: [
                                     {path: '', component: listComponent},
                                     {path: '/list', component: listComponent},
                                     {path: '/article/:lid', component: articleComponent}
                                 ]
                             });
                             new Vue({
                                 el: '#app',
                                 data: {
                                     msg: 'hello vue'
                                 },
                                 router: myRouter
                             });
                         </script>
              5. 路由嵌套
                   new VueRouter({
                  routes: [
                     {path: '/login', component: login.., children:[
                         //在这个位置可以书写嵌套的路由配置
                         ]}
                      ]
                   })
                   ex:<script src="js/vue.js"></script>
                          <script src="js/vue-router.js"></script>
                      </head>
                      <body>
                      <div id="app">
                          <router-view></router-view>
                      </div>
                      <script>
                          var loginCom = Vue.component('login', {
                              template: `
                                  <div>
                                      <h2>登录组件</h2>
                                      <router-link to="/member">会员中心</router-link>
                                      <router-link to="/order">订单中心</router-link>
                                      <router-link to="/place">收货地址</router-link>
                                      <router-view></router-view>
                                  </div>
                              `
                          });
                          var regCom = Vue.component('reg', {
                              template: `
                                  <div>
                                      <h2>这是注册组件</h2>
                                      <router-link to="/login">请登录</router-link>
                                  </div>
                              `
                          });
                          var memberCom = Vue.component('member', {
                              template: `<h2>这是会员中心组件</h2>`
                          });
                          var orderCom = Vue.component('order', {
                              template: `<h2>这是订单中心组件</h2>`
                          });
                          var placeCom = Vue.component('place', {
                              template: `<h2>这是收货地址组件</h2>`
                          });
                          var myRouter = new VueRouter({
                              routes: [
                                  {path: '', component: regCom},
                                  {path: '/reg', component: regCom},
                                  {
                                      path: '/login',
                                      component: loginCom,
                                      children: [
                                          {path: '', component: memberCom},
                                          {path: '/member', component: memberCom},
                                          {path: '/order', component: orderCom},
                                          {path: '/place', component: placeCom}
                                      ]
                                  }
                              ]
                          });
                          new Vue({
                              el: '#app',
                              data: {
                                  msg: 'hello vue'
                              },
                              router: myRouter
                          });
                      </script>
     -----------------------------------------------------angular------------------------------------------------------------
     chrome
     -----------------------------------------------------React--------------------------------------------------------------
     facebook
####--------------------------------------------------------git------------------------------------------------------------
#####1.修改用户信息
         git config --global user.name "John Doe"
         git config --global user.email johndoe@example.com
#####2.获取帮助
         git  --help
#####3.获得config命令手册
         git help config
#####4.克隆仓库
         git clone https://github.com/ligit                 (直接克隆)
         git clone https:.......   myTest                   (对仓库重命名)
#####5.查看当前文件状态
         git  status
#####6.添加内容到下一次提交中
         git add   +文件名
#####7.状态简览
         git status -s    (可以显示简图)
         ?? .idea/        (新添加未跟踪文件)
          M notes.txt     (文件被修改，但未放入暂存区)  M在右边
         M  notes.txt     (文件被修改，并放入了暂存区)  M在左边
         A  notes.txt     (新添加到暂存区的文件)
         MM notes.txt     (修改过的文件)
#####8.gitignore
         glob模式    shell使用的简化了的正则表达式
         1.所有空行或以#开头的行都会被git忽略
         2.可使用标准glob模式匹配
         3.匹配模式可以用./开头，防止递归
         4.匹配模式以/结尾指定目录
         5.要忽略指定模式以外的文件或目录，可在模式前加上！取反
         6.* 匹配0个或者多个任意字符
         7.[abc]匹配任何一个列在方括号里的字符
         8.？只匹配一个任意字符，如果在方括号中使用短划线分割两个字符，表示所有在这两个字符范围内的都可以匹配、
         9.** 两个星，匹配任意中间目录
#####9.提交已add过的文件===phpstorm中的ctrl+k
         git commit -m "..."        (引号中为提交的信息)
         [master ]
     
     
     
     
     
     
     
     --------------------------------------------------------备忘------------------------------------------------------------
     1.api参数写成对象形势
     2.命名形式
     3.git的操作
     4.注释的写法
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

#####提交
ghijkgghjk

```
console.log("dsagdsa")
```
